[{"categories":["PHP","Laravel"],"content":" 原文 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:0:0","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"介绍 由于 HTTP 驱动的应用程序是无状态的，因此会话提供了一种跨多个请求存储有关用户的信息的方法。 该用户信息通常放置在可从后续请求访问的持久性存储/后端中。 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:1:0","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"配置 应用程序的会话配置文件存储在config/session.php。 默认情况下，Laravel配置使用database会话驱动程序。 会话driver配置选项定义每个请求的会话数据的存储位置。 Laravel包括多种驱动程序： file：会话存储在storage/framework/sessions cookie：会话存储在安全、加密的Cookie中 database：会话存储在关系型数据库中 memcached/Redis：会话存储在基于缓存的快速存储之一 dynamodb：会话存储在AWS DynamoDB中 array：会话存储在PHP数据中，不会被持久化 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:1:1","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"驱动程序先决条件 Database 需要确保有一个数据库表来包含会话数据。 通常，这包含在 Laravel 的默认 0001_01_01_000000_create_users_table.php 数据库迁移中; 但是，如果没有 sessions 表，则可以使用 make:session-table Artisan 命令生成此迁移： php artisan make:session-table php artisan migrate Redis 需要通过 PECL 安装 PhpRedis PHP 扩展或通过 Composer 安装 predis/predis 软件包 （~1.0）。 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:1:2","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"会话交互 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:2:0","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"检索数据 在 Laravel 中处理会话数据有两种主要方式：全局 session 帮助程序和通过 Request 实例。 通过 Request 实例访问会话，该实例可以在路由闭包或控制器方法上进行类型提示。 \u003c?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use Illuminate\\View\\View; class UserController extends Controller { /** * Show the profile for the given user. */ public function show(Request $request, string $id): View { $value = $request-\u003esession()-\u003eget('key'); // ... $user = $this-\u003eusers-\u003efind($id); return view('user.profile', ['user' =\u003e $user]); } } 从会话中检索项时，还可以将默认值作为第二个参数传递 get 给方法。 如果会话中不存在指定的key，则将返回此默认值。 如果将闭包作为默认值传递给方法， get 并且请求的键不存在，则将执行闭包并返回其结果： $value = $request-\u003esession()-\u003eget('key', 'default'); $value = $request-\u003esession()-\u003eget('key', function () { return 'default'; }); 全局会话助手 还可以使用全局 session PHP 函数在会话中检索和存储数据。 当使用单个字符串参数调用 session 帮助程序时，它将返回该会话键的值。 当使用键/值对数组调用帮助程序时，这些值将存储在会话中： Route::get('/home', function () { // Retrieve a piece of data from the session... $value = session('key'); // Specifying a default value... $value = session('key', 'default'); // Store a piece of data in the session... session(['key' =\u003e 'value']); }); 检索所有会话数据 all方法检索会话中的所有数据 $data = $request-\u003esession()-\u003eall(); 检索会话数据的一部分 only 和 except 方法可用于检索会话数据的子集 $data = $request-\u003esession()-\u003eonly(['username', 'email']); $data = $request-\u003esession()-\u003eexcept(['username', 'email']); 确定会话中是否存在项目 has方法可以确定会话中是否存在某个项目。 如果项目存在并且不是null，则返回true if ($request-\u003esession()-\u003ehas('users')) { // ... } 要确定会话中是否存在某个项目，即使其值为 null ，也可以使用以下 exists 方法： if ($request-\u003esession()-\u003eexists('users')) { // ... } 要确定会话中是否不存在某个项目，可以使用该 missing 方法。 如果项不存在，则该 missing 方法返回 true ： if ($request-\u003esession()-\u003emissing('users')) { // ... } ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:2:1","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"存储数据 put方法或者全局session帮助程序都可以将数据存储在会话中 // Via a request instance... $request-\u003esession()-\u003eput('key', 'value'); // Via the global \"session\" helper... session(['key' =\u003e 'value']); 推送到数组会话值 push方法可用于将新值推送到作为数组的会话值上 $request-\u003esession()-\u003epush('user.teams', 'developers'); 检索和删除项目 pull方法将在单个语句中从会话中检索和删除项目 $value = $request-\u003esession()-\u003epull('key', 'default'); 递增和递减会话值 使用 increment 和 decrement 方法可以将会话数据中包含的整数进行自增或递减 $request-\u003esession()-\u003eincrement('count'); $request-\u003esession()-\u003eincrement('count', $incrementBy = 2); $request-\u003esession()-\u003edecrement('count'); $request-\u003esession()-\u003edecrement('count', $decrementBy = 2); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:2:2","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"闪存数据 flash方法可以在会话中存储项目以备下一个请求使用。 使用此方法存储在会话中的数据将立即可用，并在随后的 HTTP 请求期间可用。后续 HTTP 请求后，烧录的数据将被删除。 闪存数据主要用于短期状态消息。 $request-\u003esession()-\u003eflash('status', 'Task was successful!'); reflash方法为多个请求保留闪存数据。 该方法保留其他请求的所有闪存数据。 $request-\u003esession()-\u003ereflash(); 如果需要保留特定的闪存数据，则可以使用keep方法。 $request-\u003esession()-\u003ekeep(['username', 'email']); 要仅保留当前的闪存数据，可以使用now方法。 $request-\u003esession()-\u003enow('status', 'Task was successful!'); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:2:3","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"删除数据 forget方法将从会话中删除一段数据。 如果要删除所有数据，可以使用flush方法 // Forget a single key... $request-\u003esession()-\u003eforget('name'); // Forget multiple keys... $request-\u003esession()-\u003eforget(['name', 'status']); $request-\u003esession()-\u003eflush(); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:2:4","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"重新生成会话ID 重新生成会话 ID 通常是为了防止恶意用户利用对应用程序的会话固定攻击。 手动重新生成会话ID，可以使用regenerate方法 $request-\u003esession()-\u003eregenerate(); invalidate方法可以在单个语句中重新生成会话ID并从会话中删除所有数据 $request-\u003esession()-\u003einvalidate(); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:2:5","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"会话阻止 若要利用会话阻止，应用程序必须使用支持原子锁的缓存驱动程序。目前，这些缓存驱动程序包括 memcached 、 dynamodb 、 redis 、 database file 和 array 驱动程序。此外，不能使用 cookie 会话驱动程序。 Laravel提供允许限制给定会话的并发请求的功能。只需将 block 方法链接到路由定义上即可。 在此示例中，对 /profile 终端节点的传入请求将获取会话锁。 在保持此锁时，对共享相同会话 ID 的 /profile 或 /order 终结点的任何传入请求都将等待第一个请求完成执行，然后再继续执行： Route::post('/profile', function () { // ... })-\u003eblock($lockSeconds = 10, $waitSeconds = 10) Route::post('/order', function () { // ... })-\u003eblock($lockSeconds = 10, $waitSeconds = 10) 该 block 方法接受两个可选参数。该 block 方法接受的第一个参数是会话锁定在释放之前应保留的最大秒数。当然，如果请求在此时间之前完成执行，则锁将提前释放。 该 block 方法接受的第二个参数是请求在尝试获取会话锁时应等待的秒数。如果请求无法在给定的秒数内获得会话锁，则将抛出 Illuminate\\Contracts\\Cache\\LockTimeoutException异常。 如果这两个参数均未传递，则在尝试获取锁时，将最多获取 10 秒，请求最多等待 10 秒： Route::post('/profile', function () { // ... })-\u003eblock() ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:3:0","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"自定义会话驱动程序 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:4:0","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"实现驱动程序 自定义会话驱动程序应实现PHP的SessionHandlerInterface内置接口。 \u003c?php namespace App\\Extensions; class MongoSessionHandler implements \\SessionHandlerInterface { public function open($savePath, $sessionName) {} public function close() {} public function read($sessionId) {} public function write($sessionId, $data) {} public function destroy($sessionId) {} public function gc($lifetime) {} } Laravel 不附带包含扩展的目录。可以自由地将它们放置在任何地方。在此示例中，创建了一个 Extensions 目录来容纳 MongoSessionHandler 。 open：通常用于基于文件的会话存储系统。由于 Laravel 附带了 file 会话驱动程序，因此很少需要在此方法中添加任何内容。可以简单地将此方法留空。 close：与open方法一样，通常可以忽略不计 read：应返回与给定$sessionId关联的会话数据的字符串版本。在驱动程序中检索或存储会话数据时，无需执行任何序列化或其他编码，因为Laravel将主动执行序列化。 write：应将与关联的 $sessionId 给定 $data 字符串写入某些持久性存储系统，例如 MongoDB 或选择的其他存储系统。同样，不应该执行任何序列化 ，因为 Laravel 已经处理了。 destroy：应从持久性存储中删除与 关联 $sessionId 的数据。 gc：应销毁所有早于给定 $lifetime 的会话数据，即 UNIX 时间戳。对于像 Memcached 和 Redis 这样的自过期系统，此方法可能留空。 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:4:1","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":"注册驱动程序 实现驱动程序后，即可将其注册到 Laravel。 要向 Laravel 的会话后端添加其他驱动程序，可以使用 Session Facade 提供 extend 的方法。 应从服务提供商 boot 的方法调用该 extend 方法。 可以从现有 App\\Providers\\AppServiceProvider 提供程序中执行此操作，也可以创建一个全新的提供程序： \u003c?php namespace App\\Providers; use App\\Extensions\\MongoSessionHandler; use Illuminate\\Contracts\\Foundation\\Application; use Illuminate\\Support\\Facades\\Session; use Illuminate\\Support\\ServiceProvider; class SessionServiceProvider extends ServiceProvider { /** * Register any application services. */ public function register(): void { // ... } /** * Bootstrap any application services. */ public function boot(): void { Session::extend('mongo', function (Application $app) { // Return an implementation of SessionHandlerInterface... return new MongoSessionHandler; }); } } 注册会话驱动程序后，可以使用 SESSION_DRIVER 环境变量或在应用程序的 config/session.php 配置文件中将 mongo 驱动程序指定为应用程序的会话驱动程序。 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/:4:2","tags":["PHP","Laravel"],"title":"Laravle 11.x 会话","uri":"/2024/06/laravel11%E4%BC%9A%E8%AF%9D/"},{"categories":["PHP","Laravel"],"content":" 原文 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:0:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"创建响应 字符串和数组 Laravel框架会自动将字符串转换为完整的HTTP相应： Route::get('/', function () { return 'Hello World'; }); 会自动将数组转换为JSON响应： Route::get('/', function () { return [1, 2, 3]; }); 响应对象 通过返回完整Response实例，可以自定义相应的HTTP状态码和标头。 Response应继承自Symfony\\Component\\HttpFoundation\\Response类 Route::get('/home', function () { return response('Hello World', 200) -\u003eheader('Content-Type', 'text/plain'); }); Eloquent模型和控制器 可以直接从路由和控制器返回Eloquent ORM模型和集合。会自动将模型和集合转换为JSON响应，同时遵循模型的隐藏属性： use App\\Models\\User; Route::get('/user/{user}', function (User $user) { return $user; }); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:1:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"将Headers附加到响应 header方法为响应添加一系列标头 return response($content) -\u003eheader('Content-Type', $type) -\u003eheader('X-Header-One', 'Header Value') -\u003eheader('X-Header-Two', 'Header Value'); withHeaders方法指定要添加到响应中的标头数组 return response($content) -\u003ewithHeaders([ 'Content-Type' =\u003e $type, 'X-Header-One' =\u003e 'Header Value', 'X-Header-Two' =\u003e 'Header Value', ]); 缓存控制中间件 Laravel包含一个cache.headers中间件，可用于快速设置一组路由Cache-Control的标头。 指令应使用与相应缓存控制指令等效的“蛇形大小写”来提供，并应用分号分隔。 如果 etag 在指令列表中指定，则响应内容的 MD5 哈希值将自动设置为 ETag 标识符： Route::middleware('cache.headers:public;max_age=2628000;etag')-\u003egroup(function () { Route::get('/privacy', function () { // ... }); Route::get('/terms', function () { // ... }); }); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:1:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"将Cookie附加到响应 cookie方法将cookie附加到Illuminate\\Http\\Response实例 return response('Hello World')-\u003ecookie( 'name', 'value', $minutes ); 还接受一些不太频繁使用的参数。通常，这些参数与 PHP 的原生 setcookie 方法的参数具有相同的目的和含义： return response('Hello World')-\u003ecookie( 'name', 'value', $minutes, $path, $domain, $secure, $httpOnly ); 如果想确保在发送响应时附带一个 cookie，但还没有该响应的实例，可以使用 Cookie facade 来将 cookie “队列化”，以便在发送响应时附加到响应上。 queue 方法接受创建 cookie 实例所需的参数。 这些 cookie 将在发送到浏览器之前附加到传出的响应上： use Illuminate\\Support\\Facades\\Cookie; Cookie::queue('name', 'value', $minutes); 生成Cookie实例 如果想生成一个可以稍后附加到响应实例的 Symfony\\Component\\HttpFoundation\\Cookie 实例，可以使用全局 cookie 辅助函数。 除非该 cookie 被附加到响应实例，否则它不会发送回客户端： $cookie = cookie('name', 'value', $minutes); return response('Hello World')-\u003ecookie($cookie); 提前过期Cookie 可以通过传出响应 withoutCookie 的方法使 cookie 过期来删除 cookie： return response('Hello World')-\u003ewithoutCookie('name'); 如果还没有传出响应的实例，则可以使用 Cookie Facade expire 的方法使 cookie 过期： Cookie::expire('name'); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:1:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"Cookie加密 默认情况下，由于 Illuminate\\Cookie\\Middleware\\EncryptCookies 中间件的存在，Laravel 生成的所有 cookie 都经过加密和签名，因此客户端无法修改或读取它们。 如果想禁用应用程序生成的 cookie 子集的加密，可以使用应用程序 bootstrap/app.php 文件中的方法 encryptCookies ： -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003eencryptCookies(except: [ 'cookie_name', ]); }) ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:1:3","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"重定向 重定向响应是 Illuminate\\Http\\RedirectResponse 类的实例，包含将用户重定向到另一个 URL 所需的正确标头。有几种方法可以生成 RedirectResponse 实例。最简单的方法是使用全局 redirect 帮助程序： Route::get('/dashboard', function () { return redirect('home/dashboard'); }); 有时，需要将用户重定向到其以前的位置，例如当提交的表单无效时。可以使用全局 back 帮助程序函数来执行此操作。由于此功能利用会话，因此请确保调用函数的 back 路由使用 web 中间件组： Route::post('/user/profile', function () { // Validate the request... return back()-\u003ewithInput(); }); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:2:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"重定向到命名路由 当调用不带参数的 redirect 帮助程序时，将返回一个实例 Illuminate\\Routing\\Redirector ，允许调用 Redirector 实例上的任何方法。 例如，要生成 RedirectResponse 到命名路由，可以使用以下 route 方法： return redirect()-\u003eroute('login'); 如果路由具有参数，则可以将它们作为第二个参数传递给 route 方法： // For a route with the following URI: /profile/{id} return redirect()-\u003eroute('profile', ['id' =\u003e 1]); 通过Eloquent模型填充参数 如果要重定向到具有“ID”参数的路由，该路由是从 Eloquent 模型填充的，则可以传递模型本身。将自动提取 ID： // For a route with the following URI: /profile/{id} return redirect()-\u003eroute('profile', [$user]); 如果要自定义放置在路由参数中的值，可以在路由参数定义 （ /profile/{id:slug} ） 中指定列，也可以在 Eloquent 模型上重写该 getRouteKey 方法： /** * Get the value of the model's route key. */ public function getRouteKey(): mixed { return $this-\u003eslug; } ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:2:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"重定向至控制器操作 还可以生成指向控制器操作的重定向。为此，请将控制器和操作名称传递给 action 方法： use App\\Http\\Controllers\\UserController; return redirect()-\u003eaction([UserController::class, 'index']); 如果控制器路由需要参数，则可以将它们作为第二个参数传递给 action 方法： return redirect()-\u003eaction( [UserController::class, 'profile'], ['id' =\u003e 1] ); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:2:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"重定向到外部域 可以通过调用该 away 方法重定向到应用程序外的域。 该方法将 RedirectResponse 创建一个无需任何其他 URL 编码、验证或验证的方法： return redirect()-\u003eaway('https://www.google.com'); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:2:3","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"使用闪存的会话数量重定向 重定向到新 URL 和将数据刷入会话通常同时完成。 通常，这是在成功执行操作后，当向会话刷新成功消息时完成的。 为方便起见，可以创建一个 RedirectResponse 实例，并在单个流畅的方法链中将数据闪存到会话中： Route::post('/user/profile', function () { // ... return redirect('dashboard')-\u003ewith('status', 'Profile updated!'); }); 重定向用户后，可以显示会话中闪烁的消息。例如，使用 Blade 语法： @if (session('status')) \u003cdiv class=\"alert alert-success\"\u003e {{ session('status') }} \u003c/div\u003e @endif 使用输入重定向 在将用户重定向到新位置之前，可以使用 RedirectResponse 实例提供 withInput 的方法将当前请求的输入数据刷新到会话。 如果用户遇到验证错误，通常会执行此操作。 将输入切换到会话后，可以在下一次请求重新填充表单时轻松检索它： return back()-\u003ewithInput(); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:2:4","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"其他响应类型 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:3:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"View 响应 return response() -\u003eview('hello', $data, 200) -\u003eheader('Content-Type', $type); 如果不需要传递自定义 HTTP 状态码或自定义标头，则可以使用全局 view 帮助程序函数。 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:3:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"JSON 响应 该 json 方法会自动将 Content-Type 标头设置为 application/json ，并使用 json_encode PHP 函数将给定的数组转换为 JSON： return response()-\u003ejson([ 'name' =\u003e 'Abigail', 'state' =\u003e 'CA', ]); 如果要创建 JSONP 响应，可以将该 json 方法与以下 withCallback 方法结合使用 return response() -\u003ejson(['name' =\u003e 'Abigail', 'state' =\u003e 'CA']) -\u003ewithCallback($request-\u003einput('callback')); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:3:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"文件下载 该 download 方法可用于生成响应，强制用户的浏览器在给定路径下载文件。 该 download 方法接受文件名作为该方法的第二个参数，该参数将确定下载文件的用户看到的文件名。 最后，可以将 HTTP 标头数组作为第三个参数传递给该方法： return response()-\u003edownload($pathToFile); return response()-\u003edownload($pathToFile, $name, $headers); 流下载 该 streamDownload 方法可用于将给定操作的字符串响应转换为可下载的响应，而无需将操作的内容写入磁盘。 此方法接受回调、文件名和可选的标头数组作为其参数： use App\\Services\\GitHub; return response()-\u003estreamDownload(function () { echo GitHub::api('repo') -\u003econtents() -\u003ereadme('laravel', 'laravel')['contents']; }, 'laravel-readme.md'); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:3:3","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"文件响应 该 file 方法可用于直接在用户的浏览器中显示文件（如图像或 PDF），而不是启动下载。 此方法接受文件的绝对路径作为其第一个参数，并接受标头数组作为其第二个参数： return response()-\u003efile($pathToFile); return response()-\u003efile($pathToFile, $headers); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:3:4","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":"响应宏 如果要定义可在各种路由和控制器中重复使用的自定义响应，则可以在 Response 外观上使用该 macro 方法。 通常，应从应用程序的服务提供商之一（如 App\\Providers\\AppServiceProvider 服务提供商） boot 的方法调用此方法： \u003c?php namespace App\\Providers; use Illuminate\\Support\\Facades\\Response; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /** * Bootstrap any application services. */ public function boot(): void { Response::macro('caps', function (string $value) { return Response::make(strtoupper($value)); }); } } 该 macro 函数接受名称作为其第一个参数，接受闭包作为其第二个参数。从 ResponseFactory 实现或 response 帮助程序调用宏名称时，将执行宏的闭包： return response()-\u003ecaps('foo'); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E5%93%8D%E5%BA%94/:4:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 响应","uri":"/2024/06/laravel11%E5%93%8D%E5%BA%94/"},{"categories":["PHP","Laravel"],"content":" 原文 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:0:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"介绍 Laravel 的 Illuminate\\Http\\Request 类提供了一种面向对象的方式来与当前应用程序处理的 HTTP 请求进行交互，同时可以检索请求中提交的输入、Cookies 和文件。 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:1:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"请求交互 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:2:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"访问请求 通过依赖注入进行获取当前HTTP请求的实例： \u003c?php namespace App\\Http\\Controllers; use Illuminate\\Http\\RedirectResponse; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Store a new user. */ public function store(Request $request): RedirectResponse { $name = $request-\u003einput('name'); // Store the user... return redirect('/users'); } } 同样的也可以在闭包中使用： use Illuminate\\Http\\Request; Route::get('/', function (Request $request) { // ... }); 依赖注入和路由参数 如果控制器方法也需要来自路由参数的输入，则应该在其他依赖项之后列出路由参数。 例如，路由定义如下： use App\\Http\\Controllers\\UserController; Route::put('/user/{id}', [UserController::class, 'update']); 那么控制器就应该按照以下方式进行定义： \u003c?php namespace App\\Http\\Controllers; use Illuminate\\Http\\RedirectResponse; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Update the specified user. */ public function update(Request $request, string $id): RedirectResponse { // Update the user... return redirect('/users'); } } ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:2:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"请求路由、主机和方法 检索请求路径 path方法返回请求的路径信息。 $uri = $request-\u003epath(); 检查请求路径/路由 is方法允许验证传入请求路径是否与给定模式匹配。 可以将*字符用作通配符 if ($request-\u003eis('admin/*')) { // ... } routeIs方法，可以确定出入请求是否与命名路由匹配： if ($request-\u003erouteIs('admin.*')) { // ... } 检索请求URL url或fullUrl方法可以检索传入请求的完整URL。 url方法将返回不带查询字符串的URL fullUrl方法返回的URL包含查询字符串 $url = $request-\u003eurl(); $urlWithQueryString = $request-\u003efullUrl(); fullUrlWithQuery方法，可以将查询字符串数据追加到当前URL。 此方法将给定的查询字符串变量数组与当前查询字符串合并 $request-\u003efullUrlWithQuery(['type' =\u003e 'phone']); fullUrlWithoutQuery方法在没有给定查询字符串参数的情况下获取当前URL $request-\u003efullUrlWithoutQuery(['type']); 检索请求主机 host、httpHost和schemeAndHttpHost方法可以检索传入请求的主机 $request-\u003ehost(); $request-\u003ehttpHost(); $request-\u003eschemeAndHttpHost(); 检索请求方法 method方法将返回请求的方式 isMethod方法用来验证HTTP请求方式是否与给定字符串匹配 $method = $request-\u003emethod(); if ($request-\u003eisMethod('post')) { // ... } ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:2:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"请求标头 header方法从Illuminate\\Http\\Request实例中检索请求标头。 如果不存在，则返回null，header方法接受可选的第二个参数，如果不存在，则使用此参数 $value = $request-\u003eheader('X-Header-Name'); $value = $request-\u003eheader('X-Header-Name', 'default'); hasHeader方法用于确定请求是否包含给定的标头 if ($request-\u003ehasHeader('X-Header-Name')) { // ... } bearerToken方法可用于从Authorization标头中检索持有者令牌。 如果不存在，则返回空字符串 $token = $request-\u003ebearerToken(); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:2:3","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"请求IP地址 ip方法用于检索发出请求的IP地址 $ipAddress = $request-\u003eip(); ips方法可以检索IP地址数组，包括代理转发的所有客户端IP地址 原始客户端IP地址将位于数组的末尾 $ipAddresses = $request-\u003eips(); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:2:4","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"内容协商 Laravel 提供了几种方法，用于通过 Accept 标头检查传入请求的请求内容类型。 getAcceptableContentTypes方法返回一个数组，其中包含请求接受的所有内容类型。 $contentTypes = $request-\u003egetAcceptableContentTypes(); accepts方法接受内容类型的数组， 如果请求接受任何内容类型，则返回true，否则false if ($request-\u003eaccepts(['text/html', 'application/json'])) { // ... } prefers方法用来确定请求在给定的一组内容类型中最喜欢哪种内容类型。 如果请求不接受所提供的任何内容类型，则会返回null $preferred = $request-\u003eprefers(['text/html', 'application/json']); expectsJson方法用于快速确定传入请求是否需要JSON响应 if ($request-\u003eexpectsJson()) { // ... } ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:2:5","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"PRS-7 请求 PSR-7 标准指定了 HTTP 消息的接口，包括请求和响应。如果要获取 PSR-7 请求的实例而不是 Laravel 请求，则首先需要安装一些库。Laravel 使用 Symfony HTTP 消息桥接组件将典型的 Laravel 请求和响应转换为兼容 PSR-7 的实现： composer require symfony/psr-http-message-bridge composer require nyholm/psr7 安装后，就可以通过在路由闭包或控制器方法上键入提示请求接口来获取PSR-7请求： use Psr\\Http\\Message\\ServerRequestInterface; Route::get('/', function (ServerRequestInterface $request) { // ... }); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:2:6","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"输入 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:3:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"检索输入 检索所有输入数据 all方法检索array所有传入入请求的输入数据。 无论请求来组HTML表单还是XHR请求，都适用。 $input = $request-\u003eall(); collect方法可以将传入请求的所有输入数据作为集合检索 $input = $request-\u003ecollect(); collect方法还允许将传入的输入的子集作为集合检索 $request-\u003ecollect('users')-\u003eeach(function (string $user) { // ... }); 检索输入值 input方法用于检索用户输入 无参数调用，将所有输入值作为关联数组检索 $name = $request-\u003einput('name'); $input = $request-\u003einput(); // 如果请求的输入值不存在，则可以设置默认值： $name = $request-\u003einput('name', 'Sally'); 使用.表示法访问数组 $name = $request-\u003einput('products.0.name'); $names = $request-\u003einput('products.*.name'); 从查询字符串中检索输入 query方法将仅从查询字符串中检索值 无参数调用，将所有查询字符串值检索为关联数组 $name = $request-\u003equery('name'); $name = $request-\u003equery('name', 'Helen'); // 不存在则使用给定的默认值 $name = $request-\u003equery('name', 'Helen'); 检索JSON输入值 发送JSON请求时，只要请求Content-Type=application/json就可以通过input方法访问JSON数据。 也可以使用.语法来检索嵌套在JSON数组/对象中的值 $name = $request-\u003einput('user.name'); 检索字符串输入值 string方法可以将请求数据作为Illuminate\\Support\\Stringable实例进行检索 $name = $request-\u003estring('name')-\u003etrim(); 检索布尔值输入值 boolean方法将请求数据检索为布尔值 $archived = $request-\u003eboolean('archived'); 检索日期输入值 date方法将包含日期/时间的输入值作为Carbon实例进行检索。 如果不存在，则返回null $birthday = $request-\u003edate('birthday'); date方法接受的第二三参数可以分别用于指定日期的格式和时区 如果格式无效，则会抛出InvalidArgumentException异常 $elapsed = $request-\u003edate('elapsed', '!H:i', 'Europe/Madrid'); 检索枚举输入值 enum方法可以从请求中检索与PHP枚举相对应的输入值。 如果请求不包括具有给定名称的输入值，或者枚举没有输入值匹配的支持值，则返回null enum方法接受输入值的名称和枚举类作为其第一二参数 use App\\Enums\\Status; $status = $request-\u003eenum('status', Status::class); 通过动态属性检索输入 可以使用Illuminate\\Http\\Request实例上的动态属性访问用户输入 $name = $request-\u003ename; 检索部分输入数据 only和except方法可以检索输入数据的子集 两个方法都接受单个array或动态参数列表 only方法不会返回请求中不存在的键值对 $input = $request-\u003eonly(['username', 'password']); $input = $request-\u003eonly('username', 'password'); $input = $request-\u003eexcept(['credit_card']); $input = $request-\u003eexcept('credit_card'); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:3:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"输入状态 has方法可以确定请求中是否存在值。存在返回true if ($request-\u003ehas('name')) { // ... } has还可以接收一个数组，那么将确定是否存在所有指定的值 if ($request-\u003ehas(['name', 'email'])) { // ... } hasAny如果存在任意指定值，则返回true if ($request-\u003ehasAny(['name', 'email'])) { // ... } whenHas方法如果请求上存在值则将执行给定的闭包 $request-\u003ewhenHas('name', function (string $input) { // ... }); whenHas方法，如果请求中不存在指定的值，则可以将第二个闭包传递给将要执行的方法中 $request-\u003ewhenHas('name', function (string $input) { // The \"name\" value is present... }, function () { // The \"name\" value is not present... }); filled方法用来确定请求中是否存在值并且不是空字符串 if ($request-\u003efilled('name')) { // ... } anyFilled方法如果任意一个指定的值不是空字符串，则返回true if ($request-\u003eanyFilled(['name', 'email'])) { // ... } whenFilled如果请求上存在值并且不是空字符串，将执行给定的闭包 $request-\u003ewhenFilled('name', function (string $input) { // ... }); whenFilled如果不存在，则可以传递第二个闭包进行处理 $request-\u003ewhenFilled('name', function (string $input) { // The \"name\" value is filled... }, function () { // The \"name\" value is not filled... }); missing和whenMissing方法用于确定请求中是否缺少给定的key if ($request-\u003emissing('name')) { // ... } $request-\u003ewhenMissing('name', function () { // The \"name\" value is missing... }, function () { // The \"name\" value is present... }); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:3:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"合并其他输入 merge方法，用于手动将其他输入合并到请求的现有输入数据中。 如果请求中已存在给定的输入key，则将会被覆盖掉 $request-\u003emerge(['votes' =\u003e 0]); 如果请求的输入数据中尚不存在响应的key，则mergeIfMissing方法可用于将输入合并到请求中 $request-\u003emergeIfMissing(['votes' =\u003e 0]); 刷新会话输入 flash方法将刷新会话的当前输入。 以便在用户对应用程序的下一个请求期间可用 $request-\u003eflash(); flashOnly 和 flashExcept 方法用于将敏感信息排除在会话之外 $request-\u003eflashOnly(['username', 'email']); $request-\u003eflashExcept('password'); 刷新输入并重定向 withInput方法可以刷新输入并进行重定向 return redirect('form')-\u003ewithInput(); return redirect()-\u003eroute('user.create')-\u003ewithInput(); return redirect('form')-\u003ewithInput( $request-\u003eexcept('password') ); 检索旧输入 old方法将从会话中提取先前刷新的输入数据 $username = $request-\u003eold('username'); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:3:3","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"Cookies 从请求中检索Cookie cookie方法将从请求中进行检索Cookie值 $value = $request-\u003ecookie('name'); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:3:4","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"输入修整和归一化 默认情况下，Laravel将Illuminate\\Foundation\\Http\\Middleware\\TrimStrings and Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull中间件包含在应用程序的全局中间件中了。这些中间件将自动修剪请求上的所有输入字符串字段，并将任何空字符串转换为null 禁用输入归一化 如果要对所有请求禁用此行为，可以通过调用应用程序 bootstrap/app.php 文件中 $middleware-\u003eremove 的方法从应用程序的中间件中删除两个中间件： use Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull; use Illuminate\\Foundation\\Http\\Middleware\\TrimStrings; -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003eremove([ ConvertEmptyStringsToNull::class, TrimStrings::class, ]); }) 如果想要在应用程序中禁用对一部分请求的字符串修剪和空字符串转换，可以在应用程序的 bootstrap/app.php 文件中使用 trimStrings 和 convertEmptyStringsToNull 中间件方法。这两个方法都接受一个闭包数组，闭包应返回 true 或 false，以指示是否应跳过输入的规范化处理： -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003econvertEmptyStringsToNull(except: [ fn (Request $request) =\u003e $request-\u003eis('admin/*'), ]); $middleware-\u003etrimStrings(except: [ fn (Request $request) =\u003e $request-\u003eis('admin/*'), ]); }) ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:3:5","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"文件 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:4:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"检索上传的文件 file/Illuminate\\Http\\Request动态属性用于检索上传的文件 file方法返回Illuminate\\Http\\UploadedFile类实例， $file = $request-\u003efile('photo'); $file = $request-\u003ephoto; hasFile方法确定请求中是否存在文件 if ($request-\u003ehasFile('photo')) { // ... } 验证成功上传 isValid方法用于验证上传文件是否成功 if ($request-\u003efile('photo')-\u003eisValid()) { // ... } 文件路径和扩展名 该 UploadedFile 类还包含用于访问文件的完全限定路径及其扩展名的方法。 该 extension 方法将尝试根据文件的内容猜测文件的扩展名。 此扩展可能与客户端提供的扩展不同 $path = $request-\u003ephoto-\u003epath(); $extension = $request-\u003ephoto-\u003eextension(); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:4:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"存储上传的文件 UploadedFile类的store方法将上传的文件移动到磁盘中，该磁盘可以是本地文件系统某一位置，也可以是 Amazon S3等云存储位置 store方法接受存储文件的路径，此路径不包含文件名，自动生成唯一ID作为文件名 $path = $request-\u003ephoto-\u003estore('images'); $path = $request-\u003ephoto-\u003estore('images', 's3'); 如果不想自动生成文件名，则可以使用路径、文件名和磁盘名称作为其参数storeAs的方法 $path = $request-\u003ephoto-\u003estoreAs('images', 'filename.jpg'); $path = $request-\u003ephoto-\u003estoreAs('images', 'filename.jpg', 's3'); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:4:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"配置受信任的代理 启用Laravel应用程序中包含的Illuminate\\Http\\Middleware\\TrustProxies中间件，可以快速自定义应用程序应信任的负载均衡或代理。 使用bootstrap/app.php文件中的trustProxies中间件方法指定受信任的代理： -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003etrustProxies(at: [ '192.168.1.1', '192.168.1.2', ]); }) 也可以配置应受信任的代理标头： -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003etrustProxies(headers: Request::HEADER_X_FORWARDED_FOR | Request::HEADER_X_FORWARDED_HOST | Request::HEADER_X_FORWARDED_PORT | Request::HEADER_X_FORWARDED_PROTO | Request::HEADER_X_FORWARDED_AWS_ELB ); }) 信任所有代理 -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003etrustProxies(at: '*'); }) ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:5:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":"配置受信任的主机 启动Illuminate\\Http\\Middleware\\TrustHosts 中间件来实现配置受信任的主机。 在 bootstrap/app.php 文件中调用 trustHosts 中间件方法。使用此方法的 at 参数，可以指定应用程序应响应的主机名。带有其他 Host 标头的传入请求将被拒绝： -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003etrustHosts(at: ['laravel.test']); }) 默认情况下，来自应用程序 URL 的子域的请求也会自动受信任。如果要禁用此行为，可以使用以下 subdomains 参数： -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003etrustHosts(at: ['laravel.test'], subdomains: false); }) ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/:6:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 请求","uri":"/2024/06/laravel11%E8%AF%B7%E6%B1%82/"},{"categories":["PHP","Laravel"],"content":" 原文 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:0:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"介绍 与其在路由文件中将所有请求处理逻辑定义为闭包，也可以使用\"controller\"类来组织这些行为。 控制器可以将相关的请求逻辑分组到一个类中。 默认情况下，控制器存储在app/Http/Controllers目录中。 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:1:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"编写控制器 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:2:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"基本控制器 使用make:controller命令快速生成新控制器 php artisan make:controller UserController 控制器可以有任意数量的公共方法，这些方法将响应传入的HTTP请求： \u003c?php namespace App\\Http\\Controllers; use App\\Models\\User; use Illuminate\\View\\View; class UserController extends Controller { public function show(string $id): View { return view('user.profile', [ 'user' =\u003e User::findOrFail($id) ]); } } 编写控制器类和方法后，可以定义控制器方法的路由： use App\\Http\\Controllers\\UserController; Route::get('/user/{id}', [UserController::class, 'show']); 控制器不需要继承基类。然而，有时继承一个包含所有控制器通用方法的基控制器类会更方便。 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:2:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"单动作控制器 如果一个控制器动作特别复杂，为这个单一动作专门创建一个控制类会更方便。 可以在控制器中定义一个单一的__invoke方法。 可以使用make:controller命令--invokable选项生成单一动作控制器： php artisan make:controller ProvisionServer --invokable \u003c?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class ProvisionServer extends Controller { /** * Handle the incoming request. */ public function __invoke(Request $request) { // } } 在为单动作控制器注册路由时，不需要指定控制器方法。相反，可以简单地将控制器的名称传递给路由器： use App\\Http\\Controllers\\ProvisionServer; Route::post('/server', ProvisionServer::class); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:2:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"控制器中间件 中间件可以在路由文件中分配给控制器的路由。 Route::get('profile', [UserController::class, 'show'])-\u003emiddleware('auth'); 也可以在控制器类中指定中间件。只需控制器实现HasMiddleware接口，该接口规定控制器应具有静态middleware方法。从次方法中，可以返回一个中间件数组，该数组应用于控制器的操作： \u003c?php namespace App\\Http\\Controllers; use App\\Http\\Controllers\\Controller; use Illuminate\\Routing\\Controllers\\HasMiddleware; use Illuminate\\Routing\\Controllers\\Middleware; class UserController extends Controller implements HasMiddleware { /** * Get the middleware that should be assigned to the controller. */ public static function middleware(): array { return [ 'auth', new Middleware('log', only: ['index']), new Middleware('subscribed', except: ['store']), ]; } // ... } 还可以讲控制器中间件定义成闭包，这提供了一种方便的形式来定义内联中间件，而无需编写整个中间件类： use Closure; use Illuminate\\Http\\Request; /** * Get the middleware that should be assigned to the controller. */ public static function middleware(): array { return [ function (Request $request, Closure $next) { return $next($request); }, ]; } ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:3:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"资源控制器 使用make:controller命令的--resource选项，快速创建控制器的CRUD操作： php artisan make:controller PhotoController --resource 此命令将在app/Http/Controllers/PhotoController.php 生成一个控制器。该控制器将包含每个可用资源操作的方法。 \u003c?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class PhotoController extends Controller { /** * Display a listing of the resource. */ public function index() { // } /** * Show the form for creating a new resource. */ public function create() { // } /** * Store a newly created resource in storage. */ public function store(Request $request) { // } /** * Display the specified resource. */ public function show(string $id) { // } /** * Show the form for editing the specified resource. */ public function edit(string $id) { // } /** * Update the specified resource in storage. */ public function update(Request $request, string $id) { // } /** * Remove the specified resource from storage. */ public function destroy(string $id) { // } } 然后就可以注册一个指向该控制器的资源路由： use App\\Http\\Controllers\\PhotoController; Route::resource('photos', PhotoController::class); 也可以通过将数组传递给resources方法来一次注册多个资源控制器： Route::resources([ 'photos' =\u003e PhotoController::class, 'posts' =\u003e PostController::class, ]); 自定义缺失的模型行为 通常，如果未找到隐式绑定的资源模型，将生成一个 404 HTTP 响应。 然而，可以在定义资源路由时通过调用missing 方法来自定义此行为。 missing 方法接受一个闭包，如果在任何资源路由中找不到隐式绑定的模型，该闭包将被调用： use App\\Http\\Controllers\\PhotoController; use Illuminate\\Http\\Request; use Illuminate\\Support\\Facades\\Redirect; Route::resource('photos', PhotoController::class) -\u003emissing(function (Request $request) { return Redirect::route('photos.index'); }); 软删除模型 通常，隐式模型绑定不会检索已软删除的模型，而是返回 404 HTTP 响应。 然而，可以在定义资源路由时调用 withTrashed 方法来指示框架允许软删除的模型： use App\\Http\\Controllers\\PhotoController; Route::resource('photos', PhotoController::class)-\u003ewithTrashed(); 调用不带参数的 withTrashed 方法将允许 show、edit 和 update 资源路由处理软删除的模型。 可以通过传递一个数组给 withTrashed 方法来指定这些路由的子集。 Route::resource('photos', PhotoController::class)-\u003ewithTrashed(['show']); 指定资源模型 如果使用路由模型绑定，并希望资源控制器的方法类型提示模型实例，那么可以在生成控制器时使用 --model 选项。 php artisan make:controller PhotoController --model=Photo --resource 生成表单请求 在生成资源控制器时，可以使用 --requests 选项生成表单请求类，以供控制器的存储（create）和更新（update）方法使用。 php artisan make:controller PhotoController --model=Photo --resource --requests ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:4:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"部分资源路由 声明资源路由时，可以指定控制器应处理的操作子集，而不是完成的默认操作集： use App\\Http\\Controllers\\PhotoController; Route::resource('photos', PhotoController::class)-\u003eonly([ 'index', 'show' ]); Route::resource('photos', PhotoController::class)-\u003eexcept([ 'create', 'store', 'update', 'destroy' ]); API 资源路由 在声明将由 API 使用的资源路由时，可以使用apiResource方法自动排除提供 HTML 模板（如 create 和 edit ）的路由： use App\\Http\\Controllers\\PhotoController; Route::apiResource('photos', PhotoController::class); 同样，也可以通过将数组传递给apiResource方法一次注册多个API资源控制器： use App\\Http\\Controllers\\PhotoController; use App\\Http\\Controllers\\PostController; Route::apiResources([ 'photos' =\u003e PhotoController::class, 'posts' =\u003e PostController::class, ]); 可以通过make:controller命令的--api快速生成API资源路由： php artisan make:controller PhotoController --api ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:4:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"嵌套资源 为了嵌套资源控制器，可以在路由声明中使用.符号： use App\\Http\\Controllers\\PhotoCommentController; Route::resource('photos.comments', PhotoCommentController::class); // /photos/{photo}/comments/{comment} 浅层嵌套 通常情况下，不必在 URI 中同时包含父资源和子资源的 ID，因为子资源的 ID 已经是唯一标识符。 当使用自增主键等唯一标识符来识别模型在 URI 段中时，可以选择使用 “浅嵌套”： use App\\Http\\Controllers\\CommentController; Route::resource('photos.comments', CommentController::class)-\u003eshallow(); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:4:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"命名资源路由 默认情况下，所有资源控制器操作都具有路由名称，可以通过传递具有所需路由名称的name数据来覆盖这些名称： use App\\Http\\Controllers\\PhotoController; Route::resource('photos', PhotoController::class)-\u003enames([ 'create' =\u003e 'photos.build' ]); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:4:3","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"命名资源路由参数 默认情况下，Route::resource 根据资源名称的单数形式创建资源路由的路由参数。 可以轻松地在每个资源基础上使用 parameters 方法覆盖这一行为。 传递给 parameters 方法的数组应该是资源名称和参数名称的关联数组。 use App\\Http\\Controllers\\AdminUserController; Route::resource('users', AdminUserController::class)-\u003eparameters([ 'users' =\u003e 'admin_user' ]); // URI // /users/{admin_user} ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:4:4","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"确定资源路由的范围 Laravel 的作用域隐式模型绑定功能可以自动将嵌套绑定作用域化，以确保解析的子模型确实属于父模型。 通过在定义嵌套资源时使用 scoped 方法启用自动作用域化，并指示 Laravel 使用哪个字段来检索子资源： use App\\Http\\Controllers\\PhotoCommentController; Route::resource('photos.comments', PhotoCommentController::class)-\u003escoped([ 'comment' =\u003e 'slug', ]); // URI // /photos/{photo}/comments/{comment:slug} ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:4:5","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"本地化资源URI 默认情况下，Route::resource 会使用英语动词和复数规则创建资源的 URI。 如果需要本地化 create 和 edit 动作的动词，可以使用 Route::resourceVerbs 方法。 这可以在应用程序的 App\\Providers\\AppServiceProvider 中的 boot 方法开始时完成： /** * Bootstrap any application services. */ public function boot(): void { Route::resourceVerbs([ 'create' =\u003e 'crear', 'edit' =\u003e 'editar', ]); } ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:4:6","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"补充资源控制器 如果需要在资源控制器之外添加额外的路由，超出了默认的资源路由集合，应该在调用 Route::resource方法之前定义这些路由；否则，资源方法定义的路由可能会意外地优先于补充路由： use App\\Http\\Controller\\PhotoController; Route::get('/photos/popular', [PhotoController::class, 'popular']); Route::resource('photos', PhotoController::class); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:4:7","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"单例资源控制器 有时，应用程序会有一些资源只能有单个实例，那么可以注册一个singleton资源控制器： use App\\Http\\Controllers\\ProfileController; use Illuminate\\Support\\Facades\\Route; Route::singleton('profile', ProfileController::class); 单例实例资源也可以嵌套在标准资源中： Route::singleton('photos.comments', CommentController::class); 可创建的单例资源 可以在注册单例实例资源路由时调用creatable方法： Route::singleton('photos.thumbnail', ThumbnailController::class)-\u003ecreatable(); 使用destroyable方法注册单例资源的DELETE路由，但不注册创建或存储路由： Route::singleton('photos.comments', CommentController::class)-\u003edestroyable(); API 单例资源 apiSingleton方法可用于注册API操作的单例资源： Route::apiSingleton('photos', PhotoController::class); 也可以使用creatable将资源注册store和destroy路由： Route::apiSingleton('photos', PhotoController::class)-\u003ecreatable(); 同样的destroyable方法依旧可用： Route::apiSingleton('photos', PhotoController::class)-\u003edestroyable(); ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:4:8","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"依赖注入和控制器 ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:5:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"构造函数注入 Laravel的服务容器用于解析所有的Laravel控制器。 因此，可以在控制器的构造函数中对控制器可能需要的任何依赖项进行类型提示。 声明的依赖项将自动被解析并注入到控制器实例中。 \u003c?php namespace App\\Http\\Controllers; use App\\Repositories\\UserRepository; class UserController extends Controller { /** * Create a new controller instance. */ public function __construct( protected UserRepository $users, ) {} } ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:5:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":"方法注入 除了构造函数注入外，还可以在控制器的方法中对依赖项进行类型提示。 一个常见的用例是在控制器方法中注入 Illuminate\\Http\\Request 实例： \u003c?php namespace App\\Http\\Controllers; use Illuminate\\Http\\RedirectResponse; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Store a new user. */ public function store(Request $request): RedirectResponse { $name = $request-\u003ename; // Store the user... return redirect('/users'); } } 如果控制器方法还需要从路由参数中获取输入，请在其他依赖项之后列出路由参数。 例如，如果路由定义如下所示： use App\\Http\\Controllers\\UserController; Route::put('/user/{id}', [UserController::class, 'update']); 仍然可以对 Illuminate\\Http\\Request 进行类型提示，并通过以下方式访问 id 参数，定义控制器方法如下所示: \u003c?php namespace App\\Http\\Controllers; use Illuminate\\Http\\RedirectResponse; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Update the given user. */ public function update(Request $request, string $id): RedirectResponse { // Update the user... return redirect('/users'); } } ","date":"2024年06月16日","objectID":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/:5:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 控制器","uri":"/2024/06/laravel11%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"categories":["PHP","Laravel"],"content":" 原文 ","date":"2024年06月16日","objectID":"/2024/06/laravel11csrf%E4%BF%9D%E6%8A%A4/:0:0","tags":["PHP","Laravel"],"title":"Laravel 11.x CSRF保护","uri":"/2024/06/laravel11csrf%E4%BF%9D%E6%8A%A4/"},{"categories":["PHP","Laravel"],"content":"介绍 跨站请求伪造（CSRF）是一种恶意利用方式，通过该方式未经授权的命令会代表已验证用户执行。 Laravel 提供了简单的方法来保护应用程序免受跨站请求伪造（CSRF）攻击的影响。 ","date":"2024年06月16日","objectID":"/2024/06/laravel11csrf%E4%BF%9D%E6%8A%A4/:1:0","tags":["PHP","Laravel"],"title":"Laravel 11.x CSRF保护","uri":"/2024/06/laravel11csrf%E4%BF%9D%E6%8A%A4/"},{"categories":["PHP","Laravel"],"content":"阻止 CSRF 请求 Laravel自动为应用程序管理的每个活动用户会话生成一个CSRF“token”。 此令牌用于验证已验证用户实际上是正在向应用程序发出请求的人。 由于此令牌存储在用户的会话中，并且每次会话重新生成时都会更改，因此恶意应用程序无法访问它。 可以通过请求的会话或者通过 csrf_token 辅助函数来访问当前会话的CSRF令牌 use Illuminate\\Http\\Request; Route::get('/token', function (Request $request) { $token = $request-\u003esession()-\u003etoken(); $token = csrf_token(); // ... }); 每当您定义一个 “POST”、“PUT”、“PATCH” 或 “DELETE” 的 HTML 表单时，都应该包含一个隐藏的 CSRF _token 字段，以便CSRF保护中间件可以验证请求。 为了方便起见，可以使用 @csrf Blade 指令来生成隐藏的令牌输入字段： \u003cform method=\"POST\" action=\"/profile\"\u003e @csrf \u003c!-- Equivalent to... --\u003e \u003cinput type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\" /\u003e \u003c/form\u003e Illuminate\\Foundation\\Http\\Middleware\\ValidateCsrfToken 中间件默认包含在 web 中间件组中，它会自动验证请求输入中的令牌是否与会话中存储的令牌匹配。当这两个令牌匹配时，就可以确定已验证的用户是发起请求的用户。 ","date":"2024年06月16日","objectID":"/2024/06/laravel11csrf%E4%BF%9D%E6%8A%A4/:2:0","tags":["PHP","Laravel"],"title":"Laravel 11.x CSRF保护","uri":"/2024/06/laravel11csrf%E4%BF%9D%E6%8A%A4/"},{"categories":["PHP","Laravel"],"content":"从CSRF保护中排除URI 有时需要从CSRF保护中排除一组URI。 -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003evalidateCsrfTokens(except: [ 'stripe/*', 'http://example.com/foo/bar', 'http://example.com/foo/*', ]); }) 为了方便起见，在运行tests时，所有路由都会自动禁用 CSRF 中间件。 ","date":"2024年06月16日","objectID":"/2024/06/laravel11csrf%E4%BF%9D%E6%8A%A4/:2:1","tags":["PHP","Laravel"],"title":"Laravel 11.x CSRF保护","uri":"/2024/06/laravel11csrf%E4%BF%9D%E6%8A%A4/"},{"categories":["PHP","Laravel"],"content":"X-CSRF-Token 除了检查作为 POST 参数的 CSRF 令牌外，默认包含在 web 中间件组中的 Illuminate\\Foundation\\Http\\Middleware\\ValidateCsrfToken 中间件还会检查 X-CSRF-TOKEN 请求头。 例如，将令牌存储在一个 HTML 元标记中。 \u003cmeta name=\"csrf-token\" content=\"{{ csrf_token() }}\"\u003e 然后，在发送 AJAX 请求时，可以从元标记中获取令牌，并将其包含在请求头中： let token = document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content'); fetch('/example', { method: 'POST', headers: { 'X-CSRF-TOKEN': token, 'Content-Type': 'application/json' }, body: JSON.stringify({ key: 'value' }) }); ","date":"2024年06月16日","objectID":"/2024/06/laravel11csrf%E4%BF%9D%E6%8A%A4/:3:0","tags":["PHP","Laravel"],"title":"Laravel 11.x CSRF保护","uri":"/2024/06/laravel11csrf%E4%BF%9D%E6%8A%A4/"},{"categories":["PHP","Laravel"],"content":"X-XSRF-Token Laravel 将当前的 CSRF 令牌存储在一个加密的 XSRF-TOKEN cookie 中，该 cookie 包含在框架生成的每个响应中。可以使用这个 cookie 的值来设置 X-XSRF-TOKEN 请求头。 例如，在发送 AJAX 请求时，可以从 XSRF-TOKEN cookie 中获取令牌，并将其包含在请求头中： let token = document.cookie.split('; ') .find(row =\u003e row.startsWith('XSRF-TOKEN=')) .split('=')[1]; fetch('/example', { method: 'POST', headers: { 'X-XSRF-TOKEN': token, 'Content-Type': 'application/json' }, body: JSON.stringify({ key: 'value' }) }); 这样，您的请求将包含 X-XSRF-TOKEN 请求头，用于验证 CSRF 令牌。 ","date":"2024年06月16日","objectID":"/2024/06/laravel11csrf%E4%BF%9D%E6%8A%A4/:4:0","tags":["PHP","Laravel"],"title":"Laravel 11.x CSRF保护","uri":"/2024/06/laravel11csrf%E4%BF%9D%E6%8A%A4/"},{"categories":["PHP","Laravel"],"content":" 原文 ","date":"2024年06月15日","objectID":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/:0:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 中间件","uri":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["PHP","Laravel"],"content":"介绍 中间件为检查和过滤进入应用程序的HTTP请求提供了一种便捷的机制。 ","date":"2024年06月15日","objectID":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 中间件","uri":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["PHP","Laravel"],"content":"定义中间件 make:middleware命令用于创建新的中间件。 php artisan make:middleware EnsureTokenIsValid 此命令将在app/Http/Middleware目录中放置一个新EnsureTokenIsValid类。 \u003c?php namespace App\\Http\\Middleware; use Closure; use Illuminate\\Http\\Request; use Symfony\\Component\\HttpFoundation\\Response; class EnsureTokenIsValid { /** * Handle an incoming request. * * @param \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response) $next */ public function handle(Request $request, Closure $next): Response { if ($request-\u003einput('token') !== 'my-secret-token') { return response('This action is unauthorized.', 401); } return $next($request); } } ","date":"2024年06月15日","objectID":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 中间件","uri":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["PHP","Laravel"],"content":"中间件和响应 中间件可以在将请求传递到应用程序更深处之前或之后执行任务。 例如，以下中间件会在请求被应用程序处理之前执行某些任务 \u003c?php namespace App\\Http\\Middleware; use Closure; use Illuminate\\Http\\Request; use Symfony\\Component\\HttpFoundation\\Response; class BeforeMiddleware { /** * Handle an incoming request. * * @param \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response) $next */ public function handle(Request $request, Closure $next): Response { // Perform action return $next($request); } } 以下中间件将在应用程序处理请求后执行其任务： \u003c?php namespace App\\Http\\Middleware; use Closure; use Illuminate\\Http\\Request; use Symfony\\Component\\HttpFoundation\\Response; class AfterMiddleware { /** * Handle an incoming request. * * @param \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response) $next */ public function handle(Request $request, Closure $next): Response { $response = $next($request); // Perform action return $response; } } ","date":"2024年06月15日","objectID":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 中间件","uri":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["PHP","Laravel"],"content":"注册中间件 ","date":"2024年06月15日","objectID":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/:3:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 中间件","uri":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["PHP","Laravel"],"content":"全局中间件 如果需要中间件在每个HTTP请求到达应用程序时都运行，那么可以将它附加到应用程序的全局中间件中，在应用程序的bootstrap/app.php文件中进行配置 use App\\Http\\Middleware\\EnsureTokenIsValid; -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003eappend(EnsureTokenIsValid::class); }) 在 withMiddleware 闭包中提供的 $middleware 对象是 Illuminate\\Foundation\\Configuration\\Middleware 的实例，负责管理分配给应用程序路由的中间件。append 方法将中间件添加到全局中间件列表的末尾。 如果需要将中间件添加到列表的开头，应该使用 prepend 方法。 手动管理Laravel默认全局中间件 可以使用use方法对Laravel提供的默认全局中间件进行手动管理，根据所需调整中间件使用： -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003euse([ // \\Illuminate\\Http\\Middleware\\TrustHosts::class, \\Illuminate\\Http\\Middleware\\TrustProxies::class, \\Illuminate\\Http\\Middleware\\HandleCors::class, \\Illuminate\\Foundation\\Http\\Middleware\\PreventRequestsDuringMaintenance::class, \\Illuminate\\Http\\Middleware\\ValidatePostSize::class, \\Illuminate\\Foundation\\Http\\Middleware\\TrimStrings::class, \\Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull::class, ]); }) ","date":"2024年06月15日","objectID":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/:3:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 中间件","uri":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["PHP","Laravel"],"content":"将中间件分配给路由 在定义路由时调用middleware方法将中间件分配给路由 use App\\Http\\Middleware\\EnsureTokenIsValid; Route::get('/profile', function () { // ... })-\u003emiddleware(EnsureTokenIsValid::class); 也可以将中间件名称数组传递给middleware方法，将多个中间件分配给路由： Route::get('/', function () { // ... })-\u003emiddleware([First::class, Second::class]); 排除中间件 当将中间件分配给一组路由时，需要防止某个中间件应用于该组中的某个单独路由。 可以使用 withoutMiddleware 方法来实现。 use App\\Http\\Middleware\\EnsureTokenIsValid; Route::middleware([EnsureTokenIsValid::class])-\u003egroup(function () { Route::get('/', function () { // ... }); Route::get('/profile', function () { // ... })-\u003ewithoutMiddleware([EnsureTokenIsValid::class]); }); 还可以从整个路由组定义中排除给定的一组中间件 use App\\Http\\Middleware\\EnsureTokenIsValid; Route::withoutMiddleware([EnsureTokenIsValid::class])-\u003egroup(function () { Route::get('/profile', function () { // ... }); }); 注意：withoutMiddleware 方法只能移除路由中的中间件，不能用于全局中间件。 ","date":"2024年06月15日","objectID":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/:3:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 中间件","uri":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["PHP","Laravel"],"content":"中间件组 将多个中间件分组到一个键下，以便更轻松分配给路由，可以使用应用程序bootstrap/app.php 文件中的方法 appendToGroup 完成此操作 use App\\Http\\Middleware\\First; use App\\Http\\Middleware\\Second; -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003eappendToGroup('group-name', [ First::class, Second::class, ]); $middleware-\u003eprependToGroup('group-name', [ First::class, Second::class, ]); }) 中间件组可以使用与单个中间件相同的语法分配给路由和控制器动作 Route::get('/', function () { // ... })-\u003emiddleware('group-name'); Route::middleware(['group-name'])-\u003egroup(function () { // ... }); Laravel默认的中间件组 web 中间件组 Illuminate\\Cookie\\Middleware\\EncryptCookies Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse Illuminate\\Session\\Middleware\\StartSession Illuminate\\View\\Middleware\\ShareErrorsFromSession Illuminate\\Foundation\\Http\\Middleware\\ValidateCsrfToken Illuminate\\Routing\\Middleware\\SubstituteBindings api 中间件组 Illuminate\\Routing\\Middleware\\SubstituteBindings 如果向这些组附加或前置中间件，可以在应用程序的 bootstrap/app.php 文件中使用 web 和 api 方法。web 和 api 方法是向组添加中间件的便捷替代方法，相当于 appendToGroup 方法。 use App\\Http\\Middleware\\EnsureTokenIsValid; use App\\Http\\Middleware\\EnsureUserIsSubscribed; -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003eweb(append: [ EnsureUserIsSubscribed::class, ]); $middleware-\u003eapi(prepend: [ EnsureTokenIsValid::class, ]); }) 也可以将Laravel的默认中间件条目之一替换为自定义中间件： use App\\Http\\Middleware\\StartCustomSession; use Illuminate\\Session\\Middleware\\StartSession; $middleware-\u003eweb(replace: [ StartSession::class =\u003e StartCustomSession::class, ]); 也可以完全删除中间件： $middleware-\u003eweb(remove: [ StartSession::class, ]); 手动管理Laravel的默认中间件组 -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003egroup('web', [ \\Illuminate\\Cookie\\Middleware\\EncryptCookies::class, \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\Illuminate\\Foundation\\Http\\Middleware\\ValidateCsrfToken::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, // \\Illuminate\\Session\\Middleware\\AuthenticateSession::class, ]); $middleware-\u003egroup('api', [ // \\Laravel\\Sanctum\\Http\\Middleware\\EnsureFrontendRequestsAreStateful::class, // 'throttle:api', \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ]); }) ","date":"2024年06月15日","objectID":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/:3:3","tags":["PHP","Laravel"],"title":"Laravel 11.x 中间件","uri":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["PHP","Laravel"],"content":"中间件别名 可以在应用程序的 bootstrap/app.php 文件中为中间件分配别名。 中间件别名允许您为给定的中间件类定义一个简短的别名，这对于具有较长类名的中间件特别有用 use App\\Http\\Middleware\\EnsureUserIsSubscribed; -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003ealias([ 'subscribed' =\u003e EnsureUserIsSubscribed::class ]); }) 一旦在应用程序的 bootstrap/app.php 文件中定义了中间件别名，就可以在将中间件分配给路由时使用这个别名 Route::get('/profile', function () { // ... })-\u003emiddleware('subscribed'); Laravel 内置中间件默认使用的别名 Alias Middleware auth Illuminate\\Auth\\Middleware\\Authenticate auth.basic Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth auth.session Illuminate\\Session\\Middleware\\AuthenticateSession cache.headers Illuminate\\Http\\Middleware\\SetCacheHeaders can Illuminate\\Auth\\Middleware\\Authorize guest Illuminate\\Auth\\Middleware\\RedirectIfAuthenticated password.confirm Illuminate\\Auth\\Middleware\\RequirePassword precognitive Illuminate\\Foundation\\Http\\Middleware\\HandlePrecognitiveRequests signed Illuminate\\Routing\\Middleware\\ValidateSignature subscribed \\Spark\\Http\\Middleware\\VerifyBillableIsSubscribed throttle Illuminate\\Routing\\Middleware\\ThrottleRequests or Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis Illuminate\\Routing\\Middleware\\ThrottleRequests 或 Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis verified Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified ","date":"2024年06月15日","objectID":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/:3:4","tags":["PHP","Laravel"],"title":"Laravel 11.x 中间件","uri":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["PHP","Laravel"],"content":"中间件优先级 以使用应用程序 bootstrap/app.php 文件中的方法 priority 指定中间件优先级 -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003epriority([ \\Illuminate\\Foundation\\Http\\Middleware\\HandlePrecognitiveRequests::class, \\Illuminate\\Cookie\\Middleware\\EncryptCookies::class, \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\Illuminate\\Foundation\\Http\\Middleware\\ValidateCsrfToken::class, \\Laravel\\Sanctum\\Http\\Middleware\\EnsureFrontendRequestsAreStateful::class, \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, \\Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, \\Illuminate\\Contracts\\Auth\\Middleware\\AuthenticatesRequests::class, \\Illuminate\\Auth\\Middleware\\Authorize::class, ]); }) ","date":"2024年06月15日","objectID":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/:3:5","tags":["PHP","Laravel"],"title":"Laravel 11.x 中间件","uri":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["PHP","Laravel"],"content":"中间件参数 中间件还可以接收其他参数 \u003c?php namespace App\\Http\\Middleware; use Closure; use Illuminate\\Http\\Request; use Symfony\\Component\\HttpFoundation\\Response; class EnsureUserHasRole { /** * Handle an incoming request. * * @param \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response) $next */ public function handle(Request $request, Closure $next, string $role): Response { if (! $request-\u003euser()-\u003ehasRole($role)) { // Redirect... } return $next($request); } } 在定义路由时，可以通过将中间件名称和参数以:分隔来指定中间件参数： Route::put('/post/{id}', function (string $id) { // ... })-\u003emiddleware('role:editor'); 多个参数可以用逗号进行分隔： Route::put('/post/{id}', function (string $id) { // ... })-\u003emiddleware('role:editor,publisher'); ","date":"2024年06月15日","objectID":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/:4:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 中间件","uri":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["PHP","Laravel"],"content":"终止中间件 有时候，中间件可能需要在HTTP响应已发送到浏览器后进行一些工作。如果在中间件上定义了 terminate 方法，并且 Web 服务器使用 FastCGI，那么 terminate 方法将会在响应发送到浏览器后自动被调用 \u003c?php namespace Illuminate\\Session\\Middleware; use Closure; use Illuminate\\Http\\Request; use Symfony\\Component\\HttpFoundation\\Response; class TerminatingMiddleware { /** * Handle an incoming request. * * @param \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response) $next */ public function handle(Request $request, Closure $next): Response { return $next($request); } /** * Handle tasks after the response has been sent to the browser. */ public function terminate(Request $request, Response $response): void { // ... } } terminate 方法应接收请求和响应两个参数。一旦定义了一个终止中间件，需要将其添加到路由列表或全局中间件中，即在应用程序的 bootstrap/app.php 文件中。 在调用中间件的 terminate 方法时，Laravel 将会从服务容器中解析一个新的中间件实例。 如果需要在调用 handle 和 terminate 方法时使用同一个中间件实例，可以使用容器的 singleton 方法将中间件注册为单例。 通常情况下，这需要在 AppServiceProvider 的 register 方法中完成。 use App\\Http\\Middleware\\TerminatingMiddleware; /** * Register any application services. */ public function register(): void { $this-\u003eapp-\u003esingleton(TerminatingMiddleware::class); } ","date":"2024年06月15日","objectID":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/:5:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 中间件","uri":"/2024/06/laravel11%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["PHP","Laravel"],"content":" 原文 ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:0:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"基本路由 最基本的路由接收 URI 和闭包，提供了一种非常简单且富有表现力的方法来定义路由和行为，而无需复杂的路由配置文件： use Illuminate\\Support\\Facades\\Route; Route::get('/greeting', function () { return 'Hello World'; }); ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:1:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"默认路由文件 所有路由都在位于routes目录中的路由文件中定义。 这些文件由应用程序bootstrap/app.php文件中指定的配置自动加载。 web 路由 routes/web.php文件定义用于Web界面的路由，这些路由被分配为web中间件组，该组提供会话状态和CSRF保护等功能。 在routes/web.php中定义的路由，可以通过在浏览器中输入定义的路由的URL来访问。 例如：通过http://example.com/userURL访问以下路由： use App\\Http\\Controllers\\UserController; use Illuminate\\Support\\Facades\\Route; Route::get('/user', [UserController::class, 'index']); api 路由 install:api 命令用来生成无状态API，会创建routes/api.php文件 该命令将安装 Laravel Sanctum ，它提供了一个强大而简单的API令牌身份验证防护。 php artisan install:api use Illuminate\\Support\\Facades\\Request; use Illuminate\\Support\\Facades\\Route; Route::get('/user', function (Request $request) { return $request-\u003euser(); })-\u003emiddleware('auth:sanctum'); routes/api.php中的路由是无状态的，并且被分配到api中间件组。 会自动应用/api作为URI前缀。 可以通过bootstrap/app.php修改前缀 -\u003ewithRouting( api: __DIR__.'/../routes/api.php', apiPrefix: 'api/admin', // 自定义前缀 // ... ) 可用路由方法 Route::get('/get', [UserController::class, 'index']); Route::post('/post', [UserController::class, 'index']); Route::put('/put', [UserController::class, 'index']); Route::patch('/patch', [UserController::class, 'index']); Route::delete('/delete', [UserController::class, 'index']); Route::options('/options', [UserController::class, 'index']); Route::match(['get', 'post'], '/match', [UserController::class, 'index']); Route::any('/any', [UserController::class, 'index']); 依赖注入 可以在路由的回调签名中进行类型提示，以声明路由所需的任何依赖项。被声明的依赖项将由服务容器自动解析并注入到回调中。 例如：可以对Illuminate\\Support\\Facades\\Request 类进行类型提示，以便当前的HTTP请求自动注入到路由回调中： use Illuminate\\Support\\Facades\\Request; use Illuminate\\Support\\Facades\\Route; Route::get('/user', function (Request $request) { return $request-\u003euser(); // 可以使用 $request 对象来访问当前 HTTP 请求 }); CSRF 保护 在 web 路由文件中定义的指向 POST、PUT、PATCH 或 DELETE 路由的任何 HTML 表单都应包含一个 CSRF 令牌字段。否则，请求将被拒绝。 \u003cform method=\"POST\" action=\"/profile\"\u003e @csrf ... \u003c/form\u003e ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:1:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"重定向路由 Route::redirect 重定向路由 Route::redirect('/here', '/there'); Route::redirect 默认返回状态码是302代码，可以通过第三个参数进行自定义状态代码 Route::redirect('/here', '/there', 301); Route::permanentRedirect重定向路由默认返回301状态代码 Route::permanentRedirect('/here', '/there'); ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:1:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"视图路由 Route:view 视图路由。 该 view 方法接受 URI 作为其第一个参数，并接受视图名称作为其第二个参数。此外，还可以提供要传递给视图的数据数组作为可选的第三个参数： Route::view('/welcome', 'welcome'); Route::view('/welcome', 'welcome', ['name' =\u003e 'Taylor']); ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:1:3","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"查看所有定义的路由 route:list 命令可以查看应用程序定义的所有路由 php artisan route:list 默认情况下，分配给每个路由的路由中间件不会输出，但是可以通过-\u2028参数来显示路由中间件和中间件组名称 php artisan route:list -v # 展开中间件组 php artisan route:list -vv --path=xx 指定显示以给定URI开头的路由 php artisan route:list --path=api --except-vendor选项来指定隐藏第三方软件包定义的任何路由 php artisan route:list --except-vendor --only-vendor选项来指定仅显示第三方软件包定义的路由 php artisan route:list --only-vendor ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:1:4","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"定制路由 默认情况，应用程序的路由由bootstrap/app.php进行配置和加载： use Illuminate\\Foundation\\Application; return Application::configure(basePath: dirname(__DIR__)) -\u003ewithRouting( web: __DIR__.'/../routes/web.php', commands: __DIR__.'/../routes/console.php', health: '/up', )-\u003ecreate(); then闭包，用来注册应用程序所需要的任何附加路由 use Illuminate\\Support\\Facades\\Route; -\u003ewithRouting( web: __DIR__.'/../routes/web.php', commands: __DIR__.'/../routes/console.php', health: '/up', then: function () { Route::middleware('api') -\u003eprefix('webhooks') -\u003ename('webhooks.') -\u003egroup(base_path('routes/webhooks.php')); }, ) using闭包，用来完全控制路由注册。 当传递此参数时，框架将不会注册任何HTTP路由，需要手动注册所有路由 use Illuminate\\Support\\Facades\\Route; -\u003ewithRouting( commands: __DIR__.'/../routes/console.php', using: function () { Route::middleware('api') -\u003eprefix('api') -\u003egroup(base_path('routes/api.php')); Route::middleware('web') -\u003egroup(base_path('routes/web.php')); }, ) ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:1:5","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"路由参数 ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:2:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"必需参数 路由参数适中使用{}括起来，并且应由字母字符组成。 下划线在路由参数名称中也是可以接受的。 路由参数根据其顺序注入到路由回调/控制器中 - 路由回调/控制器参数的名称无关紧要 Route::get('/user/{id}', function (string $id) { return 'User ' . $id; }); Route::get('posts/{post}/comments/{comment}', function (string $postId, string $commentId) { return 'Post ' . $postId . ' Comment ' . $commentId; }); 参数和依赖注入 依赖注入项应该在路由参数前 Route::get('/user/{id}', function (Request $request, string $id) { return 'User ' . $id; }); ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:2:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"可选参数 通过在参数名称后放置标记?来表示可选参数。 需要确保相对于变量提供有默认值，不提供默认值又不传递参数，则会发生异常 Route::get('/user2/{name?}', function (?string $name = null) { return $name; }); Route::get('/user3/{name?}', function (?string $name = 'John') { return $name; }); ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:2:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"正则约束 使用路由实例上的方法where限制路由参数的格式。 where方法接受参数的名称和正则表达式，用于定义参数应如何约束。 Route::get('/user/{name}', function (string $name) { // ... })-\u003ewhere('name', '[A-Za-z]+'); Route::get('/user/{id}', function (string $id) { // ... })-\u003ewhere('id', '[0-9]+'); Route::get('/user/{id}/{name}', function (string $id, string $name) { // ... })-\u003ewhere(['id' =\u003e '[0-9]+', 'name' =\u003e '[a-z]+']); Laravel 提供了一些常用的正则表达式模式，可用于快速向路由添加模式约束 Route::get('/user/{id}/{name}', function (string $id, string $name) { // ... })-\u003ewhereNumber('id')-\u003ewhereAlpha('name'); Route::get('/user/{name}', function (string $name) { // ... })-\u003ewhereAlphaNumeric('name'); Route::get('/user/{id}', function (string $id) { // ... })-\u003ewhereUuid('id'); Route::get('/user/{id}', function (string $id) { // ... })-\u003ewhereUlid('id'); Route::get('/category/{category}', function (string $category) { // ... })-\u003ewhereIn('category', ['movie', 'song', 'painting']); Route::get('/category/{category}', function (string $category) { // ... })-\u003ewhereIn('category', CategoryEnum::cases()); ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:2:3","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"全局约束 使用pattern 方法，可以定义路由参数全局约束。 在App\\Providers\\AppServiceProvider类的boot方法中定义这些模式 public function boot(): void { // 定义全局路由参数约束 Route::pattern('id', '[0-9]+'); } ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:2:4","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"编码正斜杠 Laravel 路由组件允许路由参数值中包含除 / 之外的所有字符。 如果需要让 / 成为占位符的一部分，必须使用 where 条件正则表达式明确允许 Route::get('search/{search}', function (string $search) { return $search; })-\u003ewhere('search', '.*'); 注意：仅在最后一个路由段内受支持。 ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:2:5","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"命名路由 命名路由允许方便地为特定路由生成URL或进行重定向。 可以通过将 name 方法链接到路由定义上来为路由指定一个名称。 Route::get('/user/profile', function () { // ... })-\u003ename('profile'); 注意：路由名称应始终是唯一的。 ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:3:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"生成命名路由的URL 一旦为某个路由指定了名称，就可以在生成URL或进行重定向时，通过使用Laravel的 route 和 redirect 辅助函数来引用该路由的名称 // Generating URLs... $url = route('profile'); // Generating Redirects... return redirect()-\u003eroute('profile'); return to_route('profile'); 如果命名路由定义了参数，可以将参数作为第二个参数传递给 route 函数。 传入的参数会自动插入到生成的 URL 中的正确位置 Route::get('/user/{id}/profile', function (string $id) { // ... })-\u003ename('profile'); $url = route('profile', ['id' =\u003e 1]); 如果在数组中传递了额外的参数，这些键值对将自动添加到生成的 URL 的查询字符串中： Route::get('/user/{id}/profile', function (string $id) { // ... })-\u003ename('profile'); $url = route('profile', ['id' =\u003e 1, 'photos' =\u003e 'yes']); // /user/1/profile?photos=yes ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:3:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"检查当前路由 可以在路由实例上使用named方法确定当前请求是否路由到给定的命名路由 namespace App\\Http\\Middleware; use Closure; use Illuminate\\Http\\Request; use Symfony\\Component\\HttpFoundation\\Response; class RequestMiddleware { /** * Handle an incoming request. * * @param \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response) $next */ public function handle(Request $request, Closure $next): Response { if ($request-\u003eroute()-\u003enamed('profile')) { print_r('Profile route'); } return $next($request); } } ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:3:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"路由组 路由组允许在大量路由之间共享路由属性（如中间件），而无需在每个单独的路由上定义这些属性。 ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:4:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"中间件 middleware方法可以将中间件分配给组内的所有路由。 中间件按它们在数组中列出的顺序执行 Route::middleware(['first', 'second'])-\u003egroup(function () { Route::get('/', function () { // Uses first \u0026 second Middleware }); Route::get('/user', function () { // Uses first \u0026 second Middleware }); }); ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:4:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"控制器 controller方法为组内的所有路由定义公共控制器。 在定义路由时，只需提供它们调用的控制器方法。 Route::controller(UserController::class)-\u003egroup(function () { Route::get('user', 'show'); Route::get('user/edit', 'edit'); }); ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:4:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"子域路由 domain指定子域路由。 子域可以像路由URI一样分配路由参数，允许捕获子域的一部分，以便在路由或控制器中使用。 注意：为确保子域路由可访问，应该在注册根域路由之前注册子域路由。防止根域路由覆盖具有相同URI路径的子域路由。 Route::domain('{account}.myapp.com')-\u003egroup(function () { Route::get('user/{id}', function (string $account, string $id) { // }); }); // GET|HEAD {account}.myapp.com/api/user/{id} ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:4:3","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"路由前缀 prefix方法可用于使用给定的URI 为组中的每个路由添加前缀 Route::prefix('admin')-\u003egroup(function () { Route::get('users', function () { // Matches The \"/admin/users\" URL }); }); // GET|HEAD api/admin/users ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:4:4","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"路由名称前缀 name方法可用于在组中的每个路由名称前面加上给定的字符串。 给定的字符串与指定的路由名称完全相同，因此我们确保在前缀中提供尾.字符 Route::name('admin.')-\u003egroup(function () { Route::get('users', function () { // Route assigned name \"admin.users\"... })-\u003ename('users'); }); // GET|HEAD api/users ..... admin.users ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:4:5","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"路由模型绑定 ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:5:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"隐式绑定 Laravel 会自动解析在路由或控制器操作中定义的 Eloquent 模型，通过类型提示的变量名匹配路由段名称。 use App\\Models\\User; Route::get('/users/{user}', function (User $user) { return $user-\u003eemail; }); 由于$user变量被类型提示为Eloquent模型，并且变量名称与{user}URI段匹配，因此，Laravel将自动注入具有与请求URI中相应值匹配的 ID 的模型实例。 如果在数据库中找不到匹配的模型实例，则会自动生成 404 HTTP 响应。 在使用控制器方法时，隐式绑定也是可用的 use App\\Http\\Controllers\\UserController; use App\\Models\\User; // Route definition... Route::get('/users/{user}', [UserController::class, 'show']); // Controller method definition... public function show(User $user) { return view('user.profile', ['user' =\u003e $user]); } 软删除模型 withTrashed方法链接到路由的定义来指示隐式绑定检索已软删除的模式。 use App\\Models\\User; Route::get('/users/{user}', function (User $user) { return $user-\u003eemail; })-\u003ewithTrashed(); 自定义键 有时希望使用除id以外的列来解析Eloquent模型。可以在路由参数定义中指定该列 use App\\Models\\Post; Route::get('/posts/{post:slug}', function (Post $post) { return $post; }); 如果希望模型绑定始终使用数据库列，但不是id，则可以在Eloquent模型上重写getRouteKeyName方法。 /** * Get the route key for the model. */ public function getRouteKeyName(): string { return 'slug'; } 自定义键和作用域 当单个路由定义中隐式绑定多个Eloquent模型时，可能希望将第二个Eloquent模型的范围限定为必须是前一个Eloquent模型的子级。 例如：考虑以下这个根据用户特定的slug来检索博客文章的路由定义： use App\\Models\\Post; use App\\Models\\User; Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) { return $post; }); 在将自定义键隐式绑定作为嵌套路由参数使用时，Laravel 会自动将查询范围限定在通过父模型来检索嵌套模型。Laravel 使用约定来猜测父模型上的关系名称。在这种情况下，将假设 User 模型有一个名为 posts（路由参数名称的复数形式）的关系，可以用来检索 Post 模型。 还可以指示 Laravel 限定“子”绑定的范围，即使未提供自定义键也是如此。为此，可以在定义路由时调用 scopeBindings 方法： use App\\Models\\Post; use App\\Models\\User; Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) { return $post; })-\u003escopeBindings(); 还可以指示整个路由定义组使用作用域绑定： Route::scopeBindings()-\u003egroup(function () { Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) { return $post; }); }); 同样，可以通过调用 withoutScopedBindings 方法明确指示 Laravel 不限定绑定的范围： Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) { return $post; })-\u003ewithoutScopedBindings(); 自定义缺失的模型行为 通常如果未找到隐式绑定的模型，则会生成 404 HTTP 响应。 可以通过在定义路由时调用missing方法来自定义此行为。 missing方法接受一个闭包，如果找不到隐式绑定的模型，则将调用该闭包 use App\\Http\\Controllers\\LocationsController; use Illuminate\\Http\\Request; use Illuminate\\Support\\Facades\\Redirect; Route::get('/locations/{location:slug}', [LocationsController::class, 'show']) -\u003ename('locations.view') -\u003emissing(function (Request $request) { return Redirect::route('locations.index'); }); 隐式枚举绑定 PHP 8.1 引入了对枚举（Enums）的支持。为了补充这一功能，Laravel 允许在路由定义中对一个有值的枚举进行类型提示，且 Laravel 仅在该路由段对应一个有效的枚举值时才会调用该路由。否则，将自动返回 404 HTTP 响应。 \u003c?php namespace App\\Enums; enum Category: string { case Fruits = 'fruits'; case People = 'people'; } use App\\Enums\\Category; use Illuminate\\Support\\Facades\\Route; Route::get('/categories/{category}', function (Category $category) { return $category-\u003evalue; }); ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:5:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"显示绑定 要注册显示绑定，使用路由器的model方法为给定参数指定类。 应该在AppServiceProvider 类的 boot 方法的开头定义显式模型绑定。 use App\\Models\\User; use Illuminate\\Support\\Facades\\Route; /** * Bootstrap any application services. */ public function boot(): void { Route::model('user', User::class); } use App\\Models\\User; Route::get('/users/{user}', function (User $user) { // ... }); 自定义解析逻辑 如果希望定义自己的模型绑定解析逻辑，可以使用Route:bind方法。 传递给 bind 方法的闭包将接收 URI 段的值，并应返回应注入到路由中的类的实例。 同样，这种自定义应该在应用程序的 AppServiceProvider 类的 boot 方法中进行。 use App\\Models\\User; use Illuminate\\Support\\Facades\\Route; /** * Bootstrap any application services. */ public function boot(): void { Route::bind('user', function (string $value) { return User::where('name', $value)-\u003efirstOrFail(); }); } 也可以在Eloquent 模型上重写 resolveRouteBinding 方法。这个方法将接收 URI 段的值，并应返回应注入到路由中的类的实例。 /** * Retrieve the model for a bound value. * * @param mixed $value * @param string|null $field * @return \\Illuminate\\Database\\Eloquent\\Model|null */ public function resolveRouteBinding($value, $field = null) { return $this-\u003ewhere('name', $value)-\u003efirstOrFail(); } 如果路由使用隐式绑定作用域，将使用 resolveChildRouteBinding 方法来解析父模型的子绑定。 /** * Retrieve the child model for a bound value. * * @param string $childType * @param mixed $value * @param string|null $field * @return \\Illuminate\\Database\\Eloquent\\Model|null */ public function resolveChildRouteBinding($childType, $value, $field) { return parent::resolveChildRouteBinding($childType, $value, $field); } ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:5:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"回退路由 使用 Route::fallback 方法，可以定义一个在没有其他路由匹配传入请求时执行的路由。 通常，未处理的请求将通过应用程序的异常处理程序自动呈现一个 “404” 页面。 然而，由于会在 routes/web.php 文件中定义回退路由，因此 web 中间件组中的所有中间件都将应用于该路由。 也可以根据需要向该路由添加额外的中间件。 Route::fallback(function () { // ... }); 📢注意：回退路由应始终是应用程序注册的最后一个路由。 ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:6:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"速率限制 ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:7:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"定义速率限制器 Laravel包含强大且可定制的速率限制服务，可以利用它们来限制给定路由或路由组的流量量。 要开始使用，应该定义满足应用程序需求的速率限制器配置。 速率限制器可以在应用程序的 App\\Providers\\AppServiceProvider 类的 boot 方法中定义。 use Illuminate\\Cache\\RateLimiting\\Limit; use Illuminate\\Http\\Request; use Illuminate\\Support\\Facades\\RateLimiter; /** * Bootstrap any application services. */ protected function boot(): void { RateLimiter::for('api', function (Request $request) { return Limit::perMinute(60)-\u003eby($request-\u003euser()?-\u003eid ?: $request-\u003eip()); }); } 速率限制器是使用 RateLimiter Facade for 的方法定义的。 for 方法接受一个速率限制器名称和一个返回应用于分配给速率限制器的路由的限制配置的闭包。 限制配置是 Illuminate\\Cache\\RateLimiting\\Limit 类的实例。 该类包含有用的 “构建器” 方法，因此可以快速定义限制。 速率限制器名称可以是任何字符串。 use Illuminate\\Cache\\RateLimiting\\Limit; use Illuminate\\Http\\Request; use Illuminate\\Support\\Facades\\RateLimiter; /** * Bootstrap any application services. */ protected function boot(): void { RateLimiter::for('global', function (Request $request) { return Limit::perMinute(1000); }); } 如果传入的请求超过了指定的速率限制，Laravel 将自动返回一个带有 429 HTTP 状态码的响应。如果希望定义自己的响应来处理速率限制，可以使用 response 方法。 RateLimiter::for('global', function (Request $request) { return Limit::perMinute(1000)-\u003eresponse(function (Request $request, array $headers) { return response('Custom response...', 429, $headers); }); }); 由于速率限制器回调接收传入的 HTTP 请求实例，可以根据传入的请求或经过身份验证的用户动态地构建适当的速率限制。 RateLimiter::for('uploads', function (Request $request) { return $request-\u003euser()-\u003evipCustomer() ? Limit::none() : Limit::perMinute(100); }); 分段速率限制 可以在构建速率限制时使用by方法对速率限制进行分段. RateLimiter::for('uploads', function (Request $request) { return $request-\u003euser()-\u003evipCustomer() ? Limit::none() : Limit::perMinute(100)-\u003eby($request-\u003eip()); }); 例：限制对路由的访问，每分钟对经过身份验证的用户ID限制为100次，对于未登录的访客，每分钟限制为10次 RateLimiter::for('uploads', function (Request $request) { return $request-\u003euser() ? Limit::perMinute(100)-\u003eby($request-\u003euser()-\u003eid) : Limit::perMinute(10)-\u003eby($request-\u003eip()); }); 多个速率限制 可以为给定的速率限制器配置返回一个速率限制数组。每个速率限制将根据它们在数组中的顺序进行路由评估。 RateLimiter::for('login', function (Request $request) { return [ Limit::perMinute(500), Limit::perMinute(3)-\u003eby($request-\u003einput('email')), ]; }); ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:7:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"将速率限制器附加到路由 可以使用 throttle 中间件将速率限制器附加到路由或路由组。 throttle 中间件接受分配给路由的速率限制器的名称。 Route::middleware(['throttle:uploads'])-\u003egroup(function () { Route::post('/audio', function () { // ... }); Route::post('/video', function () { // ... }); }); 使用Redis进行节流 默认情况下，throttle 中间件映射到 Illuminate\\Routing\\Middleware\\ThrottleRequests 类。 然而，如果使用 Redis 作为应用程序的缓存驱动程序，并且指示 Laravel 使用 Redis 来管理速率限制，可以在应用程序的 bootstrap/app.php 文件中使用 throttleWithRedis 方法。 这个方法将 throttle 中间件映射到 Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis 中间件类。 -\u003ewithMiddleware(function (Middleware $middleware) { $middleware-\u003ethrottleWithRedis(); // ... }) ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:7:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"表单方法欺骗 HTML表单不支持PUT、PATCH或DELETE操作。因此，当定义从HTML表单调用的PUT、PATCH或DELETE路由时，需要向表单添加一个隐藏的_method字段。发送的_method字段的值将被用作HTTP请求方法。 \u003cform action=\"/example\" method=\"POST\"\u003e \u003cinput type=\"hidden\" name=\"_method\" value=\"PUT\"\u003e \u003cinput type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\"\u003e \u003c/form\u003e 为了方便起见，可以使用 Blade 指令 @method 来生成 _method 输入字段。 \u003cform action=\"/example\" method=\"POST\"\u003e @method('PUT') @csrf \u003c/form\u003e ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:8:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"访问当前路由 可以使用 Route Facade 上的 current 、 currentRouteName 和 currentRouteAction 方法来访问有关处理传入请求的路由的信息 use Illuminate\\Support\\Facades\\Route; $route = Route::current(); // Illuminate\\Routing\\Route $name = Route::currentRouteName(); // string $action = Route::currentRouteAction(); // string ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:9:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"跨域资源共享（CORS） Laravel可以自动使用您配置的值响应CORS OPTIONS HTTP请求。 OPTIONS请求将由HandleCors中间件自动处理，该中间件已自动包含在应用程序的全局中间件堆栈中。 有时，需要自定义应用程序的CORS配置值。可以使用 config:publish Artisan命令来发布CORS配置文件。 php artisan config:publish cors 此命令会将 cors.php 配置文件放在应用程序 config 的目录中。 ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:10:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"路由缓存 在将应用程序部署到生产环境时，应该利用 Laravel 的路由缓存。 使用路由缓存可以大幅减少注册所有应用程序路由所需的时间。 要生成路由缓存，可以执行 route:cache Artisan 命令。 php artisan route:cache 运行此命令后，缓存路由文件将在每个请求时加载。 请记住，如果添加了任何新路由，需要生成新的路由缓存。 因此，在项目部署期间应该只运行 route:cache 命令。 使用以下 route:clear 命令清除路由缓存： php artisan route:clear ","date":"2024年06月14日","objectID":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/:11:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 路由","uri":"/2024/06/laravel11%E8%B7%AF%E7%94%B1/"},{"categories":["PHP","Laravel"],"content":"Laravel 11 Laravel 11 通过引入简化的应用程序结构、每秒速率限制、健康路由、优雅的加密密钥轮换、队列测试改进、重新发送邮件传输、提示验证器集成、新的 Artisan 命令等功能，继续改进了 Laravel 10.x 版本。此外，Laravel Reverb，一个官方推出的可扩展 WebSocket 服务器，为您的应用程序提供了强大的实时功能。 Laravel 11.x 最低要求 PHP 版本为 8.2。 Installation ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:0:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"创建 Laravel 项目 前提：需要安装 PHP 和 Composer # 方式一（通过 Composer create-project命令创建）： composer create-project laravel/laravel example-app # 方式二（通过Composer全局安装Laravel安装程序进行创建）： composer global require laravel/installer laravel new example-app 通过 Laravel Artisan serve 命令启动本地开发服务器： cd example-app php artisan serve Configuration Laravel 框架的所有配置文件都存储在 config 目录中。 about Artisan 命令可以进行查看应用程序的配置、驱动程序和环境的概述。 可以通过 --only 选项筛选指定部分 php artisan about php artisan about --only=environment 需要浏览更详细配置文件的值，可以使用 config:show Artisan 命令 php artisan config:show database ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:1:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"环境配置 在全新 Laravel 安装中，应用程序的根目录将包含一个.env.example 定义许多常见环境变量的文件。在安装过程中，此文件将自动复制到.env。 目录中的config 配置文件使用 Laravel env 函数进行读取（e: env('APP_DEBUG', false) ）。 注意：.env文件中的任何变量都可以被外部环境变量（如服务器级或系统级环境变量）覆盖。 在加载应用程序的环境变量之前，Laravel 会确定是否已从外部提供 APP_ENV环境变量或者是否指定了 --env CLI 参数。如果有指定，Laravel 将尝试加载文件 .env.[APP_ENV]，如果不存在则将加载默认.env文件。 ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:2:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"环境文件安全 .env文件不应该提交到应用程序的源代码管理，如果泄漏，任何敏感凭证都会暴露。 但是，可以使用 Laravel 的内置环境加密来加密文件。加密后的可以安全的放置在源代码管理中。 env:encrypt 命令加密环境文件，加密后的内容放入.env.encrypted文件中。 解密密钥显示在命令的输出中，应存储在安全的密码管理器中。 php artisan env:encrypt # 可以提供加密密钥，通过 --key 选项 php artisan env:encrypt --key=3UVsEgGVK36XN82KKeyLFMhvosbZN1aF # 有多个环境文件（.env / .env.staging），可以通过 --env 来指定 php artisan env:encrypt --env=staging env:decrypt 命令解密环境文件。 默认将从LARAVEL_ENV_ENCRYPTION_KEY 环境变量中检索该密钥 也可以通过 --key 选项直接向命令提供密钥 解密后的文件内容保存在.env文件中 php artisan env:decrypt php artisan env:decrypt --key=3UVsEgGVK36XN82KKeyLFMhvosbZN1aF # 有多个环境文件（.env / .env.staging），可以通过 --env 来指定 php artisan env:decrypt --env=staging # 要覆盖现有环境文件，可以通过 --force 选项 php artisan env:decrypt --force ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:3:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"访问配置值 获取配置值：可以使用Config Facade 或全局 config函数。 $value = Config::get('app.timezone'); $value = config('app.timezone'); // 如果不存在，则返回默认值 $value = config('app.timezone', 'Asia/Shanghai'); 设置配置值：可以使用 Config::set 或将数组传递给config函数 Config::set('app.timezone', 'Asia/Shanghai'); config(['app.timezone' =\u003e 'Asia/Shanghai']); 类型化配置检索，如果检索到的配置值与预期不匹配，则会引发异常 Config::string('config-key'); Config::integer('config-key'); Config::float('config-key'); Config::boolean('config-key'); Config::array('config-key'); ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:4:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"配置缓存 config:cache Artisan命令将所有配置文件缓存到单个文件中。 这会将应用程序的所有配置选项合并到一个文件中，框架可以加速加载该文件。 php artisan config:cache config:clear 用于清除缓存的配置 php artisan config:clear ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:5:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"配置发布 Laravel的大多数配置文件已经发布在应用程序的 config 目录中，然而，像 cors.php 和 view.php 这样的一些配置文件默认情况下并不会发布，因为大多数应用程序从不需要修改它们。 不过，可以使用 config:publish Artisan 命令来发布那些默认未发布的配置文件： php artisan config:publish php artisan config:publish --all 目录结构 ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:6:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"根目录 项目根目录 |-- app (用于存放应用程序核心代码) |-- bootstrap | |-- cache (用于存放框架生成的文件以进行性能优化，比如路由和服务缓存文件) | |-- app.php (初始化框架) |-- config (用于存放所有应用程序的配置文件) |-- database (包含数据库迁移文件、模型工厂和种子文件。也可以存放SQLite数据库文件) |-- public | |-- index.php (进入应用程序的所有请求的入口，并配置了自动加载) | |-- Other (存放资源文件，如：图片、JS和CSS) |-- resources (存放视图以及原始的、未编译的资产，例如：CSS或JS) |-- routes (包含应用程序的所有路由定义) | |-- web.php (包含Laravel放置在web中间件组中的路由，该中间件组提供会话状态、CSRF 保护和 Cookie 加密) | |-- console.php (包含所有基于闭包的控制台命令) |-- storage | |-- app (用于存储应用程序生成的任何文件) | | |-- public (可用于存储用户生成的文件，例如配置文件头像，这些文件是可公开访问的) | |-- framework (用于存储框架生成的文件和缓存) | |-- logs (包含应用程序的日志文件) |-- tests (用于自动化测试) |-- vendor (包含Composer依赖项) ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:6:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"App 目录文件生成命令 app目录中许多类都可以由Artisan通过命令生成 # 查看可用命令 php artisan list make 命令汇总 命令 描述 make:cache-table [cache:table] 创建缓存数据库表的迁移文件 make:cast 创建一个新的自定义 Eloquent 类型转换类 make:channel 创建一个新的通道类 make:class 创建一个新的类 make:command 创建一个新的 Artisan 命令 make:component 创建一个新的视图组件类 make:controller 创建一个新的控制器类 make:enum 创建一个新的枚举 make:event 创建一个新的事件类 make:exception 创建一个新的自定义异常类 make:factory 创建一个新的模型工厂 make:interface 创建一个新的接口 make:job 创建一个新的任务类 make:listener 创建一个新的事件监听器类 make:mail 创建一个新的邮件类 make:middleware 创建一个新的中间件类 make:migration 创建一个新的迁移文件 make:model 创建一个新的 Eloquent 模型类 make:notification 创建一个新的通知类 make:notifications-table [notifications:table] 创建通知表的迁移文件 make:observer 创建一个新的观察者类 make:policy 创建一个新的策略类 make:provider 创建一个新的服务提供者类 make:queue-batches-table [queue:batches-table] 创建批处理数据库表的迁移文件 make:queue-failed-table [queue:failed-table] 创建失败队列任务数据库表的迁移文件 make:queue-table [queue:table] 创建队列任务数据库表的迁移文件 make:request 创建一个新的表单请求类 make:resource 创建一个新的资源 make:rule 创建一个新的验证规则 make:scope 创建一个新的作用域类 make:seeder 创建一个新的数据库填充类 make:session-table [session:table] 创建会话数据库表的迁移文件 make:test 创建一个新的测试类 make:trait 创建一个新的特性 make:view 创建一个新的视图 部署 ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:6:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"服务器要求 PHP \u003e= 8.2 Ctype PHP Extension cURL PHP Extension DOM PHP Extension Fileinfo PHP Extension Filter PHP Extension Hash PHP Extension Mbstring PHP Extension OpenSSL PHP Extension PCRE PHP Extension PDO PHP Extension Session PHP Extension Tokenizer PHP Extension XML PHP Extension ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:7:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"服务器配置 ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:8:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"Nginx server { listen 80; listen [::]:80; server_name example.com; root /srv/example.com/public; add_header X-Frame-Options \"SAMEORIGIN\"; add_header X-Content-Type-Options \"nosniff\"; index index.php; charset utf-8; location / { try_files $uri $uri/ /index.php?$query_string; } location = /favicon.ico { access_log off; log_not_found off; } location = /robots.txt { access_log off; log_not_found off; } error_page 404 /index.php; location ~ \\.php$ { fastcgi_pass unix:/var/run/php/php8.2-fpm.sock; fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name; include fastcgi_params; fastcgi_hide_header X-Powered-By; } location ~ /\\.(?!well-known).* { deny all; } } ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:8:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"FrankenPHP FrankenPHP 是一个用 Go 编写的现代 PHP 应用程序服务器。为 Laravel PHP 应用程序提供服务，只需调用其php-server命令： frankenphp php-server -r public/ ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:8:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"优化 将应用程序部署到生产环境时，有多种文件应进行缓存，包括：配置、事件、路由和视图。 Laravel 提供了一个单一且方便的optimize Artisan命令，可以缓存所有这些文件。 通常应该作为应用程序部署过程的一部分来调用： php artisan optimize # 清除所有缓存 php artisan optimize:clear ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:9:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"缓存 ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:10:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"Config 缓存 config:cache命令，将配置进行缓存。 这样会将所有配置文件合并到一个缓存文件中，这极大地减少了框架在加载配置值时访问文件系统的次数。 php artisan config:cache 注意：使用此命令，应确保只在配置文件中调用了env函数。因为一旦配置被缓存，.env文件将不会被加载，所有对.env变量的env函数调用将返回null。 ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:10:1","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"Event 缓存 event:cache命令，在部署过程中缓存应用程序自动发现的事件到监听器的映射。 php artisan event:cache ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:10:2","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"Routes 缓存 route:cache命令，将所有的路由注册简化为在一个缓存文件中的单个方法调用，从而在注册数百个路由时提高路由注册的性能。 php artisan route:cache ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:10:3","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"Views 缓存 view:cache命令，该命令会预编译所有的 Blade 视图，因此它们不会在需要时即时编译，从而提高返回视图的每个请求的性能。 php artisan view:cache ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:10:4","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"Debug 模式 config/app.php 配置文件中的 debug 选项决定了实际向用户显示多少关于错误的信息。 默认情况下，该选项设置为遵循存储在应用程序 .env 文件中的 APP_DEBUG 环境变量的值。 注意：在生产环境中，此值应始终为false。 ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:11:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["PHP","Laravel"],"content":"健康路由 Laravel 包含一个内置的健康检查路由，可以用来监控应用程序状态。 在生产环境中，这个路由可以用来向正常运行时间监控器、负载均衡器或者像 Kubernetes 这样的编排系统报告您的应用程序状态。 默认情况下，健康检查路由提供于 /up，如果应用程序启动时没有异常，则会返回 200 HTTP 响应。否则，会返回 500 HTTP 响应。 可以在应用程序的 bootstrap/app 文件中配置此路由的 URI： -\u003ewithRouting( web: __DIR__.'/../routes/web.php', commands: __DIR__.'/../routes/console.php', // health: '/up', health: '/status', ) 当向此路由发出 HTTP 请求时，Laravel 还会调度一个 Illuminate\\Foundation\\Events\\DiagnosingHealth 事件，允许执行与应用程序相关的额外健康检查。 在此事件的监听器中，可以检查应用程序的数据库或缓存状态。如果检测到应用程序有问题，可以直接在监听器中抛出一个异常。 ","date":"2024年06月13日","objectID":"/2024/06/laravel11%E5%85%A5%E9%97%A8/:12:0","tags":["PHP","Laravel"],"title":"Laravel 11.x 入门","uri":"/2024/06/laravel11%E5%85%A5%E9%97%A8/"},{"categories":["AI","ChatGPT"],"content":"ChatGPT 提问的艺术","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"一、Prompt工程 ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:1:0","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"什么是Prompt工程？ Prompt 工程是创建 Prompt、提问或指导像 ChatGPT 这样的语言模型输出的过程。 它允许用户控制模型的输出，生成符合其特定需求的文本。 ChatGPT 是一种先进的语言模型，能够生成类似人类的文本。它建立在 Transformer 架构之上，可以处理大量数据并生成高质量的文本。 但是，为了从 ChatGPT 获得最佳结果，了解如何正确引导模型是非常重要的。 通过引导模型，用户可以控制模型的输出，生成相关、准确且高质量的文本。 Prompt 工程的作用： 通过提供清晰和具体的指令，您可以引导模型的输 出，确保其相关性。 ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:1:1","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"Prompt公式 Prompt公式是Prompt的特定格式，通常由三个主要元素组成： 任务：明确而简洁地陈述Prompt要求模型生成的内容。 指令：模型再生成文本时应遵循的指令。 角色：模型在生成文本时应扮演的角色。 ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:1:2","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"二、指令Prompt技术 指令Prompt技术是一种通过提供特定指令来引导ChatGPT输出的方法。 该技术对确保输出相关和高质量非常有用。 Prompt公式：“按照以下指示生成[任务]：[指示]” 生成中秋节祝福： 任务：生成中秋节祝福 指令：使用幽默语气 Prompt公式：“按照以下指示生成中秋节祝福：使用幽默语气” 生成售屋标题： 任务：生成一个两房两厅近地铁的售屋标题 指令：标题应该符合香港用语习惯，并且使用繁体 Prompt公式：“按照以下指示生成一个两房两厅近地铁的售屋标题：标题应该符合香港用语习惯，并且使用繁体” ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:2:0","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"三、角色Prompt技术 角色 Prompt 技术是一种通过指定模型要扮演的特定角色来引导 ChatGPT 输出的 方法。 该技术对生成针对特定上下文或受众量身定制的文本非常有用。 Prompt公式：“以[角色]身份生成[任务]” 生成中秋节祝福： 任务：生成中秋节祝福 角色：公司领导 Prompt公式：“以公司领导的身份生成中秋节祝福” 生成售屋标题： 任务：生成一个两房两厅近地铁的售屋标题 角色：香港地产代理人 Prompt公式：”以香港地产代理人的身份生成一个两房两厅近地铁的售屋标题“ ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:3:0","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"四、标准Prompt 标准Prompt是一种通过提供模型要完成的特定任务来引导ChatGPT输出的简单方法。 Prompt公式：“生成一个[任务]” 生成一个房源标题 任务：写一个近地铁的两房一厅的房源发布标题 Prompt公式：“生成一个近地铁的两房一厅的房源发布标题” ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:4:0","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"五、零样本、一样本和少样本Prompting 零样本、一样本和少样本Prompting是一种使用ChatGPT生成文本的技术，可以最小化或不使用示例。当特定任务的数据有限或任务是新的且未被明确定义时，这些技术非常有用。 零样本：用于任务没有可用的样例时。将通用任务提供给模型，它根据对任务的理解生成文本。 一样本：用于只有一个样例可用的任务。将样例提供给模型，它根据对样例的理解生成文本。 少样本：用于任务有限数量的样例可用。将样例提供给模型，它根据这些样例的理解生成文本。 Prompt公式：“根据[数量]个样例生成文本” 对于没有可用样例的新产品，生成一个产品描述： 任务：为新智能手表撰写产品描述 Prompt公式：“对于这个新智能手表，零样例生成产品描述” 使用一个可用样例比较新智能手机和最新款的 iPhone： 任务：比较一款新智能手机和最新款的 iPhone Prompt公式：“使用一个样例（最新款 iPhone）对这个新智能手机进行产品比较” 对于少量可用的样例，生成一篇产品评论： 任务：撰写一篇新电子阅读器的评论 Prompt公式：“对于这个新电子阅读器，使用少数样例（另外三款电子阅读器）生成评论” PS: 这些技术可用于根据模型对任务或提供的样例的理解生成文本。 ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:5:0","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"六、“让我们思考一下”提示 “让我们思考一下”提示是一种用来鼓励ChatGPT生成反思和沉思性文本的技巧。该技巧对于写作论文、诗歌或创意写作等任务非常有用。 这种独特的提示帮助ChatGPT从不同的角度回答问题，从而产生更动态和信息丰富的段落。 Prompt公式：“让我们思考一下：[主题或问题]” 要使用“让我们思考一下”提示技巧与ChatGPT进行对话或文本生成，可是按照以下步骤进行： 确定要讨论的主题或想法 制定一个明确表名主题或想法并开始对话或文本生成的提示 在提示前加上“让我们思考”或“让我们讨论”，表示正在发起对话或讨论 🌰例子： 提示：“让我们思考气候变化对农业的影响” 提示：“让我们讨论人工智能的现状” 提示：“让我们谈谈远程工作的利弊” 还可以添加一个开放式的问题、陈述或一段文本，希望模型继续或扩展。 PS：一旦提供了提示，模型将使用其训练数据和算法生成与提示相关的响应，并以连贯的方式继续对话。 ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:6:0","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"七、自一致性提示 自一致性提示是一种用于确保ChatGPT的输出与所提供的输入一致的技巧。这种技巧对于事实核实、数据验证或文本生成中的一致性检查等任务非常有用。 示例 1：文本生成 任务：生成产品评论 说明：评论应与输入中提供的产品信息一致 提示公式：“生成一篇与以下产品信息一致的产品评论[插入产品信息]” 示例 2：文本摘要 任务：总结一篇新闻文章 说明：摘要应与文章中提供的信息一致 提示公式：“以与以下提供的信息一致的方式总结以下新闻文章[插入新闻文章]” 示例 3：文本完成 任务：完成一个句子 说明：完成应与输入中提供的上下文一致 提示公式：“以与所提供的上下文一致的方式完成以下句子[插入句子]” 示例 4：事实核查 任务：检查给定新闻文章中的一致性 输入文本：“文章中提到该城市的人口为 500 万，但后来它说该城市的人口为 700 万。” 提示公式：“请确保以下文本自我一致：文章中提到该城市的人口为 500 万，但 后来它说该城市的人口为 700 万。” 示例 5：数据验证： 任务：检查给定数据集中的一致性 输入文本：“数据显示 7 月份的平均温度为 30 度，但最低温度记录为 20 度。” 提示公式：“请确保以下文本自我一致：数据显示 7 月份的平均温度为 30 度， 但最低温度记录为 20 度。” ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:7:0","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"八、种子词提示 种子词提示是一种通过提供特定的种子词或短语来控制ChatGPT输出的技巧。 Prompt：“请根据以下种子词生成文本：[种子词或短语]” 生成标题 任务：生成一个近地铁两房一厅的房屋标题 种子词：“近地铁、急售” 提示公式：“请根据以下种子词生成一个近地铁两房一厅的房屋标题：近地铁、急售” ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:8:0","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"九、知识生成提示 知识生成提示是一种从ChatGPT中引发新的和原始信息的技术。 Prompt：“请生成关于【感兴趣的主题】的新的和原始的信息” 这是一种利用模型的预先存在的知识来生成新的信息或回答问题的技术。 要在ChatGPT中使用此提示，应将问题或主题作为输入提供给模型，并提供一个知识，指定生成文本的任务或目标。提示应包括有关所需输出的信息，例如要生成文本类型以及任何特定要求或限制。 知识生成 任务：生成关于春节的新信息 说明：生成的信息应准确且与主题相关 提示公式：“请生成关于春节的新的准确信息” ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:9:0","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"十、知识整合提示 这种技术利用模型的预先存在的知识来整合新信息或连接不同的信息。 这种技术有助于将现有知识与新信息相结合，生成对特定主体更全面的理解。 与ChatGPT一起使用： 将新信息和现有知识作为输入提供给模型，并提供一个提示，指定生成文本的任务或目标。提示应包含有关所需输出的信息，例如要生成的文本类型以及任何特定要求或限制。 知识整合 任务：将新信息与现有知识整合 说明：整合应准确且与主题相关 提示公式：”将以下信息与有关【特定主题】的现有知识整合：【插入新信息】“ 连接信息 任务：连接不同的信息 说明：连接应相关和逻辑 提示公式：“以相关和逻辑的方式连接一下信息：【插入信息1】、【插入信息2】” ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:10:0","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["AI","ChatGPT"],"content":"十一、多项选择提示 这种技术问题或任务和一组预定义的选项作为潜在答案呈现给模型。 这种技术对于生成限定于特定选型集的文本非常有用，可用于问答、文本补全和其他任务。模型可以生成限定于预定义选项的文本。 要与 ChatGPT 一起使用多项选择提示，应将问题或任务作为输入提供给模型，以 及一组预定义的选项作为潜在答案。提示还应包括有关所需输出的信息，例如要 生成的文本类型以及任何特定要求或限制。 问答 任务：回答多项选择问题 说明：答案应是预定义选项之一 提示公式：“通过选择以下选项之一回答以下问题：[插入问题] [插入选项 1] [插入选项 2] [插入选项 3]” 文本补全 任务：用预定义选项之一完成句子 说明：完成应是预定义选项之一 提示公式：“通过选择以下选项之一来完成以下句子：[插入句子] [插入选项 1] [插入选项 2] [插入选项 3]” 情感分析 任务：将文本分类为积极的、中性的或消极的 说明：分类应是预定义选项之一 提示公式：“通过选择以下选项之一将以下文本分类为积极的、中性的或消极的： [插入文本] [积极] [中性] [消极]” ","date":"2023年10月26日","objectID":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/:11:0","tags":["AI","ChatGPT"],"title":"ChatGPT 提问的艺术","uri":"/2023/10/chatgpt%E6%8F%90%E9%97%AE%E8%89%BA%E6%9C%AF/"},{"categories":["Python","Selenium","docker"],"content":" 在使用Selenium Grid模拟操作上传文件时，会从浏览器实例的本地文件系统中读取文件。这就导致了一个问题，如果Grid Hub所在的机器上没有要上传的文件，那么就会出现文件不存在的错误。 ","date":"2023年10月22日","objectID":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:0:0","tags":["Python","Selenium","docker"],"title":"Selenium Grid 模拟操作上传操作问题解决方案","uri":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Python","Selenium","docker"],"content":"解决 将浏览器实例的某一文件夹映射出来，在执行上传操作时，将文件上传到该文件夹中，这样就可以解决文件不存在的问题。 ","date":"2023年10月22日","objectID":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:0","tags":["Python","Selenium","docker"],"title":"Selenium Grid 模拟操作上传操作问题解决方案","uri":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Python","Selenium","docker"],"content":"步骤 在每个浏览器镜像中，创建一个文件夹，例如：/home/seluser/upload volumes: - ./upload:/home/upload 在执行上传时中，将文件上传到该文件夹（./upload）中, 在代码中就可以使用/home/upload来访问该文件夹下的文件了 ele = driver.find_element(By.XPATH, \"//input[@type='file']\") ele.send_keys(\"/home/upload/xxx.txt\") ","date":"2023年10月22日","objectID":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:1","tags":["Python","Selenium","docker"],"title":"Selenium Grid 模拟操作上传操作问题解决方案","uri":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Python","Selenium","docker"],"content":"增强处理 提供上传接口，可以在执行上传文件模拟操作之前，先使用接口进行上传 起一个fastapi服务，提供上传接口 将服务中的upload文件夹映射到./upload文件夹中,实现文件共享 将所有服务使用NGINX进行代理 ","date":"2023年10月22日","objectID":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:2:0","tags":["Python","Selenium","docker"],"title":"Selenium Grid 模拟操作上传操作问题解决方案","uri":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Python","Selenium","docker"],"content":"说明 Selenium Grid ui界面 http://127.0.0.1:8080/ui Selenium Grid Hub http://127.0.0.1:8080/grid/hub from selenium import webdriver from selenium.webdriver.chrome import options # from selenium.webdriver.firefox import options # from selenium.webdriver.edge import options driver = webdriver.Remote(command_executor=\"http://admin:admin@127.0.0.1:8080/grid/hub\", options=options.Options()) Selenium Grid 状态 http://127.0.0.1:8080/grid/hub/status 上传接口 http://127.0.0.1:8080/api/upload import requests def upload(pictures): \"\"\" 上传图片 :param pictures: 图片路径列表 :return: 图片上传后在浏览器实例中的路径列表 \"\"\" url = \"http://admin:admin@127.0.0.1:8080/api/upload\" files = [(\"files\", open(picture, 'rb')) for picture in pictures] response = requests.post(url, files=files) if response.status_code == 401: raise Exception(\"Authorization Required\") elif response.status_code != 200: raise Exception(\"Upload Failed\") else: res = response.json() return [data.get(\"browser_file_path\") for data in res.get(\"data\", [])] files_path = upload([\"/Users/example/Pictures/6.JPG\", \"/Users/example/Pictures/7.png\"]) print(files_path) # ['/home/upload/2023/10/22/19676048770179.JPG', '/home/upload/2023/10/22/19676121458637.png'] ","date":"2023年10月22日","objectID":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:2:1","tags":["Python","Selenium","docker"],"title":"Selenium Grid 模拟操作上传操作问题解决方案","uri":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Python","Selenium","docker"],"content":"部署启动（Selenium-Grid-Upload） ","date":"2023年10月22日","objectID":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:3:0","tags":["Python","Selenium","docker"],"title":"Selenium Grid 模拟操作上传操作问题解决方案","uri":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Python","Selenium","docker"],"content":"部署 克隆项目 git clone https://github.com/Joker-desire/Selenium-Grid-Upload.git 进入项目目录 cd Selenium-Grid-Upload 运行 sh grid.sh run 默认superuser username: admin password: admin ","date":"2023年10月22日","objectID":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:3:1","tags":["Python","Selenium","docker"],"title":"Selenium Grid 模拟操作上传操作问题解决方案","uri":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Python","Selenium","docker"],"content":"命令行 运行 sh grid.sh run # 指定启动多少个浏览器实例 sh grid.sh run --scale chrome=5 --scale edge=1 --scale firefox=5 启动 sh grid.sh start 重启 sh grid.sh restart 停止 sh grid.sh stop 删除 sh grid.sh down 创建新的superuser sh grid.sh superuser \u003cusername\u003e ","date":"2023年10月22日","objectID":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:3:2","tags":["Python","Selenium","docker"],"title":"Selenium Grid 模拟操作上传操作问题解决方案","uri":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Python","Selenium","docker"],"content":"示例 import requests from selenium import webdriver from selenium.webdriver.chrome import options from selenium.webdriver.common.by import By def upload(pictures): \"\"\" 上传图片 :param pictures: 图片路径列表 :return: 图片上传后在浏览器实例中的路径列表 \"\"\" url = \"http://admin:admin@127.0.0.1:8080/api/upload\" files = [(\"files\", open(picture, 'rb')) for picture in pictures] response = requests.post(url, files=files) if response.status_code == 401: raise Exception(\"Authorization Required\") elif response.status_code != 200: raise Exception(\"Upload Failed\") else: res = response.json() return [data.get(\"browser_file_path\") for data in res.get(\"data\", [])] # 在需要执行上传的模拟程序前，先进行上传需要用到的图片 files_path = upload([\"/Users/example/Pictures/6.JPG\", \"/Users/example/Pictures/7.png\"]) driver = webdriver.Remote(command_executor=\"http://admin:admin@127.0.0.1:8080/grid/hub\", options=options.Options()) driver.get(\"https://www.example.com/upload.html\") ele = driver.find_element(By.XPATH, \"//input[@type='file']\") for file_path in files_path: # 通过上传后的图片获取浏览器中的路径进行上传 ele.send_keys(file_path) driver.quit() ","date":"2023年10月22日","objectID":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:4:0","tags":["Python","Selenium","docker"],"title":"Selenium Grid 模拟操作上传操作问题解决方案","uri":"/2023/10/selenium-grid-%E6%A8%A1%E6%8B%9F%E6%93%8D%E4%BD%9C%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Go笔记"],"content":"泛型基本含义 在定义函数（结构等）时，可能会有多种类型传入，真正使用方法的时候才可以确定用的是什么类型，此时就可以用一个更加宽泛的类型（存在一定约束，只能在哪些类型的范围内使用）暂时占位。这个类型就叫泛型。 泛型定义 写法：[泛型标识 泛型约束] 例如：[T any] 、 [S int|string] ","date":"2023年05月27日","objectID":"/2023/05/go-%E6%B3%9B%E5%9E%8B/:0:0","tags":["Go笔记"],"title":"Go 泛型（1.18+）","uri":"/2023/05/go-%E6%B3%9B%E5%9E%8B/"},{"categories":["Go笔记"],"content":"泛型方法 func Say[T any](msg T) T { return msg } func TestFunc(t *testing.T) { // 可以传递任意类型的参数 fmt.Println(Say(\"hello\")) fmt.Println(Say(1)) // 指定类型 fmt.Println(Say[int](1)) fmt.Println(Say[string](\"hello\")) // 如果指定了类型，参数必须是指定的类型，否则报错：cannot use 1 (untyped int constant) as string value in argument //fmt.Println(Say[string](1)) } ","date":"2023年05月27日","objectID":"/2023/05/go-%E6%B3%9B%E5%9E%8B/:1:0","tags":["Go笔记"],"title":"Go 泛型（1.18+）","uri":"/2023/05/go-%E6%B3%9B%E5%9E%8B/"},{"categories":["Go笔记"],"content":"泛型结构体 // 泛型结构体 type User[T any] struct { Name T } // 泛型结构体的方法 func (t User[T]) GetName() T { return t.Name } func TestStruct(t *testing.T) { // 在创建结构体变量时，指定类型（必须） fmt.Println(User[string]{Name: \"Joker\"}) fmt.Println(User[int]{Name: 111}) // 如果没有指定类型，会报错：cannot use generic type User[T any] without instantiation //fmt.Println(User{Name: 111}) // 如果指定了类型，参数必须是指定的类型，否则报错：cannot use \"Joker\" (untyped string constant) as int value in struct literal //fmt.Println(User[int]{Name: \"Joker\"}) // 调用泛型结构体的方法 fmt.Println(User[string]{Name: \"Joker\"}.GetName()) } ","date":"2023年05月27日","objectID":"/2023/05/go-%E6%B3%9B%E5%9E%8B/:2:0","tags":["Go笔记"],"title":"Go 泛型（1.18+）","uri":"/2023/05/go-%E6%B3%9B%E5%9E%8B/"},{"categories":["Go笔记"],"content":"泛型Map // map的key必须是可比较的类型，所以这里使用了comparable type MyMap[K comparable, V any] map[K]V func TestMap(t *testing.T) { // 定义map时，指定类型 var myMap MyMap[string, int] myMap = make(MyMap[string, int]) myMap[\"Joker\"] = 18 fmt.Println(myMap) } ","date":"2023年05月27日","objectID":"/2023/05/go-%E6%B3%9B%E5%9E%8B/:3:0","tags":["Go笔记"],"title":"Go 泛型（1.18+）","uri":"/2023/05/go-%E6%B3%9B%E5%9E%8B/"},{"categories":["Go笔记"],"content":"泛型切片 type mySlice[T any] []T func TestSlice(t *testing.T) { // 定义slice时，指定类型 var slice mySlice[int] slice = append(slice, 1, 3, 4, 5) // 如果写入的类型不是指定的类型，会报错：cannot use \"Joker\" (untyped string constant) as int value in argument to append //slice = append(slice, \"Joker\") fmt.Println(slice) // 定义slice时，如果指定的类型是any，可以写入任意类型的值 var slice2 mySlice[any] slice2 = append(slice2, 1, 3, 4, 5, \"Joker\") fmt.Println(slice2) } ","date":"2023年05月27日","objectID":"/2023/05/go-%E6%B3%9B%E5%9E%8B/:4:0","tags":["Go笔记"],"title":"Go 泛型（1.18+）","uri":"/2023/05/go-%E6%B3%9B%E5%9E%8B/"},{"categories":["Go笔记"],"content":"自定义泛型约束 // 定义一个接口 type z interface { GetValue() string } // 定义一个结构体，实现z接口 type MyStruct struct { Name string } func (s MyStruct) GetValue() string { return s.Name } // 定义一个结构体，没有实现z接口 type MyStruct2 struct { } // 定义一个函数，参数必须是实现了z接口的类型 func test[T z](s T) T { fmt.Println(s.GetValue()) return s } func TestCustomize(t *testing.T) { myStruct := MyStruct{ Name: \"Joker\", } // 只能MyStruct类型，MyStruct实现了z接口 m := test[MyStruct](myStruct) fmt.Println(m.Name) user := MyStruct2{} // 如果传入的类型没有实现z接口，会报错：MyStruct2 does not implement z (missing GetValue method) u := test[MyStruct2](user) fmt.Println(u) } ","date":"2023年05月27日","objectID":"/2023/05/go-%E6%B3%9B%E5%9E%8B/:5:0","tags":["Go笔记"],"title":"Go 泛型（1.18+）","uri":"/2023/05/go-%E6%B3%9B%E5%9E%8B/"},{"categories":["Go笔记"],"content":"~用法 将多个约束条件通过~前缀增加到自定义接口，以实现多类型约束 testType[T MyType]等价于testType2[T int | string | bool] type MyType interface { ~int | ~string | ~bool } func testType[T MyType](t T) { fmt.Println(t) } // 使用接口实现泛型约束~int | ~string | ~bool，等价于下面的int | string | bool func testType2[T int | string | bool](t T) { fmt.Println(t) } func TestMyType(t *testing.T) { // 只能传入int、string、bool类型的参数 testType[int](123) testType[string](\"Joker\") testType[bool](false) // 可以不传递类型，但是参数必须是int、string、bool类型 testType(123) testType(\"Joker\") testType(false) // 如果传入的类型不是指定的类型，会报错：float64 does not implement MyType //testType(12.8) // 只能传入int、string、bool类型的参数 testType2[int](123) testType2[string](\"Joker\") testType2[bool](false) // 可以不传递类型，但是参数必须是int、string、bool类型 testType2(123) testType2(\"Joker\") testType2(false) // 如果传入的类型不是指定的类型，会报错：float64 does not implement int|string|bool //testType2(12.8) } ","date":"2023年05月27日","objectID":"/2023/05/go-%E6%B3%9B%E5%9E%8B/:6:0","tags":["Go笔记"],"title":"Go 泛型（1.18+）","uri":"/2023/05/go-%E6%B3%9B%E5%9E%8B/"},{"categories":["Go笔记"],"content":"基本介绍 反射可以在运行时动态获取变量的各种信息，比如变量的类型（type），类别（kind） 如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段、方法） 通过反射，可以修改变量的值，可以调用关联的方法 使用反射，需要引入reflect包 应用场景 不知道接口调用哪个函数，根据传入参数在运行时确定调用的具体接口，这种需要对函数或方法反射。 对结构体序列化时，如果结构体有指定Tag，也会使用到反射生成对应的字符串。 重要的函数和概念 reflect.TypeOf(变量名) 获取变量的属性，返回reflect.Type类型 reflect.ValueOf(变量名) 获取变量的值，返回reflect.Value类型（结构体类型），通过reflect.Value，可以获取到关于该变量的很多信息。 变量、Interface{} 和reflect.Value是可以相互转换的，这点在实际开发中会经常使用到。 快速入门 案例1：演示对（基本数据类型、Interface{}、reflect.Value）进行反射的基本操作 package main import ( \"fmt\" \"reflect\" ) func reflectTest(b any) { // 通过反射获取到传入的变量的type，kind,值 // 1.先获取到reflect.Type rType := reflect.TypeOf(b) fmt.Println(\"rType = \", rType) //rType = int // 2.获取到reflect.Value rValue := reflect.ValueOf(b) fmt.Printf(\"rValue = %v, rValue Type = %T\\n\", rValue, rValue) //rValue = 100, rValue Type = reflect.Value // n2 := 2 + rValue //rValue并不是真正的值，直接使用会报错：2 + rValue (mismatched types untyped int and Value) n2 := 2 + rValue.Int() // 通过rValue.Int()获取到真正的值 fmt.Println(\"n2 = \", n2) //n2 = 102 // 3. 将rValue转换成interface{} iV := rValue.Interface() // 将interface{}通过断言转换成需要的类型 num2 := iV.(int) fmt.Println(\"num2 = \", num2) //num2 = 100 } func main() { var num int = 100 reflectTest(num) } 案例2：演示对（结构体类型、Interface{}、reflect.Value）进行反射的基本操作 func reflectTest2(b any) { // 1.先获取到reflect.Type rType := reflect.TypeOf(b) fmt.Println(\"rType = \", rType) //rType = main.Student // 2.获取到reflect.Value rValue := reflect.ValueOf(b) fmt.Printf(\"rValue = %v, rValue Type = %T\\n\", rValue, rValue) //rValue = {Joker 18}, rValue Type = reflect.Value // 3. 将rValue转换成interface{} iV := rValue.Interface() // 将interface{}通过断言转换成需要的类型 stu, ok := iV.(Student) if ok { fmt.Printf(\"stu.Name = %v, stu.Age = %v\\n\", stu.Name, stu.Age) //stu.Name = Joker, stu.Age = 18 } } type Student struct { Name string Age int } func main() { stu := Student{ Name: \"Joker\", Age: 18, } reflectTest2(stu) } 注意事项和细节说明 1、reflect.Value.Kind 获取变量的类别，返回的是一个常量。文档 2、Type是类型，Kind是类别，它们可能是相同的，也可能是不同的 Var num int = 100 num的Type是int，Kind也是int Var sty Student stu的Type是 pkg.Student，Kind是struct 3、通过反射可以让变量在interface{}和Reflect.Value之间互相转换 4、使用反射的方式来获取变量的值（并返回对应的类型），要求数据类型匹配，比如x是int，那么就应该使用reflect.Value(x).Int()获取值，否则将会在执行时报panic 5、通过反射来修改变量，注意当使用SetXX方法来设置需要通过对应的指针类型来完成，这样才能改变传入的变量的值，通过需要使用到reflect.Value.Elem()方法 func reflectTest3(b any) { rValue := reflect.ValueOf(b) //rValue.SetInt(200) // 错误用法 rValue.Elem().SetInt(200) } func main() { var num = 100 //reflectTest3(num) //如果要修改值，必须传递指针类型，否则报错：reflect.Value.SetInt using unaddressable value reflectTest3(\u0026num) fmt.Println(\"num = \", num) //num = 200 } 6、reflect.Value.Elem()理解 Elem 返回接口 v 包含的值或指针 v 指向的值。如果 v 的种类不是接口或指针，它会发生panics。如果 v 为 nil，则返回零值。 // rValue.Elem()用于获取指针指向变量，类似以下代码示例： num2 := 9 var ptr *int = \u0026num2 *ptr = 3 fmt.Println(\"num2 = \", num2) //num = 3 最佳实践 1、使用反射来遍历结构体的字段，调用结构体的方法，并获取结构体标签的值 func TestReflect01(t *testing.T) { model := User{ Name: \"Joker\", Age: 18, } // 获取reflect.type类型 iType := reflect.TypeOf(model) // 获取reflect.value类型 iValue := reflect.ValueOf(model) // 如果类型不是结构体类型，就退出 if iValue.Kind() != reflect.Struct { t.Error(\"type is not struct\") return } // 获取结构体字段数量 num := iValue.NumField() t.Log(\"num = \", num) // num = 2 // 遍历结构体字段 for i := 0; i \u003c num; i++ { // 获取字段名需要使用reflect.Type name := iType.Field(i).Name t.Logf(\"Field[%d] name: %v, 值: %v\\n\", i, name, iValue.Field(i)) //获取到结构体字段的标签值，需要通过reflect.Type来获取 tagVal := iType.Field(i).Tag.Get(\"json\") if tagVal != \"\" { t.Logf(\"Field[%d],Tag: %v\\n\", i, tagVal) } } // 获取结构体方法数量 numMethod := iValue.NumMethod() t.Log(\"numMethod = \", numMethod) // numMethod = 2 // 遍历结构体方法 for i := 0; i \u003c numMethod; i++ { // 获取方法名需要使用reflect.Type，可以看到这里获取的方法顺序是按照方法名的ASCII码顺序来的 t.Logf(\"Method[%d] name: %v\\n\", i, iType.Method(i).Name) } // 调用方法，需要使用reflect.Value res := iValue.Method(0).Call(nil) t.Log(\"res = \", res[0].Int()) res = iValue.Method(1).Call(nil) t.Log(\"res = \", res[0].String()) params := []reflect.Value{reflect.ValueOf(\"yy\")} res = iValue.Method(2).Call(params) t.Log(\"res = \", res[0].String()) // 可以使用方法名进行调用 res = iValue","date":"2023年05月27日","objectID":"/2023/05/go%E5%8F%8D%E5%B0%84/:0:0","tags":["Go笔记"],"title":"Go 反射","uri":"/2023/05/go%E5%8F%8D%E5%B0%84/"},{"categories":["Go笔记"],"content":"序列化 func Marshal(v any) ([]byte, error) 可传入任意参数进行序列化 【官方文档】 ","date":"2023年05月25日","objectID":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/:0:0","tags":["Go笔记"],"title":"Go 序列化","uri":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["Go笔记"],"content":"结构体序列化 package main import ( \"encoding/json\" \"fmt\" ) type User struct { Name string `json:\"name\"` Age int `json:\"age\"` Hobby []string `json:\"hobby\"` } user := User{ Name: \"Joker\", Age: 20, Hobby: []string{\"跑步\", \"爬山\", \"游泳\"}, } // 调用json.Marshal进行序列化 marshal, err := json.Marshal(\u0026user) if err != nil { fmt.Println(\"Serialization err \", err) } fmt.Println(\"Struct to Serialization result: \", string(marshal)) ","date":"2023年05月25日","objectID":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/:1:0","tags":["Go笔记"],"title":"Go 序列化","uri":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["Go笔记"],"content":"Map序列化 package main import ( \"encoding/json\" \"fmt\" ) var user map[string]any // map使用要先make user = make(map[string]any) user[\"name\"] = \"Desire\" user[\"age\"] = 19 user[\"hobby\"] = []string{\"篮球\", \"羽毛球\"} marshal, err := json.Marshal(user) if err != nil { fmt.Println(\"Serialization err \", err) } fmt.Println(\"Map to Serialization result: \", string(marshal)) ","date":"2023年05月25日","objectID":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/:2:0","tags":["Go笔记"],"title":"Go 序列化","uri":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["Go笔记"],"content":"Slice序列化 package main import ( \"encoding/json\" \"fmt\" ) var users []map[string]any user1 := map[string]any{ \"name\": \"Joker\", \"age\": 18, \"hobby\": []string{\"足球\", \"徒步\"}, } users = append(users, user1) user2 := map[string]any{ \"name\": \"Joker2\", \"age\": 18, \"hobby\": []string{\"足球\", \"徒步\"}, } users = append(users, user2) marshal, err := json.Marshal(users) if err != nil { fmt.Println(\"Serialization err \", err) } fmt.Println(\"Map to Serialization result: \", string(marshal)) 反序列化 func Unmarshal(data []byte, v any) error 参数1：反序列化数据（[]byte）,参数2：反序列化的对象 【官方文档】 ","date":"2023年05月25日","objectID":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/:3:0","tags":["Go笔记"],"title":"Go 序列化","uri":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["Go笔记"],"content":"反序列化成结构体 package main import ( \"encoding/json\" \"fmt\" ) type User struct { Name string `json:\"name\"` Age int `json:\"age\"` Hobby []string `json:\"hobby\"` } str := `{\"name\":\"Joker\",\"age\":20,\"hobby\":[\"跑步\",\"爬山\",\"游泳\"]}` var user User err := json.Unmarshal([]byte(str), \u0026user) if err != nil { fmt.Println(\"Deserialization err \", err) } fmt.Println(user) ","date":"2023年05月25日","objectID":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/:4:0","tags":["Go笔记"],"title":"Go 序列化","uri":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["Go笔记"],"content":"反序列化成Map package main import ( \"encoding/json\" \"fmt\" ) str := `{\"age\":19,\"hobby\":[\"篮球\",\"羽毛球\"],\"name\":\"Desire\"}` var user map[string]any err := json.Unmarshal([]byte(str), \u0026user) if err != nil { fmt.Println(\"Deserialization err \", err) } fmt.Println(user) ","date":"2023年05月25日","objectID":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/:5:0","tags":["Go笔记"],"title":"Go 序列化","uri":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["Go笔记"],"content":"反序列化成Slice package main import ( \"encoding/json\" \"fmt\" ) str := `[{\"age\":18,\"hobby\":[\"足球\",\"徒步\"],\"name\":\"Joker\"},{\"age\":18,\"hobby\":[\"足球\",\"徒步\"],\"name\":\"Joker2\"}]` var users []map[string]any err := json.Unmarshal([]byte(str), \u0026users) if err != nil { fmt.Println(\"Deserialization err \", err) } fmt.Println(users) ","date":"2023年05月25日","objectID":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/:6:0","tags":["Go笔记"],"title":"Go 序列化","uri":"/2023/05/go%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["Go笔记"],"content":"Args解析命令行参数 flag解析命令行参数 package main import ( \"flag\" \"fmt\" \"time\" ) //flag库是Go语言标准库之一，提供了命令行参数解析的能力。 func main() { b := flag.Bool(\"testBool\", false, \"testBool is bool byte.\") // go run main.go -testBool=false port := flag.Int(\"port\", 8081, \"服务端口号\") // go run main.go --port 8080 var ( boolValue bool intValue int int64Value int64 uintValue uint uint64Value uint64 stringValue string float64Value float64 durationValue time.Duration ) flag.BoolVar(\u0026boolValue, \"bool\", false, \"This is bool value.\") flag.IntVar(\u0026intValue, \"int\", 0, \"This is int value.\") flag.Int64Var(\u0026int64Value, \"int64\", 0, \"This is int64 value.\") flag.UintVar(\u0026uintValue, \"uint\", 0, \"This is uint value.\") flag.Uint64Var(\u0026uint64Value, \"uint64\", 0, \"This is uint64 value.\") flag.StringVar(\u0026stringValue, \"string\", \"\", \"This is string value.\") flag.Float64Var(\u0026float64Value, \"float64\", 0, \"This is float64 value\") flag.DurationVar(\u0026durationValue, \"duration\", time.Second*0, \"This is duration value.\") flag.Parse() fmt.Println(*b, *port) } ","date":"2023年05月24日","objectID":"/2023/05/go%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/:0:0","tags":["Go笔记"],"title":"Go 命令行参数","uri":"/2023/05/go%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/"},{"categories":["Go笔记"],"content":"基本介绍 文件再程序中是以流的形式来操作的。 流：数据再数据源（文件）和程序（内存）之间经历的路径 输入流：数据从数据源（文件）到程序（内存）的路径 输出流：数据从程序（内存）到数据源（文件）的路径 os.File封装了所有文件相关的操作，File是一个结构体。 文档 文件操作 ","date":"2023年05月23日","objectID":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:0","tags":["Go笔记"],"title":"Go文件操作","uri":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Go笔记"],"content":"文件打开和关闭 ","date":"2023年05月23日","objectID":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:0","tags":["Go笔记"],"title":"Go文件操作","uri":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Go笔记"],"content":"读文件操作应用实例 1、读取文件的内容使用带缓冲区的方式，使用os.Open, file.Close, bufio.NewReader(), reader.ReadString函数和方法 2、读取文件的内容使用ioutil一次将整个文件读入到内存中，这种方式适用于文件不大的情况。相关方法和函数(ioutil.ReadFile) ","date":"2023年05月23日","objectID":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:2:0","tags":["Go笔记"],"title":"Go文件操作","uri":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Go笔记"],"content":"写文件操作应用实例 ","date":"2023年05月23日","objectID":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:3:0","tags":["Go笔记"],"title":"Go文件操作","uri":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Go笔记"],"content":"os.OpenFile写文件 func OpenFile(name string , flag int , perm FileMode ) (* File , error ) 说明： os.OpenFile是一个更一般性的文件打开函数，它会使用指定的选项、指定的模式打开指定名称的文件。如果操作成功，返回文件对象可用于I/O。如果出错，错误底层类型是*PathError。 参数说明： 第一个参数：文件路径 第二个参数：打开文件的选项： 第三个参数：权限控制 实例： 1、创建新文件并写入内容 os.O_CREATE|os.O_WRONLY(创建|只写) package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { // 创建新文件，写入内容 fileName := \"go-basic/go-file/writer_file/test.txt\" file, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY, 0666) if err != nil { fmt.Println(\"open file err=\", err) return } defer file.Close() // 写入内容 str := \"Hello Golang\\n\" // 使用带缓存的写入 writer := bufio.NewWriter(file) for i := 0; i \u003c 5; i++ { writer.WriteString(str) } //因为写入是带缓存的，所以需要调用Flush方法，将缓存的数据真正写入到文件中 writer.Flush() } 2、打开存在的文件，将原来的内容进行覆盖 os.O_TRUNC|os.O_WRONLY(覆盖|只写) package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { // 打开存在的文件，将原来的内容进行覆盖 fileName := \"go-basic/go-file/writer_file/test.txt\" file, err := os.OpenFile(fileName, os.O_TRUNC|os.O_WRONLY, 0666) if err != nil { fmt.Println(\"open file err=\", err) return } defer file.Close() // 写入内容 str := \"Hello New Golang\\n\" // 使用带缓存的写入 writer := bufio.NewWriter(file) for i := 0; i \u003c 10; i++ { writer.WriteString(str) } //因为写入是带缓存的，所以需要调用Flush方法，将缓存的数据真正写入到文件中 writer.Flush() } 3、打开存在的文件，在原来的内容中追加内容 os.O_APPEND|os.O_WRONLY(追加|只写) package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { // 打开存在的文件，在原来的内容中追加内容 fileName := \"go-basic/go-file/writer_file/test.txt\" file, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY, 0666) if err != nil { fmt.Println(\"open file err=\", err) return } defer file.Close() // 写入内容 str := \"APPEND!\\n\" // 使用带缓存的写入 writer := bufio.NewWriter(file) writer.WriteString(str) //因为写入是带缓存的，所以需要调用Flush方法，将缓存的数据真正写入到文件中 writer.Flush() } 4、打开存在的文件，将原来内容输出在终端，并且追加内容 os.O_RDWR|os.O_APPEND（只读|追加） package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) func main() { // 打开存在的文件，将原来内容输出在终端，并且追加内容 fileName := \"go-basic/go-file/writer_file/test.txt\" file, err := os.OpenFile(fileName, os.O_RDWR|os.O_APPEND, 0666) if err != nil { fmt.Println(\"open file err=\", err) return } defer file.Close() // 读内容原内容 reader := bufio.NewReader(file) for { readString, err := reader.ReadString('\\n') if err == io.EOF { break } fmt.Print(readString) } // 写入内容 str := \"APPEND!\\n\" // 使用带缓存的写入 writer := bufio.NewWriter(file) writer.WriteString(str) //因为写入是带缓存的，所以需要调用Flush方法，将缓存的数据真正写入到文件中 writer.Flush() } ","date":"2023年05月23日","objectID":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:3:1","tags":["Go笔记"],"title":"Go文件操作","uri":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Go笔记"],"content":"ioutil.WriterFile写文件 func WriteFile(filename string, data []byte, perm fs.FileMode) error 实例： package main import ( \"fmt\" \"io/ioutil\" ) func main() { fileName := \"go-basic/go-file/writer_file2/test.txt\" fileName2 := \"go-basic/go-file/writer_file2/test2.txt\" data, err := ioutil.ReadFile(fileName) if err != nil { fmt.Println(\"read file err=\", err) return } // 将test.txt文件内容写入到test2.txt文件中（如果文件不存在则新建） err = ioutil.WriteFile(fileName2, data, 0666) if err != nil { fmt.Println(\"write file err=\", err) return } } ","date":"2023年05月23日","objectID":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:3:2","tags":["Go笔记"],"title":"Go文件操作","uri":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Go笔记"],"content":"判断文件或文件夹是否存在 func (f *File) Stat() (FileInfo, error) 如果返回的错误为nil，说明文件或文件夹存在 如果返回的错误类型使用os.IsNotExist()判断为true，说明文件或文件夹不存在 如果返回的错误为其他类型，则不确定是否存在 func PathIsExist(path string) bool { _, err := os.Stat(path) if err == nil { return true } if os.IsExist(err) { return true } return false } ","date":"2023年05月23日","objectID":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:4:0","tags":["Go笔记"],"title":"Go文件操作","uri":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Go笔记"],"content":"拷贝文件 func Copy(dst Writer, src Reader) (written int64, err error) 实例： package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) func FileCopy(dstFileName string, srcFileName string) (written int64, err error) { // 打开需要拷贝的文件 srcFile, err := os.Open(srcFileName) if err != nil { return 0, err } // 创建一个reader reader := bufio.NewReader(srcFile) // 打开需要写入的文件 dstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, 0666) if err != nil { return 0, err } // 创建一个writer writer := bufio.NewWriter(dstFile) // 关闭文件 defer func() { srcFile.Close() dstFile.Close() }() // 使用io.Copy开始拷贝 return io.Copy(writer, reader) } func main() { // 将6.JPG文件拷贝到6_copy.JPG srcFile := \"6.JPG\" dstFile := \"6_copy.JPG\" fileCopy, err := FileCopy(dstFile, srcFile) if err != nil { return } fmt.Println(\"拷贝成功，共拷贝了\", fileCopy, \"字节\") } ","date":"2023年05月23日","objectID":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:5:0","tags":["Go笔记"],"title":"Go文件操作","uri":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Go笔记"],"content":"统计不同类型的字符数量 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) type CharCount struct { ChCount int // 记录英文个数 NumCount int // 记录数字个数 SpaceCount int // 记录空格个数 OtherCount int // 记录其他字符个数 } func main() { // 实例化记录结构体 count := CharCount{} // 打开文件 fileName := \"go-basic/go-file/file_count/test.txt\" file, err := os.Open(fileName) if err != nil { fmt.Println(\"open file err=\", err) return } defer file.Close() //创建一个reader reader := bufio.NewReader(file) // 每读取一行，就去统计该行有多少个英文、数字、空格以及其他字符 for { readString, err := reader.ReadString('\\n') if err == io.EOF { break } // 遍历readString，进行统计 for _, v := range readString { switch { case v \u003e= 'a' \u0026\u0026 v \u003c= 'z': fallthrough // 穿透 case v \u003e= 'A' \u0026\u0026 v \u003c= 'Z': count.ChCount++ case v == ' ' || v == '\\t': count.SpaceCount++ case v \u003e= '0' \u0026\u0026 v \u003c= '9': count.NumCount++ default: count.OtherCount++ } } } // 然后将结果保存在一个结构体中 fmt.Println(\"字符的个数为：\", count.ChCount) fmt.Println(\"数字的个数为：\", count.NumCount) fmt.Println(\"空格的个数为：\", count.SpaceCount) fmt.Println(\"其他字符的个数为：\", count.OtherCount) } ","date":"2023年05月23日","objectID":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:6:0","tags":["Go笔记"],"title":"Go文件操作","uri":"/2023/05/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Go笔记"],"content":"基本介绍 Golang仍然有面向对象编程的继承、封装和多态的特性，只是实现的方式和其他OOP语言不一样。 封装 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:0:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"封装的介绍 封装（encapsulation）就是把抽象出的字段和字段的操作封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作。 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:1:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"封装的好处 隐藏实现细节 可以对数据进行验证，保证安全合理 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:2:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"如何体现封装 对结构体中的属性进行封装 通过方法、包实现封装 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:3:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"封装的实现步骤 将结构体、字段（属性）的首字母小写（类似private） type student struct { name string age int } 给结构体所在包提供一个工厂模式的函数，首字母大写。类似一个构造函数 func NewStudent() *student { return \u0026student{} } 提供一个首字母大写的Set方法，用于对属性判断并赋值 func (s *student) SetName(name string) { s.name = name } func (s *student) SetAge(age int) { if age \u003e 0 \u0026\u0026 age \u003c 150 { s.age = age } } 提供一个首字母大写的Get方法，用户获取属性的值 func (s *student) GetName() string { return s.name } func (s *student) GetAge() int { return s.age } 调用 student := model.NewStudent() student.SetName(\"Joker\") student.SetAge(19) fmt.Println(student.GetName(), student.GetAge()) //Joker 19 继承 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:4:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"继承的介绍 继承可以解决代码复用，让编程更加靠近人类思维。 当多个结构体存在相同的属性（字段）和方法时，可以从这些结构体中抽象出结构体，在该结构体中定义这写相同的属性和方法。其他的结构体不需要重新定义这些属性和方法，只需嵌套一个抽象出来的匿名结构体即可。 也就是说：在Golang中，如果一个struct嵌套了另一个匿名结构体，那么这个结构体可以直接访问匿名结构体的字段和方法，从而实现了继承特性。 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:5:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"嵌套匿名结构体的基本语法 type Person struct { Name string Age int } type Student struct { Person // 这就是嵌套匿名结构体 Score float64 } ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:6:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"继承的深入讨论 1、结构体可以使用嵌套匿名结构体所有的字段和方法，即：首字母大写或小写的字段、方法都可以使用 2、匿名结构体字段访问可以简化 3、当结构体和匿名结构体有相同的字段或方法时，编译器采用就近访问原则访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分 4、结构体嵌入两个（或多个）匿名结构体，如两个匿名结构体有相同的字段和方法（同时结构体本身没有同名的字段和方法），在访问时，就必须明确指定匿名结构体名字，否则编译报错 5、如果一个struct嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段或方法时，必须带上结构体的名字 6、嵌套匿名结构体后，也可以在创建结构体变量（实例）时，直接指定各个匿名结构体字段的值 接口（interface） ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:7:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"基本介绍 interface类型可以定义一组方法，但是这些方法不需要实现。并且interface不能包含任何变量。 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:8:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"基本语法 type 接口名 interface { method1(参数列表) 返回值列表 method2(参数列表) 返回值列表 } 实现接口所有方法 func (c 自定义类型) method1(参数列表) 返回值列表 { // 方法实现 } func (c 自定义类型) method2(参数列表) 返回值列表 { // 方法实现 } 说明： 接口里的所有方法都没有方法体，即接口的方法都是没有实现的。接口体现了程序设计的多态和高内聚低耦合的思想。 Golang中的接口，不需要显式的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现了这个接口。 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:9:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"注意事项和细节 1、接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量（实例） 2、接口中所有的方法都没有方法体，即都是没有实现的方法 3、在Golang中，一个自定义类型需要将某个接口的所有方法都实现，那么这个自定义类型就实现了该接口 4、一个自定义类型只有实现了某个接口，才能将该自定义类型的实例（变量）赋给接口类型 5、只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型 6、一个自定义类型可以实现多个接口 7、Golang接口中不能有任何变量 8、一个接口可以继承多个别的接口，如果要实现接口，也必须将接口继承的别的接口的方法也全部实现 9、interface类型默认是一个指针（引用类型），如果没有对interface初始化就使用，那么会输出nil 10、空接口interface{}没有任何方法，所以所有类型都实现了空接口，即可以把任何一个变量赋值给空接口 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:10:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"接口经典案例（结构体排序） package main import ( \"fmt\" \"math/rand\" \"sort\" ) type Student struct { Name string Age int } type StudentSlice []Student func (s StudentSlice) Len() int { // 获取切片长度 return len(s) } func (s StudentSlice) Less(i, j int) bool { // 按照年龄升序 return s[i].Age \u003c s[j].Age } func (s StudentSlice) Swap(i, j int) { // 交换顺序 s[i], s[j] = s[j], s[i] } func main() { slice := StudentSlice{} for i := 0; i \u003c 10; i++ { student := Student{Name: fmt.Sprintf(\"Joker-%d\", rand.Intn(100)), Age: rand.Intn(150)} slice = append(slice, student) } fmt.Println(\"原结构体顺序：\") for _, stu := range slice { fmt.Println(stu) } sort.Sort(slice) fmt.Println(\"排序后结构体顺序：\") for _, stu := range slice { fmt.Println(stu) } } ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:11:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"接口VS继承 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:12:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"案例 package main import \"fmt\" type IBird interface { Fly() } type IFish interface { Swim() } type Monkey struct { Name string } func (m *Monkey) ClimbTree() { fmt.Println(m.Name, \"会爬树...\") } type SmallMonkey struct { Monkey // 继承了Monkey结构体 } // Fly 给SmallMonkey延伸Fly功能 func (m SmallMonkey) Fly() { fmt.Println(m.Name, \"学会了飞行...\") } // Swim 给SmallMonkey延伸Swim功能 func (m SmallMonkey) Swim() { fmt.Println(m.Name, \"学会了游泳...\") } func main() { smallMonkey := SmallMonkey{Monkey{Name: \"悟空\"}} smallMonkey.ClimbTree() smallMonkey.Fly() smallMonkey.Swim() var b IBird = smallMonkey b.Fly() var f IFish = smallMonkey f.Swim() } ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:12:1","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"总结 当A结构体继承了B结构体，那么A结构体就自动的继承了B结构体的字段和方法，并且可以直接使用 当A结构体需要扩展功能，同时不希望去破坏继承关系，则可以去实现某个接口即可，因此可以认为，实现接口是对继承机制的补充 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:12:2","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"接口 VS 继承 接口和继承解决的问题不同 继承的价值主要在于：解决代码的复用性和可维护性 接口的价值主要在于：设计，设计好各种规范（方法），让其它自定义类型去实现这些方法。 接口比继承更加灵活 接口比继承更加灵活，继承是满足is - a的关系，而接口只需满足like - a的关系 接口在一定程度上实现代码解耦 多态 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:12:3","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"基本介绍 变量（实例）具有多种形态。在Golang中，多态特性是通过接口实现的。可以按照统一的接口来调用不同的实现。这时接口变量就呈现不同的形态。 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:13:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"接口体现多态的两种形式 多态参数 多态数组 ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:14:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"类型断言 类型断言，由于接口是一般类型，不知道具体类型，如果要转成具体类型，就需要使用类型断言。 func main() { // 类型断言 var x interface{} var b float64 = 29.9 x = b // 空接口，可以接受任意类型 y := x.(float64) // 使用类型断言 fmt.Printf(\"y 的类型是 %T 值是 %v\\n\", y, y) // y 的类型是 float64 值是 29.9 } 进行断言时进行检测： func main() { // 类型断言 var x interface{} var b float64 = 29.9 x = b // 空接口，可以接受任意类型 if f, ok := x.(float32); ok { // 进行检测 y := f // 使用类型断言 fmt.Printf(\"y 的类型是 %T 值是 %v\\n\", y, y) // y 的类型是 float64 值是 29.9 } else { fmt.Println(\"convert fail\") } } ","date":"2023年05月21日","objectID":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/:15:0","tags":["Go笔记"],"title":"Go面向对象三大特性","uri":"/2023/05/go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"},{"categories":["Go笔记"],"content":"结构体 ","date":"2023年05月19日","objectID":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/:0:0","tags":["Go笔记"],"title":"Go结构体","uri":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go笔记"],"content":"声明结构体 基本语法 type 结构体名称 struct{ field1 type field2 type } ","date":"2023年05月19日","objectID":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/:1:0","tags":["Go笔记"],"title":"Go结构体","uri":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go笔记"],"content":"字段/属性 基本介绍 结构体字段 = 属性 = field 字段是结构体的一个组成部分，一般是基本数据类型、数组，也可是引用类型 注意事项 字段声明语法同变量，示例：Name string 字段的类型可以为：基本类型、数组或引用类型 在创建一个结构体变量后，如果没有给字符赋值，都对应一个零值(默认值) 布尔类型是false，数值是0，字符串是\"\" 数组类型的默认值和它的元素类型相关，比如：score[3] int 默认值：[0,0,0] 指针、slice和map的零值都是nil，即还没有分配空间，需要make后使用 不同结构体变量的字段是独立的，互不影响，一个结构体变量字段的更改，不影响另外一个 ","date":"2023年05月19日","objectID":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/:2:0","tags":["Go笔记"],"title":"Go结构体","uri":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go笔记"],"content":"创建结构体变量 方式一：直接声明 var person Person 方式二：{} var person Person = Person{} 方式三：new var person *Person = new(Person) 方式四：\u0026 var person *Person = \u0026Person{} 说明 第3、4种方式返回的是结构体指针。 结构体指针访问字段的标准方式：(*结构体指针).字段名，比如：(*person).Name = \"tom\" 对于结构体指针访问字段，golang做了简化操作，也支持 结构体指针.字段名，比如：person.Name = \"tom\"。这样更加符合程序员使用习惯，golang底层进行了一步转化操作。 ","date":"2023年05月19日","objectID":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/:3:0","tags":["Go笔记"],"title":"Go结构体","uri":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go笔记"],"content":"结构体内存分配机制 ","date":"2023年05月19日","objectID":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/:4:0","tags":["Go笔记"],"title":"Go结构体","uri":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go笔记"],"content":"结构体变量在内存中存在示例图 变量总是存在内存中的，那么结构体变量也是一样的 var p1 Person p1.Name = \"Joker\" p1.Age = 18 var p2 Person = p1 fmt.Println(p2.Age) //18 p2.Name = \"Tommy\" fmt.Printf(\"p2.Name=%v, p1.Name=%v\\n\", p2.Name, p1.Name) //p2.Name=Tommy, p1.Name=Joker 示例图： ","date":"2023年05月19日","objectID":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/:4:1","tags":["Go笔记"],"title":"Go结构体","uri":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go笔记"],"content":"结构体指针变量在内存中存在示例图 var p1 Person p1.Name = \"Joker\" p1.Age = 18 var p2 *Person = \u0026p1 fmt.Println((*p2).Age) //18 fmt.Println(p2.Age) //18 p2.Name = \"Tommy\" fmt.Printf(\"p2.Name=%v, p1.Name=%v\\n\", p2.Name, p1.Name) //p2.Name=Tommy, p1.Name=Tommy fmt.Printf(\"p2.Name=%v, p1.Name=%v\\n\", (*p2).Name, p1.Name) //p2.Name=Tommy, p1.Name=Tommy 示例图： ","date":"2023年05月19日","objectID":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/:4:2","tags":["Go笔记"],"title":"Go结构体","uri":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go笔记"],"content":"结构体使用注意事项和细节 结构体的所有字段在内存中是连续的 package main import \"fmt\" type Point struct { x int y int } type Rect struct { leftUp, rightDown Point } type Rect2 struct { leftUp, rightDown *Point } func main() { r1 := Rect{Point{1, 2}, Point{3, 4}} // r1有4个int，在内存中是连续分布的 fmt.Printf(\"r1.leftUp.x的地址=%p r1.leftUp.y的地址=%p r1.rightDown.x的地址=%p r1.rightDown.y的地址=%p\\n\", \u0026r1.leftUp.x, \u0026r1.leftUp.y, \u0026r1.rightDown.x, \u0026r1.rightDown.y) // r1.leftUp.x的地址=0x1400012c000 r1.leftUp.y的地址=0x1400012c008 r1.rightDown.x的地址=0x1400012c010 r1.rightDown.y的地址=0x1400012c018 r2 := Rect2{\u0026Point{10, 20}, \u0026Point{30, 40}} // r2有2个*Point，在内存中2个*Point本身地址也是连续分布的 fmt.Printf(\"r2.leftUp 本身地址=%p r2.rightDown 本身地址=%p\\n\", \u0026r2.leftUp, \u0026r2.rightDown) //r2.leftUp 本身地址=0x1400008e210 r2.rightDown 本身地址=0x1400008e218 // 但是它们指向的地址不一定是连续的 fmt.Printf(\"r2.leftUp 指向地址=%p r2.rightDown 指向地址=%p\\n\", r2.leftUp, r2.rightDown) //r2.leftUp 指向地址=0x140000a8010 r2.rightDown 指向地址=0x140000a8020 } 内存分布图： 结构体是用户单独定义的类型，和其它类型进行转换时需要有完全相同的字段（名字、个数和类型） package main import \"fmt\" type A struct { Num int } type B struct { Num int } func main() { var a A var b B a = A(b) // 可以进行转换 fmt.Println(a, b) } 结构体进行type重新定义（相当于取别名），Golang认为是新的数据类型，但是相互间可以强转 type Student struct { Name string Age int } type Stu Student var stu1 Student var stu2 Stu //stu2 = stu1 //cannot use stu1 (variable of type Student) as type Stu in assignment stu2 = Stu(stu1) fmt.Println(stu1, stu2) struct的每个字段上，可以写上一个tag，该tag可以通过反射机制获取，常见的使用场景就是序列化和反序列化 方法 Golang中的方法是作用在指定的数据类型上（即：和指定的数据类型绑定），因此自定义类型，都可以有方法，而不仅仅是struct ","date":"2023年05月19日","objectID":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/:5:0","tags":["Go笔记"],"title":"Go结构体","uri":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go笔记"],"content":"声明方法 func (recevier type) methodName (参数列表) （返回值列表）{ // 方法体 return 返回值 } recevier type：表示这个方法和type这个类型进行绑定，或者说该方法作用于type类型 recevier type：type可以是结构体，也可以是其它的自定义类型 recevier ：就是type类型的一个变量（实例）， 参数列表：方法输入 返回值列表：返回值，可以有多个 方法体：逻辑代码 return：不是必须的 示例： ","date":"2023年05月19日","objectID":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/:6:0","tags":["Go笔记"],"title":"Go结构体","uri":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go笔记"],"content":"方法的调用和传参机制原理 说明：方法的调用和传参机制和函数基本一样，不一样的地方是方法调用时，会将调用方法的变量，当做实参也传递给方法。 ","date":"2023年05月19日","objectID":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/:7:0","tags":["Go笔记"],"title":"Go结构体","uri":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go笔记"],"content":"方法注意事项和细节 1、结构体类型是值类型，在方法调用中，遵守值类型的传递机制，是值拷贝传递方式。 2、如果希望在方法中修改结构体变量的值，可以通过结构体指针的方式进行处理。（这种方式用的比较多，因为指针传递效率高） 3、Golang中的方法作用在指定的数据类型上（即：和指定的数据类型绑定），因此自定义类型，都可以有方法，而不仅仅是struct。 4、方法的访问范围控制的规则，和函数一样。方法名首字母小写，只能在本包访问，方法首字母大写，可以在本包和其他包访问。 5、如果一个变量实现了String()这个方法，那么fmt.Println默认会调用这个变量的String()进行输出。 ","date":"2023年05月19日","objectID":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/:8:0","tags":["Go笔记"],"title":"Go结构体","uri":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["Go笔记"],"content":"方法 VS 函数 1、调用方式不一样 函数的调用方式：函数名(实参列表) 方法的调用方式：变量.方法名(实参列表) 2、普通函数，接收者为值类型时，不能将指针类型的数据直接传递 3、对于方法，接收者为值类型时，可以直接用指针类型的变量调用方法，反过来也可以。 注：不管调用形式如何，真正决定是值拷贝还是地址拷贝还是看方式是和哪种类型绑定 工厂模式 Golang的结构体没有构造函数，通常可以使用工厂模式来解决这个问题。 使用工厂模式解决结构体首字母小写在别的包调用问题： ","date":"2023年05月19日","objectID":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/:9:0","tags":["Go笔记"],"title":"Go结构体","uri":"/2023/05/go%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["PHP","Laravel"],"content":"基本路由 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:0:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"基本路由 最基本的Laravel路由仅接受URI和一个闭包： Route::get(\"foo\", function () { return 'Hello PHP'; }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:1:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"可用的路由器方法 路由器允许注册响应任何HTTP动词的路由 Route::get(uri, $callback); Route::post(uri, $callback); Route::put(uri, $callback); Route::patch(uri, $callback); Route::delete(uri, $callback); Route::options(uri, $callback); 在Laravel中可以定义响应多个HTTP动作的路由 /** * 注册可响应多个HTTP动作的路由 */ Route::match(['get', 'post'], 'match', function () { return '使用match定义可响应多个HTTP动作的路由'; }); /** * 注册可响应全部HTTP动作的路由 */ Route::any('any', function () { return '使用any定义全部HTTP动作的路由'; }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:1:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"依赖注入 可以在路由的回调签名中键入提示路由所需要的任何依赖项。 声明的依赖项将自动解析，并由Laravel服务容器注入回调中。 Route::get('/api', function (Request $request) { Log::info(\"api接口请求\"); print_r($request-\u003eall()); return 'api接口请求'; }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:1:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"重定向路由 Route::redirect方法提供了一个方便快捷的方式进行重定向到另一个URI的路由 Route::redirect('/here', '/api/first'); 默认情况下，返回了302状态码，可以使用可选参数进行自定义状态码 Route::redirect('/here', '/api/first', 301); 或者可以使用Route::permanentRedirect，此方法返回301状态码 Route::permanentRedirect('/here2', '/api/api'); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:2:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"路由列表 # 查看全部路由 php artisan route:list # 通过-v选项来显示路由中间件 php artisan route:list -v # 通过 --path 选项仅显示给定URI开头的路由 php artisan route:list --path=api # 通过 --except-vendor 选项隐藏第三方软件包定义的任何路由 php artisan route:list --except-vendor # 通过 --only-vendor 选项只显示第三方软件包定义的任何路由 php artisan route:list --only-vendor ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:3:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"路由参数 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:4:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"必需参数 在路由中捕获URI的段 路由参数适中包含在{}大括号中，并应由字母字符组成，下划线_在路由参数名称中也是可以的。 路由参数根据其顺序注入路由回调/控制器，参数的名称无关紧要。 // 从URL中获取用户ID Route::get('/user/{id}', function (string $id) { return 'User ' . $id; }); // URL：http://127.0.0.1:8000/api/user/1 // 结果：User 1 Route::get('/posts/{post}/comments/{comment}', function (string $postId, string $commentId) { return 'Post id -\u003e ' . $postId . ' Comment id -\u003e ' . $commentId; }); // url: http://127.0.0.1:8000/api/posts/1001/comments/3000 // 结果：Post id -\u003e 1001 Comment id -\u003e 3000 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:4:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"参数和依赖注入 如果路由具有依赖项，并希望Laravel服务容器自动注入路由的回调中，应该在依赖项之后列出路由参数 use Illuminate\\Http\\Request; Route::get('/user/{id}', function (Request $request, string $id) { return 'User ' . $id; }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:4:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"可选参数 通过放置一个?在参数名称后标记，则可设置一个可选参数。 注：确保给路由的相应变量一个默认值。 Route::get('/user/{name?}', function (string $name = null) { return $name; }); Route::get('/user/{name?}', function (string $name = 'Joker') { return $name; }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:4:3","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"正则表达式约束 使用路由实例上的where方法限制路由参数的格式 where方法接受参数的名称和定义如何约束参数的正则表达式 如果传入的请求与路由模式约束不匹配，将返回404HTTP响应 Route::get('/user/{name}', function (string $name) { // ... })-\u003ewhere('name', '[A-Za-z]+'); Route::get('/user/{id}', function (int $id) { //... })-\u003ewhere('id', '[0-9]+'); Route::get('/user/{id}/{name}', function (int $id, string $name) { // ... })-\u003ewhere(['id' =\u003e '[0-9]+', 'name' =\u003e '[A-Za-z]+']); 为了方便起见，一些常用的正则表达式具有辅助方法，允许快速向路由添加模式约束 /** * whereAlphaNumeric: 指定给定的路由参数必须是字母数字 */ Route::get('/user/{name}', function (string $name) { // ... })-\u003ewhereAlphaNumeric('name'); /** * whereNumber: 指定给定的路由参数必须是数字 */ Route::get('/user/{id}', function (int $id) { //... })-\u003ewhereNumber('id'); /** * 使用多个参数约束条件 */ Route::get('/user/{id}/{name}', function (int $id, string $name) { // ... })-\u003ewhereNumber('id')-\u003ewhereAlpha('name'); /** * whereUuid: 指定给定的路由参数必须是UUlDs。 */ Route::get('/user/{id}', function (string $id) { // ... })-\u003ewhereUuid('id'); /** * whereUlid: 指定给定的路由参数必须是ULIDs。 */ Route::get('/user/{id}', function (string $id) { // ... })-\u003ewhereUlid('id'); /** * whereIn: 指定给定的路由参数必须是给定值之一 */ Route::get('/category/{category}', function (string $category) { // ... })-\u003ewhereIn('category', ['movie', 'song', 'painting']); 全局约束条件 使用patten方法可以定义全局约束条件。 在app/Providers/RouteServiceProvider.php文件中的RouteServiceProvider类的boot方法中定义这些全局约束条件模式 public function boot(): void { // 定义全局约束条件 Route::pattern('id', '[0-9]+'); // ... } 一旦定义了全局模式，将使用参数名称的自动应用于所有路由 Route::get('/user/{id}', function (string $id) { return 'userid -\u003e ' . $id; }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:4:4","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"编码的正斜杠 Laravel路由组件允许除/之外的所有字符都在存在于路由参数值中。 必须使用where条件正则表达式明确允许/成为占位符的一部分。 注：编码的正斜杠仅在最后一个路由段内受支持。 Route::get('/search/{search}', function (string $search) { return 'Search -\u003e ' . $search; })-\u003ewhere('search', '.*'); // URL：http://127.0.0.1:8000/api/search/Joker/19/Shenzhen // 结果：Search -\u003e Joker/19/Shenzhen ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:4:5","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"命名路线 命名路由允许为特定路由方便地生成URL或重定向。 通过name方法链接到路由定义上，可以指定路由的名称。 注：路由名称应始终是唯一的。 Route::get('/user/profile', function () { // ... })-\u003ename('profile'); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:5:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"生成命名路由的URL 一旦为给定的路由分配一个名字，可以通过Laravel的route和redirect辅助函数生成URL或重定向时使用该路由的名称： Route::get('/user/create', function () { // 生成完整的URL $url = route('profile'); log::debug($url) // http://127.0.0.1:8000/api/user/profile // 生成重定向(两种方式) // return redirect()-\u003eroute('profile'); return to_route('profile'); }); 如果命名路由定义了参数，可以将参数作为第二个参数传递给route函数。给定的参数将自动插入到生成的URL的正确位置： Route::get('/user/{id}/profile', function (string $id) { // ... })-\u003ename('profile'); // 生成完整的URL $url = route('profile', ['id' =\u003e 1]); log::debug($url); // http://127.0.0.1:8000/api/user/1/profile 如果在数组中传递其他参数，这些键值对将自动添加到生成的URL的查询字符串中： $url = route('profile', ['id' =\u003e 1, 'photos' =\u003e 'yes']); log::debug($url); // http://127.0.0.1:8000/api/user/1/profile?photos=yes ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:5:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"检查当前路由 如果想确定当前请求是否路由到给定的命名路由，可以在Route实例上使用named方法。例如，可以在路由中间件检查当前路由名称： if ($request-\u003eroute()-\u003enamed('profile')){ // ... } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:5:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"路由组 路由组允许共享路由属性。例如中间件，而无需在每个独立的路由上定义这些属性。 嵌套组尝试智能地将属性与其父组\"合并\"。中间件和where条件合并，同时附加名称和前缀。URL前缀中的命名空间分隔符和斜杠会在适当的地方自动添加。 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:6:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"路由中间件 要将中间件分配给组内的所有路由，可以在定义组之前使用middleware方法。 中间件按照它们在数组中列出的顺序执行 Route::middleware(['first', 'second'])-\u003egroup(function () { Route::get('/', function () { // ... }); Route::get('/user/profile', function () { // ... }); }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:6:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"控制器 如果一组路由都使用相同的控制器，可以使用controller方法为组内的所有路由定义公共控制器。然后再定义路由时，只需要提供他们调用的控制器方法 use \\App\\Http\\Controllers\\Api\\OrderController; Route::controller(OrderController::class)-\u003egroup(function () { Route::get('/order/{id}', 'show'); Route::get('/orders', 'store'); }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:6:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"路由前缀 prefix方法可以用给定的URI为组中的每个路由做前缀。 Route::prefix('admin')-\u003egroup(function () { Route::get('/users', function () { // 对应 '/admin/users' 的URL }); }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:6:3","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"路由名称前缀 name方法可以给定字符串作为组中的每个路由名的前缀 建议要提供末尾.字符在前缀中 Route::name('admin.')-\u003egroup(function () { Route::get('/users', function () { // 被分配的路由名为：'admin.users' })-\u003ename('users'); }); 中间件 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:6:4","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"定义中间件 可以使用make:middleware Artisan命令 php artisan make:middleware EnsureTokenIsValid 此命令将在项目的 app/Http/Middleware 目录中放置一个新的 EnsureTokenIsValid 类。 \u003c?php namespace App\\Http\\Middleware; use Closure; use Illuminate\\Http\\Request; use Symfony\\Component\\HttpFoundation\\Response; class EnsureTokenIsValid { /** * Handle an incoming request. * * @param \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response) $next */ public function handle(Request $request, Closure $next): Response { // 判断传入的token是否一致 if ($request-\u003einput('token') !== 'my-secret-token') { return redirect('home') // 如果不一致，则重定向到home路由 } return $next($request); } } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:7:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"中间件和相应 中间件可以在请求更深入地传递到应用程序之前或之后执行任务 请求之前执行任务 \u003c?php namespace App\\Http\\Middleware; use Closure; use Illuminate\\Http\\Request; use Symfony\\Component\\HttpFoundation\\Response; class BeforeMiddleware { /** * Handle an incoming request. * * @param \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response) $next */ public function handle(Request $request, Closure $next): Response { // 执行操作 return $next($request); } } 请求后执行任务 \u003c?php namespace App\\Http\\Middleware; use Closure; use Illuminate\\Http\\Request; use Symfony\\Component\\HttpFoundation\\Response; class AfterMiddleware { /** * Handle an incoming request. * * @param \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response) $next */ public function handle(Request $request, Closure $next): Response { $response = $next($request); // 执行操作 return $response; } } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:8:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"注册中间件 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:9:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"全局中间件 如果希望在对应程序的每个HTTP请求期间运行中间件，需要在app/Http/Kernel.php类的$middleware属性中列出中间件类。 class Kernel extends HttpKernel { /** * The application's global HTTP middleware stack. * * These middleware are run during every request to your application. * * @var array\u003cint, class-string|string\u003e */ protected $middleware = [ // \\App\\Http\\Middleware\\TrustHosts::class, \\App\\Http\\Middleware\\TrustProxies::class, \\Illuminate\\Http\\Middleware\\HandleCors::class, \\App\\Http\\Middleware\\PreventRequestsDuringMaintenance::class, \\Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize::class, \\App\\Http\\Middleware\\TrimStrings::class, \\Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull::class, ]; ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:9:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"将中间件分配给路由 如果要将中间件分配给特定路由，可以在定义路由时调用middleware方法 use \\App\\Http\\Middleware\\BeforeMiddleware; Route::get('/profile', function () { // ... })-\u003emiddleware(BeforeMiddleware::class); 通过向middleware方法传递一组中间件名称，可以为路由分配多个中间件 use \\App\\Http\\Middleware\\BeforeMiddleware; use \\App\\Http\\Middleware\\AfterMiddleware; Route::get('/profile', function () { // ... })-\u003emiddleware([BeforeMiddleware::class, AfterMiddleware::class]); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:9:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"定义中间件别名 为了方便起见，可以在应用程序的app/Http/Kernel.php文件中为中间件分配别名 protected $middlewareAliases = [ ... // 自定义中间价 'before' =\u003e \\App\\Http\\Middleware\\BeforeMiddleware::class, 'after' =\u003e \\App\\Http\\Middleware\\AfterMiddleware::class ]; 在路由中使用中间件分配的别名 Route::get('/profile', function () { // ... })-\u003emiddleware(['before', 'after']); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:9:3","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"排除中间件 当将中间件分配给一组路由时，可能偶尔需要防止中间件应用于组内的单个路由。 可以使用withoutMiddleware方法完成此操作。 use \\App\\Http\\Middleware\\EnsureTokenIsValid; Route::middleware([EnsureTokenIsValid::class])-\u003egroup(function () { Route::get('/', function () { // ... }); Route::get('/profile', function () { // ... })-\u003ewithoutMiddleware([EnsureTokenIsValid::class]); }); 也可以从整个组路由定义中排除一组给定的中间件 use \\App\\Http\\Middleware\\EnsureTokenIsValid; Route::middleware([EnsureTokenIsValid::class])-\u003egroup(function () { Route::get('/', function () { // ... }); Route::withoutMiddleware([EnsureTokenIsValid::class])-\u003egroup(function () { Route::get('/login', function () { // ... }); }); }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:9:4","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"中间件组 如果希望将多个中间件组合在一个键下，以使它们更容易分配给路由。可以使用HTTP内核的$middlewareGroups属性来完成此操作。 Laravel包括预定义带有web和api中间件组，其中包含肯呢个希望应用于web和api路由的常见中间件。这些中间件组会由应用程序的App\\Providers\\RouteServiceProvider服务提供者自动应用于相应的web和api路由文件中的路由 /** * The application's route middleware groups. * * @var array\u003cstring, array\u003cint, class-string|string\u003e\u003e */ protected $middlewareGroups = [ 'web' =\u003e [ \\App\\Http\\Middleware\\EncryptCookies::class, \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, // \\App\\Http\\Middleware\\VerifyCsrfToken::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], 'api' =\u003e [ // \\Laravel\\Sanctum\\Http\\Middleware\\EnsureFrontendRequestsAreStateful::class, \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class . ':api', \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], ]; 中间件组可以使用与单个中间件相同的语法分配给路由和控制器动作。同理，中间件组使一次将多个中间件分配给一个路由更加方便 Route::get('/', function () { // ... })-\u003emiddleware('web'); Route::middleware(['web'])-\u003egroup(function () { // ... }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:9:5","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"排序中间件 在特定情况下，可能需要中间件以特定的顺序执行，但当它们分配到路由时，是无法控制它们的顺序的。这种情况下，可以使用到app/Http/Kernel.php文件的$middlewarePriority属性指定中间件优先级。 注：默认情况下，HTTP内核中可能不存在此属性。如果不存在则新增即可。 /** * 中间件的优先级排序列表 * * 这迫使非全局中间件始终处于给定的顺序 * * @var string[] */ protected $middlewarePriority = [ \\Illuminate\\Foundation\\Http\\Middleware\\HandlePrecognitiveRequests::class, \\Illuminate\\Cookie\\Middleware\\EncryptCookies::class, \\Illuminate\\Session\\Middleware\\StartSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\Illuminate\\Contracts\\Auth\\Middleware\\AuthenticatesRequests::class, \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, \\Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis::class, \\Illuminate\\Contracts\\Session\\Middleware\\AuthenticatesSessions::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, \\Illuminate\\Auth\\Middleware\\Authorize::class, ]; ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:9:6","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"中间件参数 中间件也可以接收额外的参数，额外的中间件参数将在$next参数之后传递给中间件 \u003c?php namespace App\\Http\\Middleware; use Closure; use Illuminate\\Http\\Request; use Symfony\\Component\\HttpFoundation\\Response; class EnsureTokenIsValid { /** * Handle an incoming request. * * @param \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response) $next */ public function handle(Request $request, Closure $next, string $role): Response { if (!$request-\u003euser()-\u003ehasRole($role)) { // 重定向... } return $next($request); } } 在定义路由时，可以指定中间件参数，方法是使用:分割中间件名称和参数。多个参数应以逗号分隔 Route::put('/post/{id}', function (string $id) { // ... })-\u003emiddleware('role:editor'); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:9:7","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"可终止的中间件 部分情况下，在将HTTP响应发送到浏览器之后，中间件可能需要做一些工作。 如果在中间件上定义了一个terminate方法，并且web服务器使用FastCGI，则在将响应发送到浏览器后会自动调用terminate方法 \u003c?php namespace App\\Http\\Middleware; use Closure; use Illuminate\\Http\\Request; use Symfony\\Component\\HttpFoundation\\Response; class TerminatingMiddleware { /** * Handle an incoming request. * * @param \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response) $next */ public function handle(Request $request, Closure $next): Response { return $next($request); } /** * 在响应发送到浏览器后处理任务 * * @param Request $request * @param Response $response * @return void */ public function terminate(Request $request, Response $response): void { //... } } terminate方法应该同时接收请求和响应。一旦定义了一个可终止的中间件，应该将它添加到app/Http/Kernel.php文件中的路由或全局中间件列表中。 当在中间件上调用terminate方法时，Laravel会从服务器容器解析一个新的中间件实例。如果想在调用handle和terminate方法时使用相同的中间件实例，可以使用容器的singleton方法向容器注册中间件。通常应该在项目的AppServiceProvider的register方法中完成 \u003c?php namespace App\\Providers; use App\\Http\\Middleware\\TerminatingMiddleware; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /** * Register any application services. */ public function register(): void { // $this-\u003eapp-\u003esingleton(TerminatingMiddleware::class); } ... } 控制器 控制器可以将相关的请求处理逻辑分组到一个类中。 例如：一个UserController类可能会处理所有与用户相关的传入请求，包括显示、创建、更新和删除用户。默认情况下，控制器存储在app/Http/Controller目录中。 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:9:8","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"编写控制器 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:10:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"基本控制器 可以使用make:controllerArtisan命令快速生成新控制器 php artisan make:controller UserController 默认情况下生成在app/Http/Controller目录中，可以通过指定路径子目录Api/UserController进行生成，这样生成后的目录在app/Http/Controller/Api目录下 php artisan make:controller Api/UserController 示例 \u003c?php namespace App\\Http\\Controllers\\Api; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; class UserController extends Controller { public function show(string $id): string { return 'User' . $id; } } 定义到控制器方法的路由： use App\\Http\\Controllers\\Api\\UserController; Route::get('/user/{id}', [UserController::class, 'show']); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:10:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"单动作控制器 如果控制器动作特别复杂，可能会发现将整个控制器专用于该单个动作很方便。为此，可以在控制器中定义一个__invoke方法。 可以使用make:controllerArtisan命令的--invokable选项生成可调用控制器 php artisan make:controller ProvisionServer --invokable 生成的控制器： \u003c?php namespace App\\Http\\Controllers\\Api; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; class ProvisionServer extends Controller { /** * Handle the incoming request. */ public function __invoke(Request $request): array { // return $request-\u003eall(); } } 为单动作控制器注册路由时，不需要指定控制器方法。可以简单地将控制器的名称传递给路由器： use App\\Http\\Controllers\\Api\\ProvisionServer; Route::get('/server', ProvisionServer::class); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:10:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"控制器中间件 中间件可以在路由文件中分配给控制器的路由： Route::get('/user/{id}', [UserController::class, 'show'])-\u003emiddleware('auth'); 也可以在控制器的构造函数中指定中间件。使用控制器构造函数中的middleware方法将中间件分配给控制器的操作： \u003c?php namespace App\\Http\\Controllers\\Api; use App\\Http\\Controllers\\Controller; use Closure; use Illuminate\\Http\\Request; class UserController extends Controller { public function __construct() { $this-\u003emiddleware('auth'); $this-\u003emiddleware('log')-\u003eonly('index'); $this-\u003emiddleware('subscribed')-\u003eexcept('store'); // 控制器还允许使用闭包注册中间件 $this-\u003emiddleware(function (Request $request, Closure $next) { return $next($request); }); } public function show(string $id): string { return 'User' . $id; } } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:11:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"资源控制器 如果将应用程序中的每个Eloquent模型都是为资源，那么通常对应用程序中的每个资源都执行相同的操作。 Laravel的资源路由通过单行代码即可将典型的增删改查(CURD)路由分配给控制器。首相，使用Artisan命令make:controller的--resource选项来快速创建一个控制器 \u003c?php namespace App\\Http\\Controllers\\Api; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; class PhotoController extends Controller { /** * Display a listing of the resource. */ public function index() { // } /** * Show the form for creating a new resource. */ public function create() { // } /** * Store a newly created resource in storage. */ public function store(Request $request) { // } /** * Display the specified resource. */ public function show(string $id) { // } /** * Show the form for editing the specified resource. */ public function edit(string $id) { // } /** * Update the specified resource in storage. */ public function update(Request $request, string $id) { // } /** * Remove the specified resource from storage. */ public function destroy(string $id) { // } } 给控制器注册一个资源路由： use App\\Http\\Controllers\\Api\\PhotoController; Route::resource('photos', PhotoController::class); 这个单一的路由声明创建了多个路由来处理资源上的各种行为，可以通过php artisan route:list来快速了解： ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"自定义缺失模型行为 通常如果未找到隐式绑定的资源模型，则会生成状态码为404的HTTP响应。但是可以通过在定义资源路由时调用missing的方法来自定义该行为。missing方法接受一个闭包，如果对任何资源的路由都找不到隐式绑定模型，则将调用该闭包： Route::resource('photos', PhotoController::class) -\u003emissing(function (Request $request) { return Redirect::route('photos.index'); }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"软删除模型 通常情况下，隐式模型绑定将不会检索已经进行了软删除的模型，并且会返回一个404HTTP响应。但是，可以在定义资源路由时调用withTrashed方法来告诉框架允许软删除的模型： use App\\Http\\Controllers\\Api\\PhotoController; Route::resource('photos', PhotoController::class)-\u003ewithTrashed(); 当不传递参数调用withTrashed时，将在show、edit 和 update资源路由中允许软删除的模型。可以通过一个数组指定这些路由的子集传递给withTrashed方法： Route::resource('photos', PhotoController::class) -\u003ewithTrashed(['show']); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"指定资源模型 如果使用了路由模型的绑定并且想在资源控制器的方法中使用类型提示，可以在生成控制器的时候使用--model选项： php artisan make:controller Api/PhotoController --model=Photo --resource ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:3","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"生成表单请求 可以在生成资源控制器时提供--requests选项来让Artisan位控制器的storage和update方法生成表单请求类： php artisan make:controller Api/PhotoController --model=Photo --resource --requests ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:4","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"部分资源路由 当声明资源路由时，可以指定控制器处理的部分行为，而不是所有默认的行为： use App\\Http\\Controllers\\Api\\PhotoController; Route::resource('photos', PhotoController::class) -\u003eonly(['index', 'show']); Route::resource('photos', PhotoController::class) -\u003eexcept(['create', 'store', 'update', 'destroy']); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:5","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"API资源路由 当声明用于API的资源路由时，通常需要排除显示HTML模板的路由，例如create和edit。为了方便，可以使用apiResource方法来排除这两个路由： use App\\Http\\Controllers\\Api\\PhotoController; Route::apiResource('photos', PhotoController::class); 也可以传递一个数组给apiResources方法来同时注册多个API资源控制器： Route::apiResources([ 'photos' =\u003e PhotoController::class, 'posts' =\u003e PostController::class, ]); 要快速生成API资源控制器，可以执行make:controller命令时使用--api参数： php artisan make:controller PhotoController --api ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:6","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"嵌套资源 有时可能需要定义一个嵌套的资源型路由。例如，一个photo资源可能被添加了多个comments。那么可以在路由中使用.符号来声明资源型控制器： use App\\Http\\Controllers\\Api\\PhotoController; Route::resource('photos.comments', PhotoController::class); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:7","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"浅层嵌套 通常，并不是在所有情况下都需要子啊URI中同时拥有父ID和子ID，因为子ID已经是唯一的标识符。当使用唯一标识符（如自动递增的主键）来表示URI中的模式时，可以选择使用「浅嵌套」的方式定义路由： use App\\Http\\Controllers\\Api\\PhotoController; Route::resource('photos.comments', PhotoController::class) -\u003eshallow(); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:8","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"命名资源路由 默认情况下，所有的资源控制器行为都有一个路由名称，可以传入names数组来覆盖这些名称： use App\\Http\\Controllers\\Api\\PhotoController; Route::resource('photos.comments', PhotoController::class) -\u003enames(['create' =\u003e 'photos.build']); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:9","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"命名资源路由参数 默认情况下，Route::resource会根据资源名称的单数形式创建资源路由的路由参数。可以使用parameters方法来轻松地覆盖资源路由名称。传入parameters方法应该是自愿名称和参数名称的关联数组： use App\\Http\\Controllers\\Api\\PhotoController; Route::resource('photos', PhotoController::class) -\u003eparameters(['photos' =\u003e 'photo_id']); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:10","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"限定范围的资源路由 Laravel的作用域隐式模型绑定功能可以自动确定嵌套绑定的范围，以便确认已解析的子模型属于父模型。通过在定义嵌套资源时使用scoped方法，可以启用自动范围界定，并指示Laravel应该通过以下方式来检索子资源的哪个字段： use App\\Http\\Controllers\\Api\\PhotoController; Route::resource('photos.comments', PhotoController::class) -\u003escoped(['comment' =\u003e 'slug']); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:11","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"本地化资源URIs 默认情况下，Route::resource将会用英文动词创建资源URIs。如果需要自定义create和edit行为的动词，可以在App\\Providers\\RouteServiceProvider 的 boot 方法中使用 Route::resourceVerbs 方法实现： public function boot(): void { ... Route::resourceVerbs([ 'create' =\u003e 'crear', 'edit' =\u003e 'editar', ]); ... } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:12","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"补充资源控制器 如果需要向资源控制器添加超出默认资源路由集的其他路由，则应在调用Route::resource方法之前定义这些路由；否则，由resource方法定义的路由可能会无意中优先于补充路由： use App\\Http\\Controllers\\Api\\PhotoController; Route::get('/photos/popular', [PhotoController::class, 'popular']); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:13","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"单例资源控制器 有时候，应用中的资源可能只有一个实例，这种情况下，可以注册成单例（signleton）资源控制器： use App\\Http\\Controllers\\Api\\PhotoController; Route::singleton('photos', PhotoController::class); 单例资源中create路由没有被注册；并且注册的路由不接受路由参数，因为该资源中只有一个实例存在： 单例资源也可以在标准资源内嵌套使用： Route::singleton('photos.comments', PhotoController::class); 上例中，photo资源将接收所有的标准资源路由；不过comments资源将会是个单例资源，它的路由如下所示： Creatable单例资源 有时，可能需要为单例资源定义create和storage路由。要实现这一功能，可以在注册单例资源路由时，调用creatable方法： Route::singleton('photos.comments', PhotoController::class) -\u003ecreatable(); 如果希望Laravel为单个资源注册DETELE路由，但不注册创建或存储路由，则可以使用destroyable方法： Route::singleton('photos.comments', PhotoController::class) -\u003edestroyable(); API单例资源 apiSingleton方法可用于注册将通过API操作的单例资源，从而不需要create和edit路由： Route::apiSingleton('photos', PhotoController::class); API单例资源也可以时creatable，它将注册store和destroy资源路由： Route::apiSingleton('photos', PhotoController::class) -\u003ecreatable(); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:12:14","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"依赖注入和控制器 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:13:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"构造函数注入 Laravel服务容器用于解析所有Laravel控制器。因此，可以在其构造函数中对控制器可能需要的任何依赖项进行类型提示。声明的依赖项将自动解析并注入到控制器实例中： \u003c?php namespace App\\Http\\Controllers; use App\\Repositories\\UserRepository; class UserController extends Controller { /** * 创建新控制器实例。 */ public function __construct( protected UserRepository $users, ) {} } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:13:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"方法注入 方法注入的一个常见用例时将Illuminate\\Http\\Request实例注入到控制器方法中： \u003c?php namespace App\\Http\\Controllers\\Api; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; class UserController extends Controller { public function __construct(Request $request) { $name = $request-\u003ename; // ... return redirect('/users'); } } 如果控制器方法也需要路由参数，那就在其他依赖项之后列出路由参数即可： use App\\Http\\Controllers\\UserController; Route::put('/user/{id}', [UserController::class, 'update']); \u003c?php namespace App\\Http\\Controllers; use Illuminate\\Http\\RedirectResponse; use Illuminate\\Http\\Request; class UserController extends Controller { /** * 更新给定用户。 */ public function update(Request $request, string $id): RedirectResponse { // 更新用户。。。 return redirect('/users'); } } HTTP请求 Laravel的Illuminate\\Http\\Request类提供了一种面向对象的方式来与当前由应用程序处理的HTTP请求进行交互，并检索提交请求的输入内容、Cookie和文件。 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:13:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"与请求交互 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:14:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"访问请求 要通过依赖注入获取当前的HTTP请求实例，应该在路由闭包或控制器方法中导入Illuminate\\Http\\Request类。传入的请求实例将由Laravel服务容器自动注入： \u003c?php namespace App\\Http\\Controllers\\Api; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; class UserController extends Controller { public function __construct(Request $request) { $name = $request-\u003ename; // ... return redirect('/users'); } public function show(string $id): string { return 'User' . $id; } } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:14:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"请求路径、主机和方法 Illuminate\\Http\\Request实例提供各种方法来检查传入的HTTP请求，并扩展了Symfony\\Component\\HttpFoundation\\Request类。 获取请求路径 path方法返回请求的路径信息。 // 访问：http://127.0.0.1:8000/api/user/1 $uri = $request-\u003epath(); // api/user/1 检查请求路径/路由信息 is方法允许验证传入请求路径是否与给定的模式匹配。当使用此方法时，可以使用*字符作为通配符： if ($request-\u003eis('admin/*')) { // ... } 使用routeIs方法，可以确定传入的请求是否与命名路由匹配： if ($request-\u003erouteIs('admin.*')) { // ... } 获取请求URL 要获取传入请求的完整URL，可以使用url或fullUrl方法。 url方法将返回不带查询字符串的URL，而fullUrl方法将包括查询字符串： // 访问：http://127.0.0.1:8000/api/user/1?type=2 $url = $request-\u003eurl(); // http://127.0.0.1:8000/api/user/1 $urlWithQueryString = $request-\u003efullUrl(); // http://127.0.0.1:8000/api/user/1?type=2 如果想将查询字符串数据附加到当前URL，请调用fullUrlWithQuery方法。此方法将给定的查询字符串变量数组与当前查询字符串合并： $request-\u003efullUrlWithQuery(['phone' =\u003e '11111']); 获取请求Host Route::get('/getHost', function (Request $request) { $host = $request-\u003ehost(); $httpHost = $request-\u003ehttpHost(); $schemeAndHttpHost = $request-\u003eschemeAndHttpHost(); return ['host' =\u003e $host, 'httpHost' =\u003e $httpHost, 'schemeAndHttpHost' =\u003e $schemeAndHttpHost]; }); // { // \"host\": \"127.0.0.1\", // \"httpHost\": \"127.0.0.1:8000\", // \"schemeAndHttpHost\": \"http://127.0.0.1:8000\" // } 获取请求方法 method方法将返回请求的HTTP动词，可以使用isMethod方法来验证HTTP动词是否与给定的字符串匹配： $method = $request-\u003emethod(); if ($request-\u003eisMethod('post')) { // ... } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:14:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"请求头 使用header方法从Illuminate\\Http\\Request实例中检索请求标头。如果请求中没有标头，则返回null。header方法接受两个可选参数，如果该标头在请求中不存在，则返回第二个参数： $header = $request-\u003eheader('X-Header-Name'); // null $header = $request-\u003eheader('X-Header-Name', 'default'); // default hasHeader方法可用于确定请求是否包含给定的标头： if ($request-\u003ehasHeader('X-Header-Name')) { // ... } bearerToken方法可用于从Authorization标头检索授权标记。如果不存在此类标头，将返回一个空字符串： $bearerToken = $request-\u003ebearerToken(); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:14:3","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"请求IP地址 ip方法可用于检索应用程序发出请求的客户端的IP地址： $ip = $request-\u003eip(); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:14:4","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"内容协商 Laravel提供了几种方法，通过Accept标头检查传入请求的请求内容类型。首先，getAcceptableContentTypes方法将返回包含请求接受的所有内容类型的数组： $acceptableContentTypes = $request-\u003egetAcceptableContentTypes(); // [ // \"text/html\", // \"application/xhtml+xml\", // \"image/avif\", // \"image/webp\", // \"image/apng\", // \"application/xml\", // \"*/*\", // \"application/signed-exchange\" // ] accepts方法接收一个内容类型数组，并在请求接受任何内容类型时返回true。否则将返回false： if ($request-\u003eaccepts(['text/html', 'application/json'])) { // ... } prefers方法确定给定内容类型数组中的哪种内容类型由请求最具优势。如果请求未接受任何提供的内容类型，则返回null： $prefers = $request-\u003eprefers(['text/html', 'application/json']); // text/html 由于许多应用程序仅提供HTML或JSON，因此可以使用expectsJson方法快速确定传入请求是否期望获得JSON响应： if ($request-\u003eexpectsJson()){ // ... } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:14:5","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"PSR-7请求 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:14:6","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"输入 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:15:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"检索输入 检索所有输入数据 使用all方法将所有传入请求的输入数据作为array检索。无论传入请求是否来自于HTML表单或XHR请求： $all = $request-\u003eall(); 使用collect方法，可以将所有传入请求的输入数据作为集合检索： $collection = $request-\u003ecollect(); collect方法还允许将传入请求的子集作为集合检索： $request-\u003ecollect('users')-\u003eeach(function (string $user) { // ... }); 检索输入值 input方法可用于检索用户输入： $name = $request-\u003einput('name'); 可以将默认值作为第二个参数传递给input方法。如果请求中不存在所请求的输入值，则返回此值： $name = $request-\u003einput('name', 'desire'); 处理包含数组输入的表单时，使用.符号访问数组： $name = $request-\u003einput('products.0.name'); $names = $request-\u003einput('products.*.name'); 如果不带任何参数的input方法，以将所有输入值作为关联数组检索出来： $input = $request-\u003einput(); 从查询字符串检索输入 query方法仅从查询字符串检索值 $queryName = $request-\u003equery('name'); 如果请求的查询字符串值数据不存在，则将返回此方法的第二个参数： $queryName = $request-\u003equery('name', 'Desire'); 如果调用不带任何参数的query方法，以将所有查询字符串值作为关联数组检索出来： $query = $request-\u003equery(); 检索可字符串化的输入值 可以使用string方法将请求的输入数据检索为Illuminate\\Http\\Request的实例，而不是将其作为基本string检索： $stringAble = $request-\u003estring('name')-\u003etrim(); 检索布尔值输入 可以使用boolean方法进行布尔值检索。 对于 1，「1」，true，「true」，「on」和「yes」，返回 true。所有其他值将返回 false： $archived = $request-\u003eboolean('archived'); 检索日期输入值 包含日期/时间的输入值可以使用date方法检索为Carbon实例。如果请求中不包含给定名称的输入值，则返回null： $birthday = $request-\u003edate('birthday'); date方法可接受的第二个和第三个参数可用于分别指定日期的格式和时区： $elapsed = $request-\u003edate('elapsed', '!H:i', 'Europe/Madrid'); 如果输入值存在但格式无效，则会抛出一个InvalidArgumentException异常；因此，在调用date方法之前建议对输入进行验证。 检索枚举输入值 enum方法接受输入值的名称和枚举类作为其第一个和第二个参数。 如果请求中不包含给定名称的输入值或枚举没有与输入值匹配的备份值，则返回null use App\\Enums\\Status; $status = $request-\u003eenum('status', Status::class); 通过动态属性检索输入 可以使用Illuminate\\Http\\Request实例上的动态属性访问用户输入： $name = $request-\u003ename; 使用动态属性时，Laravel首先会在请求负载中查找参数的值，如果不存在，则会在匹配路由的参数中搜索该字段。 检索输入数据的一部分 如果需要检索输入数据的子集，则可以使用only和except方法。这两个方法都接受一个单一的array或动态参数列表： $only = $request-\u003eonly(['username', 'password']); $only1 = $request-\u003eonly('username', 'password'); $except = $request-\u003eexcept(['credit_card']); $except1 = $request-\u003eexcept('credit_card'); 注：only方法返回请求的所有键值对；但是，不会返回请求中不存在的键值对。 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:15:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"判断输入是否存在 可以使用has方法来确定请求中是否存在某个值。如果请求中存在该值则返回true： if ($request-\u003ehas('name')) { // ... } 当给定一个数组时，has方法将确定所有指定的值是否都存在： if ($request-\u003ehas(['name', 'email'])) { // ... } whenHas方法将在请求中存在一个值时执行给定的闭包： $request-\u003ewhenHas('name', function (string $input) { // ... }); 可以通过向whenHas方法传递第二个闭包来执行在请求中没有指定值的情况： $request-\u003ewhenHas('name', function (string $input) { // \"name\" 值存在... }, function () { // \"name\" 值不存在... }); hasAny方法放回true，如果任意指定的值存在，则返回true： if ($request-\u003ehasAny(['name', 'email'])) { // ... } 如果想要确定请求中是否存在一个值且不是一个空字符串，则可以使用fulled方法： if ($request-\u003efilled('name')) { // ... } whenFilled方法将请求中存在一个值且不是空字符串时执行给定的闭包： $request-\u003ewhenFilled('name', function (string $input) { // ... }); 可以通过向whenFilled方法传递第二个闭包来执行在请求中没有指定值的情况： $request-\u003ewhenFilled('name', function (string $input) { // \"name\" 值已填写... }, function () { // \"name\" 值未填写... }); 要确定给定的键是否不存在请求中，可以使用missing和whenMissing方法： if ($request-\u003emissing('name')) { // ... } $request-\u003ewhenMissing('name', function (array $input) { // \"name\" 值缺失... }, function () { // \"name\" 值存在... }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:15:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"合并其他输入 可以使用merge方法，手动将其他输入合并到请求的向右输入数据中。如果给定的输入键已经存在于请求中，它将被提供给merge方法的数据覆盖： $request-\u003emerge(['votes' =\u003e 0]); 如果请求的输入数据中不存在相应的键，则可以使用mergeIfMissing方法将输入合并到请求中： $request-\u003emergeIfMissing(['votes' =\u003e 0]); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:15:3","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"旧输入 Laravel允许在两次请求之间保留数据。这个特性在检测到验证错误后重新填充表单时特别有用。但是，如果使用Laravel的包含的表单验证，不需要自己手动调用这些方法，因为Laravel的一些内置验证功能将自动调用它们。 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:15:4","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"闪存 闪存输入到Session 在Illuminate\\Http\\Request类上的flash方法将当前输入闪存到session，以便在下一次用户请求应用程序时使用： $request-\u003eflash(); 还可以使用flashOnly和flashExcept方法闪存一部分请求数据到Session。这些方法对于将敏感信息（如密码）排除在Session外的情况下非常有用： $request-\u003eflashOnly(['username', 'email']); $request-\u003eflashExcept('password'); 闪存输入后重定向 可以使用withInput方法将输入闪存到重定向中： return redirect('form')-\u003ewithInput(); return redirect()-\u003eroute('user.create')-\u003ewithInput(); return redirect('form')-\u003ewithInput( $request-\u003eexcept('password') ); 检索旧输入值 若要获取上一次请求所保存的就输入数据，可以在Illuminate\\Http\\Request的实例上调用old方法，old方法会从session中检索先前闪存的输入数据： $username = $request-\u003eold('username'); 此外，Laravel还提供了一个全局辅助函数old。如果在Blade模板中显示旧的输入，则更方便使用old辅助函数重新填充表单。如果给定字段没有就输入，则会返回null： \u003cinput type=\"text\" name=\"username\" value=\"{{ old('username') }}\"\u003e ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:15:5","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"Cookies 检索请求中的Cookies Laravel框架创建的所有cookies都经过加密并签名，这意味着如果客户端更改了cookie值，则这些cookie将被视为无效。要从请求中检索cookie值，在Illuminate\\Http\\Request实例上使用cookie方法： $cookie = $request-\u003ecookie('name'); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:15:6","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"输入过滤和规范化 默认情况下，Laravel在应用程序的全局中间件中包含App\\Http\\Middleware\\TrimStrings和Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull中间件。这些中间件在App\\Http\\Kernel类的全局中间件中列出。这些中间件将自动修剪请求中的字符串字段，并将任何空字符串转换为null。 禁用输入规范化 如果要禁用所有请求的该行为，可以从 App\\Http\\Kernel 类的 $middleware 属性中删除这两个中间件，从而将它们从应用程序的中间件栈中删除。 如果想要禁用应用程序的一部分请求的字符串修剪和空字符串转换，可以使用中间件提供的 skipWhen 方法。该方法接受一个闭包，该闭包应返回 true 或 false，以指示是否应跳过输入规范化。通常情况下，需要在应用程序的 AppServiceProvider 的 boot 方法中调用 skipWhen 方法。 use App\\Http\\Middleware\\TrimStrings; use Illuminate\\Http\\Request; use Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull; /** * Bootstrap any application services. */ public function boot(): void { TrimStrings::skipWhen(function (Request $request) { return $request-\u003eis('admin/*'); }); ConvertEmptyStringsToNull::skipWhen(function (Request $request) { // ... }); } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:16:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"文件 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:17:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"检索上传的文件 可以使用file方法或动态属性从Illuminate\\Http\\Request实例中检索已上传的文件。file方法返回Illuminate\\Http\\UploadedFile类的实例，该类扩展了PHP的SplFileInfo类，并提供了各种用于与文件交互的方法： $file = $request-\u003efile('photo'); $file = $request-\u003ephoto; 可以使用hasFile方法检查请求中是否存在文件： if ($request-\u003ehasFile('photo')) { // ... } 验证成功上传的文件 除了检查文件是否存在之外，还可以通过isValid方法验证上传文件时是否存在问题： if ($request-\u003efile('photo')-\u003eisValid()) { // ... } 文件路径和扩展名 UploadedFile 类还包含访问文件的完全限定路径及其扩展名的方法。extension 方法将尝试基于其内容猜测文件的扩展名。此扩展名可能与客户端提供的扩展名不同： $path = $request-\u003ephoto-\u003epath(); $extension = $request-\u003ephoto-\u003eextension(); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:17:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"存储上传的文件 要存储已上传的文件，通常会使用您配置的一个文件系统 。UploadedFile 类具有一个 store 方法，该方法将上传的文件移动到您的磁盘中的一个位置，该位置可以是本地文件系统上的位置，也可以是像 Amazon S3 这样的云存储位置。 store 方法接受存储文件的路径，该路径相对于文件系统的配置根目录。此路径不应包含文件名，因为将自动生成唯一的 ID 作为文件名。 store 方法还接受一个可选的第二个参数，用于指定应用于存储文件的磁盘的名称。该方法将返回相对于磁盘根目录的文件路径： $path = $request-\u003ephoto-\u003estore('images'); $path = $request-\u003ephoto-\u003estore('images', 's3'); 如果不希望自动生成文件名，则可以使用storeAs方法，该方法接受路径、文件名和磁盘名称作为其参数： $path = $request-\u003ephoto-\u003estoreAs('images', 'filename.jpg'); $path = $request-\u003ephoto-\u003estoreAs('images', 'filename.jpg', 's3'); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:17:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"配置受信任的代理 使用 App\\Http\\Middleware\\TrustProxies 中间件，这个中间件已经包含在 Laravel 应用程序中，它允许快速定制应用程序应信任的负载均衡器或代理。信任的代理应该被列在此中间件的 $proxies 属性上的数组中。除了配置受信任的代理之外，还可以配置应该信任的代理 $headers： \u003c?php namespace App\\Http\\Middleware; use Illuminate\\Http\\Middleware\\TrustProxies as Middleware; use Illuminate\\Http\\Request; class TrustProxies extends Middleware { /** * 此应用程序的受信任代理。 * * @var string|array */ protected $proxies = [ '192.168.1.1', '192.168.1.2', ]; /** * 应用于检测代理的标头。 * * @var int */ protected $headers = Request::HEADER_X_FORWARDED_FOR | Request::HEADER_X_FORWARDED_HOST | Request::HEADER_X_FORWARDED_PORT | Request::HEADER_X_FORWARDED_PROTO; } 注意 如果正在使用 AWS 弹性负载平衡，请将 $headers 值设置为 Request::HEADER_X_FORWARDED_AWS_ELB 信任所有代理 /** * 应用所信任的代理。 * * @var string|array */ protected $proxies = '*'; ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:18:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"配置可信任的Host 默认情况下，Laravel 将响应它接收到的所有请求，而不管 HTTP 请求的 Host 标头的内容是什么。此外，在 web 请求期间生成应用程序的绝对 URL 时，将使用 Host 头的值。 通常情况下，应该配置 Web 服务器（如 Nginx 或 Apache）仅向匹配给定主机名的应用程序发送请求。然而，如果没有直接自定义 Web 服务器的能力，需要指示 Laravel 仅响应特定主机名的请求，可以为应用程序启用 App\\Http\\Middleware\\TrustHosts 中间件。 TrustHosts 中间件已经包含在应用程序的 $middleware 堆栈中；但是，应该将其取消注释以使其生效。在此中间件的 hosts 方法中，可以指定应用程序应该响应的主机名。具有其他 Host 值标头的传入请求将被拒绝： /** * 获取应被信任的主机模式。 * * @return array\u003cint, string\u003e */ public function hosts(): array { return [ 'laravel.test', $this-\u003eallSubdomainsOfApplicationUrl(), ]; } allSubdomainsOfApplicationUrl 帮助程序方法将返回与应用程序app.url配置值的所有子域相匹配的正则表达式。在构建利用通配符子域的应用程序时，这个帮助程序提供了一种方便的方法来允许所有应用程序的子域。 响应 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:19:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"创建响应 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:20:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"字符串 \u0026 数组 最基本就是从路由或控制器返回一个简单的字符串，框架会自动将这个字符串转化为一个完整的HTTP响应： Route::get('/', function () { return 'Hello PHP!'; }); 也可以返回数组，框架会自动将数组转换为JSON响应： Route::get('/', function () { return [1, 3, 4]; }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:20:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"Response对象 返回一个完整的Illuminate\\Http\\Response实力允许自定义返回的HTTP状态码和返回头信息。Response实例继承自Symfony\\Component\\HttpFoundation\\Response类，此类提供了各种构建HTTP响应的方法： Route::get('/home', function () { return response('Hello PHP!', 200) -\u003eheader('Content-Type', 'text/plain'); }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:20:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"Eloquent模型和集合 可以直接从路由和控制器返回 Eloquent ORM 模型和集合。这样做时，Laravel 将自动将模型和集合转换为 JSON 响应，同时遵循模型的 隐藏属性: use App\\Models\\User; Route::get('/user/{user}', function (User $user) { return $user; }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:20:3","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"添加响应头 可以使用header方法将一系列头添加到响应中： return response($content) -\u003eheader('Content-Type', $type) -\u003eheader('X-Header-One', 'Header Value') -\u003eheader('X-Header-Two', 'Header Value'); 也可以使用withHeaders方法指定要添加到响应的标头数组： return response($content) -\u003ewithHeaders([ 'Content-Type' =\u003e $type, 'X-Header-One' =\u003e 'Header Value', 'X-Header-Two' =\u003e 'Header Value', ]); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:20:4","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"缓存控制中间件 Laravel包含一个cache.headers中间件，可用于快速设置一组路由的CaChe-Control标头。指令应使用相应缓存控制指定的蛇形命名法等效项提供，并应以分号分割。如果在指令列表中指定了etag，则响应内容的MD5哈希将自动设置为ETag标识符： Route::middleware('cache.headers:public;max_age=2628000;etag')-\u003egroup(function () { Route::get('/privacy', function () { // ... }); Route::get('/terms', function () { // ... }); }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:20:5","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"添加响应Cookies 可以使用cookie方法将cookie附加到传出的Illumize\\Http\\Response实例，应将cookie的名称、值和有效分钟数传递给此方法： return response('Hello World')-\u003ecookie( 'name', 'value', $minutes ); cookie方法还接受一些使用频率较低的参数。通常，这些参数的目的和意义与PHP原生setcookie的参数相同 return response('Hello World')-\u003ecookie( 'name', 'value', $minutes, $path, $domain, $secure, $httpOnly ); 如果希望确保cookie与传出响应一起发送，但还没有该响应的实例，则可以使用Cookiefacade将cookie加入队列，以便在发送响应时附加到响应中。queue方法接受创建cookie实例所需的参数。在发送到浏览器之前，这些cookies将附加到传出的响应中： use Illuminate\\Support\\Facades\\Cookie; Cookie::queue('name', 'value', $minutes); 生成Cookie实例 如果要生成一个Symfony\\Component\\HttpFoundation\\Cookie实例，打算稍后附加到响应实例中。可以使用全局cookie助手函数。此cookie将不会发送回客户端，除非它被附加到响应实例中： $cookie = cookie('name', 'value', $minutes); return response('Hello PHP')-\u003ecookie($cookie) 提前过期Cookies 可以通过响应中的withoutCookie方法使Cookie过期，用于删除Cookie： return response('Hello PHP')-\u003ewithoutCookie('name'); 如果尚未有创建响应的实例，则可以使用Cookiefacade中的expire方法使Cookie过期： Cookie::expire('name'); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:20:6","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"Cookies \u0026 加密 默认情况下，由 Laravel 生成的所有 cookie 都经过了加密和签名，因此客户端无法篡改或读取它们。如果要对应用程序生成的部分 cookie 禁用加密，可以使用 App\\Http\\Middleware\\EncryptCookies 中间件的 $except 属性，该属性位于 App/Http/Middleware 目录中： \u003c?php namespace App\\Http\\Middleware; use Illuminate\\Cookie\\Middleware\\EncryptCookies as Middleware; class EncryptCookies extends Middleware { /** * The names of the cookies that should not be encrypted. * * @var array\u003cint, string\u003e */ protected $except = [ // 'cookie_name', ]; } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:20:7","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"重定向 重定向响应是 Illuminate\\Http\\RedirectResponse 类的实例，包含将用户重定向到另一个 URL 所需的适当 HTTP 头。Laravel 有几种方法可以生成 RedirectResponse 实例。最简单的方法是使用全局 redirect 助手函数： Route::get('/dashboard', function () { return redirect('home/dashboard') }); 有时可能希望将用户重定向到以前的位置，例如当提交的表单无效时，可以使用全局back助手函数来执行操作。由于此功能使用session，请确保调用back函数的路由使用的是web中间件组： Route::post('/user/profile', function () { // 验证请求参数 return back()-\u003ewithInput(); }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:21:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"重定向到指定名称的路由 当在没有传递参数的情况下调用redirect助手函数时，将返回Illuminate\\Routing\\Redirector的实例，允许调用Redirector实例上的任何方法。例如，要对命名路由生成RedirectResponse，可以使用route方法： return redirect()-\u003eroute('login'); 如果路由中有参数，可以将其作为第二个参数传递给route方法： // 对于具有以下URI的路由: /profile/{id} return redirect()-\u003eroute('profile', ['id' =\u003e 1]); 通过Eloquent模型填充参数 如果要重定向到使用从Eloquent模型田中ID参数的路由，可以直接传递模型本身。ID将会被自动提取： // 对于具有以下URI的路由: /profile/{id} return redirect()-\u003eroute('profile', [$user]); 如果想要自定义路由参数，可以指定路由参数(/profile/{id:slug})或者重写Eloquent模型上getRouteKey方法： /** * 获取模型的路由键值。 */ public function getRouteKey(): mixed { return $this-\u003eslug; } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:21:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"重定向到控制器方法 也可以生成重定向到controller actions。只要把控制器和action的名称传递给action方法： use App\\Http\\Controllers\\UserController; return redirect()-\u003eaction([UserController::class, 'index']); 如果控制器路由有参数，可以将其作为第二个参数传递给action方法： return redirect()-\u003eaction( [UserController::class, 'profile'], ['id' =\u003e 1] ); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:21:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"重定向到外部域名 有时候需要重定向到应用外的域名。可以通过调用away方法，它会创建一个不带有任何额外的URL编码、有效性校验和检查RedirectResponse实例： return redirect()-\u003eaway('https://www.google.com'); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:21:3","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"重定向并使用闪存的Session数据 重定向到新的URL的同时传递数据给session是很常见的。通常在将消息发送给session后成功执行操作后完成的。为了方便，可以创建一个RedirectResponse实例并在链式方法调用中将数据传递给session： Route::post('/user/profile', function () { // ... return redirect('dashboard')-\u003ewith('status', 'Profile updated!'); }); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:21:4","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"其他响应类型 response助手可以用于生成其他类型的响应实例。当不带参数调用response助手时，会返回Illuminate\\Contracts\\Routing\\ResponseFactorycontract的实现。该契约提供了几种有用的方法来生成响应。 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:22:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"视图响应 return response() -\u003eview('hello', $data, 200) -\u003eheader('Content-Type', $type); 如果不需要传递自定义HTTP状态代码或自定义标头，则可以使用全局view辅助函数。 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:22:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"JSON响应 json方法会自动将Content-Type表头设置为application/json，并使用json_encodePHP函数将给定的数组转换为JSON： return response()-\u003ejson([ 'name' =\u003e 'Abigail', 'state' =\u003e 'CA', ]); 如果想创建一个JSONP响应，可以结合使用json方法和withCallback方法： return response() -\u003ejson(['name' =\u003e 'Abigail', 'state' =\u003e 'CA']) -\u003ewithCallback($request-\u003einput('callback')); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:22:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"文件下载 download方法可用于生成强制用户浏览器在给定路径下载文件的响应。download方法接受文件名作为该方法的第二个参数，这将确定下载文件的用户看到的文件名。最后，可以将一组HTTP标头作为该方法的第三个参数传递： return response()-\u003edownload($pathToFile); return response()-\u003edownload($pathToFile, $name, $headers); 流式下载 有时候可能希望将给定操作的字符串响应转换为可下载的响应，而不必将操作的内容写入磁盘。在这种情况下，可以使用streamDownload方法。此方法接受回调、文件名和可选的标头数组作为其参数： use App\\Services\\GitHub; return response()-\u003estreamDownload(function () { echo GitHub::api('repo') -\u003econtents() -\u003ereadme('laravel', 'laravel')['contents']; }, 'laravel-readme.md'); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:22:3","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"文件响应 file方法可用于直接在用户的浏览器中显示文件，例如图像或PDF，而不是启动下载。这个方法接受文件的路径作为它的第一个参数和一个标头数组作为它的第二个参数： return response()-\u003efile($pathToFile); return response()-\u003efile($pathToFile, $headers); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:22:4","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"响应宏 如果想定义一个可以在各种路由和控制器中重复使用的自定义响应，可以使用Responsefacade上的macro方法。通常，应用从应用程序的服务提供者，如App\\Providers\\AppServiceProvider服务提供程序的boot方法调用此方法： \u003c?php namespace App\\Providers; use Illuminate\\Support\\Facades\\Response; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /** * 启动一个应用的服务 */ public function boot(): void { Response::macro('caps', function (string $value) { return Response::make(strtoupper($value)); }); } } macro函数接受名称作为其第一个参数，并接受闭包作为其第二个参数。当从ResponseFactory实现或response助手函数调用宏名称时，将执行宏的闭包： return response()-\u003ecaps('foo'); 会话 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:23:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"简介 由于HTTP驱动的应用程序是无状态的，Session提供了一种在多个请求之间存储有关用户信息的方法，这类信息一般都存储在后续请求可以访问的持久存储/后端中。 Laravel通过同一个可读性强的API处理各种自带的后台驱动程序。支持诸如比较热门的Memcached、Redis和数据库。 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:24:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"配置 Session的配置文件存储在config/session.php文件中。默认情况下，Laravle为绝大多数应用程序配置的Session驱动为file驱动，它适用于大多数程序。如果应用程序需要再多个web服务器之间进行负载平衡，应该选择一个所有服务器都可以访问的几种式存储，例如Redis或数据库。 Sessiondriver的配置预设了每个请求存储Session数据的位置。Laravel自带了几个不错而且开箱即用的驱动： file：Session存储在storage/framework/sessions cookie：Session存储在安全加密的cookie中 database：Session储存在关系型数据库中 memcached/redis：Session存储在基于高速缓存的存储系统中 dynamodb：Session存储在AWS DynamoDB中 array：Session存储在PHP数组中，不会被初九话 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:24:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"驱动先决条件 数据库 使用databaseSession驱动时，需要创建一个记录Session的表。下面是Schema的声明示例： use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; Schema::create('sessions', function (Blueprint $table) { $table-\u003estring('id')-\u003eprimary(); $table-\u003eforeignId('user_id')-\u003enullable()-\u003eindex(); $table-\u003estring('ip_address', 45)-\u003enullable(); $table-\u003etext('user_agent')-\u003enullable(); $table-\u003etext('payload'); $table-\u003einteger('last_activity')-\u003eindex(); }); 可以使用Artisan命令session:table生成这个迁移 php artisan session:table php artisan migrate Redis 在Laravel使用Redis Session驱动前，需要安装PhpReis PHP扩展，可以通过PECL/Composer安装predis/predis包。 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:24:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"使用Session ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:25:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"获取数据 在 Laravel 中有两种基本的 Session 使用方式：全局 session 助手函数和通过 Request 实例。首先看下通过 Request 实例访问 Session , 它可以隐式绑定路由闭包或者控制器方法。记住，Laravel 会自动注入控制器方法的依赖。 \u003c?php namespace App\\Http\\Controllers; use App\\Http\\Controllers\\Controller; use Illuminate\\Http\\Request; use Illuminate\\View\\View; class UserController extends Controller { /** * 显示指定用户个人资料。 */ public function show(Request $request, string $id): View { $value = $request-\u003esession()-\u003eget('key'); // ... $user = $this-\u003eusers-\u003efind($id); return view('user.profile', ['user' =\u003e $user]); } } 当从Session获取数据时，也可以在get方法第二个参数里传递一个default默认值，如果Session里不存在键值对key的数据结果，这个默认值就会返回。如果传递给get方法一个闭包作为默认值，这个闭包会被执行并且返回结果： $value = $request-\u003esession()-\u003eget('key', 'default'); $value = $request-\u003esession()-\u003eget('key', function () { return 'default'; }); 全局Session助手函数 可以在Session里使用PHP全局session函数获取和存储数据。当这个session函数以一个单独的字符串形式被调用时，它将返回这个Session键值对的结果。当函数以key-value数组形式被调用时，这些值会被存储在Session中： Route::get('/home', function () { // 从 Session 获取数据 ... $value = session('key'); // 设置默认值... $value = session('key', 'default'); // 在Session 里存储一段数据 ... session(['key' =\u003e 'value']); }); 获取所有Session数据 可以使用all方法从Session里获取所有数据： $data = $request-\u003esession()-\u003eall(); 判断Session里是否存在条目 可以使用has方法。如果条目存在返回true，否则返回null： if ($request-\u003esession()-\u003ehas('users')) { // ... } 判断 Session 里是否存在一个即使结果值为 null 的条目，可以使用 exists 方法： if ($request-\u003esession()-\u003eexists('users')) { // ... } 要确定某个条目是否在会话中不存在，可以使用 missing 方法。如果条目不存在，missing 方法返回 true： if ($request-\u003esession()-\u003emissing('users')) { // ... } ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:25:1","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"存储数据 Session 里存储数据，通常将使用 Request 实例中的 put 方法或者 session 助手函数： // 通过 Request 实例存储 ... $request-\u003esession()-\u003eput('key', 'value'); // 通过全局 Session 助手函数存储 ... session(['key' =\u003e 'value']); Session存储数组 push 方法可以把一个新值推入到以数组形式存储的 session 值里。例如：如果 user.teams 键值对有一个关于团队名字的数组，可以推入一个新值到这个数组里： $request-\u003esession()-\u003epush('user.teams', 'developers'); 获取\u0026删除条目 pull 方法会从 Session 里获取并且删除一个条目： $value = $request-\u003esession()-\u003epull('key', 'default'); 递增、递减会话值 如果 Session 数据里有整形希望进行加减操作，可以使用 increment 和 decrement 方法： $request-\u003esession()-\u003eincrement('count'); $request-\u003esession()-\u003eincrement('count', $incrementBy = 2); $request-\u003esession()-\u003edecrement('count'); $request-\u003esession()-\u003edecrement('count', $decrementBy = 2); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:25:2","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"闪存数据 有时可能想在 Session 里为下次请求存储一些条目。可以使用 flash 方法。使用这个方法，存储在 Session 的数据将立即可用并且会保留到下一个 HTTP 请求期间，之后会被删除。闪存数据主要用于短期的状态消息： $request-\u003esession()-\u003eflash('status', 'Task was successful!'); 如果需要为多次请求持久化闪存数据，可以使用 reflash 方法，它会为一个额外的请求保持住所有的闪存数据，如果仅需要保持特定的闪存数据，可以使用 keep 方法： $request-\u003esession()-\u003ereflash(); $request-\u003esession()-\u003ekeep(['username', 'email']); 如果仅为了当前的请求持久化闪存数据，可以使用 now 方法： $request-\u003esession()-\u003enow('status', 'Task was successful!'); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:25:3","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"删除数据 forget 方法会从 Session 删除一些数据。如果想删除所有 Session 数据，可以使用 flush 方法： // 删除一个单独的键值对 ... $request-\u003esession()-\u003eforget('name'); // 删除多个 键值对 ... $request-\u003esession()-\u003eforget(['name', 'status']); $request-\u003esession()-\u003eflush(); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:25:4","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"重新生成SessionID 重新生成 Session ID 经常被用来阻止恶意用户使用 session fixation 攻击你的应用。 如果正在使用入门套件或 Laravel Fortify 中的任意一种， Laravel 会在认证阶段自动生成 Session ID；然而如果需要手动重新生成 Session ID ，可以使用 regenerate 方法： $request-\u003esession()-\u003eregenerate(); 如果需要重新生成 Session ID 并同时删除所有 Session 里的数据，可以使用 invalidate 方法： $request-\u003esession()-\u003einvalidate(); ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:25:5","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"Session阻塞 默认情况下，Laravel 允许使用同一 Session 的请求并发地执行，举例来说，如果使用一个 JavaScript HTTP 库向你的应用执行两次 HTTP 请求，它们将同时执行。对多数应用这不是问题，然而 在一小部分应用中可能出现 Session 数据丢失，这些应用会向两个不同的应用端并发请求，并同时写入数据到 Session。 为了解决这个问题，Laravel 允许限制指定 Session 的并发请求。首先，可以在路由定义时使用 block 链式方法。在这个示例中，一个到 /profile 的路由请求会拿到一把 Session 锁。当它处在锁定状态时，任何使用相同 Session ID 的到 /profile 或 /order 的路由请求都必须等待，直到第一个请求处理完成后再继续执行： Route::post('/profile', function () { // ... })-\u003eblock($lockSeconds = 10, $waitSeconds = 10) Route::post('/order', function () { // ... })-\u003eblock($lockSeconds = 10, $waitSeconds = 10) block 方法接受两个可选参数。block 方法接受的第一个参数是 Session 锁释放前应该持有的最大秒数。当然，如果请求在此时间之前完成执行，锁将提前释放。 block 方法接受的第二个参数是请求在试图获得 Session 锁时应该等待的秒数。如果请求在给定的秒数内无法获得会话锁，将抛出 Illuminate\\Contracts\\Cache\\LockTimeoutException 异常。 如果不传参，那么 Session 锁默认锁定最大时间是 10 秒，请求锁最大的等待时间也是 10 秒： Route::post('/profile', function () { // ... })-\u003eblock() ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:26:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP","Laravel"],"content":"添加自定义Session驱动 实现驱动 如果现存的 Session 驱动不能满足需求，Laravel 允许自定义 Session Handler。自定义驱动应实现 PHP 内置的 SessionHandlerInterface。这个接口仅包含几个方法。以下是 MongoDB 驱动实现的代码片段： \u003c?php namespace App\\Extensions; class MongoSessionHandler implements \\SessionHandlerInterface { public function open($savePath, $sessionName) {} public function close() {} public function read($sessionId) {} public function write($sessionId, $data) {} public function destroy($sessionId) {} public function gc($lifetime) {} } 注：Laravel 没有内置存放扩展的目录，可以放置在任意目录下，这个示例里，创建了一个 Extensions 目录存放 MongoSessionHandler。 open 方法通常用于基于文件的 Session 存储系统。因为 Laravel 附带了一个fileSession 驱动。你无须在里面写任何代码。可以简单地忽略掉。 close 方法跟 open 方法很像，通常也可以忽略掉。对大多数驱动来说，它不是必须的。 read 方法应返回与给定的 $sessionId 关联的 Session 数据的字符串格式。在你的驱动中获取或存储 Session 数据时，无须作任何序列化和编码的操作，Laravel 会自动为你执行序列化。 write 方法将与 $sessionId 关联的给定的 $data 字符串写入到一些持久化存储系统，如 MongoDB 或者其他你选择的存储系统。再次，你无须进行任何序列化操作，Laravel 会自动为你处理。 destroy 方法应可以从持久化存储中删除与 $sessionId 相关联的数据。 gc 方法应可以销毁给定的 $lifetime（UNIX 时间戳格式 ）之前的所有 Session 数据。对于像 Memcached 和 Redis 这类拥有过期机制的系统来说，本方法可以置空。 注册驱动 在 Laravel 中添加额外的驱动到 Session 后端 ，可以使用 Session Facade 提供的 extend 方法。你应该在服务提供者中的 boot 方法中调用 extend 方法。可以通过已有的 App\\Providers\\AppServiceProvider 或创建一个全新的服务提供者执行此操作： \u003c?php namespace App\\Providers; use App\\Extensions\\MongoSessionHandler; use Illuminate\\Contracts\\Foundation\\Application; use Illuminate\\Support\\Facades\\Session; use Illuminate\\Support\\ServiceProvider; class SessionServiceProvider extends ServiceProvider { /** * 注册任意应用服务。 */ public function register(): void { // ... } /** * 启动任意应用服务。 */ public function boot(): void { Session::extend('mongo', function (Application $app) { // 返回一个 SessionHandlerInterface 接口的实现 ... return new MongoSessionHandler; }); } } 一旦 Session 驱动注册完成，就可以在 config/session.php 配置文件选择使用 mongo 驱动。 ","date":"2023年05月08日","objectID":"/2023/05/laravel01/:27:0","tags":["PHP","Laravel"],"title":"Laravel 路由","uri":"/2023/05/laravel01/"},{"categories":["PHP"],"content":"一、初识PHP？ ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:0:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"1.1 PHP是什么 PHP(Hypertext Preprocessor 超文本预处理器)的简称，是一种被广泛应用的开源通用的服务器端脚本语言，适用于web开发并可嵌入HTML中 通用：指跨平台，如：Windows、Linux、MacOS 开源：意味着你可以轻松获取全部源代码，并进行定制或扩展 免费：意味着你不必为PHP花一分钱，哪怕用在商业项目中 服务器端：意味着你必须将它安装在服务器环境下才可以使用 脚本语言：解释型语言，按编写顺序执行。是指不需要编译,直接由解释器/虚拟机执行的编程语言 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:1:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"1.2 PHP能做什么 可以快速动态的生成HTML页面 可以返回前端需要的各种类型的数据 可以高效安全的处理表单数据 可以安全的操作服务器上的文件 可以控制与客户端的会话( Cookie/Session ) 可以对用户的行为进行授权控制 可以高效安全的操作各种类型的数据库 通过扩展，可以实现加密，压缩等其他功能 可以提供接口数据，包括：小程序、APP、等其他语言 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:2:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"1.3 PHP程序执行流程 二、PHP基础 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:3:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.1 php程序 PHP文件的默认扩展名是.php PHP文件中可以包含html、CSS、JavaScript代码 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:4:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.1.1 PHP标记 开始标记\u003c?php 和结束标记?\u003e中间写php代码 当解析一个文件时，PHP会寻找起始和结束标记，也就是告诉PHP开始和停止解析二者之间的代码。 此种解析方式使得PHP可以被嵌入到各种不同的文档中去，而任何起始和结束标记之外的部分都会被PHP解析器忽略 \u003c?php ... ?\u003e ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:4:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.1.2 PHP代码 指令 描述 echo 可以输出一个或多个字符串，用逗号隔开 print 只允许输出一个字符串 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:4:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.1.3 语句结束符; 一行代码结束应该以;结束 \u003c?php echo 111, 222; print 11; ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:4:3","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.1.4 注释 \u003c?php // 这是单行注释 /* 这是多行注释 注释后，在浏览器和网页源码中，是看不到的。 */ ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:4:4","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.3 PHP变量 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:5:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.3.1 声明变量 声明变量使用$ = 属于赋值运算符 \u003c?php $a = 2; $b = 3; echo $a + $b; ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:5:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.3.2 变量命名规则 不能以数字开头 中间不能有空格 \u003c?php # 下划线命名法 $new_title = 'php是世界上最好的语言'; echo $new_title; echo '\u003chr\u003e'; # 小驼峰命名法 $newTitle = 'php是世界上最好的语言'; echo $newTitle; echo '\u003chr\u003e'; # 大驼峰命名法 $NewTitle = 'php是世界上最好的语言'; echo $NewTitle; ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:5:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.4 php标量数据类型 类型 描述 布尔型 Boolean true 和 false 整型 Integer 0~无限大 浮点型 Float 带小数的数字 字符串 String 汉字、英文、复合、等 echo 输出数据值 var_dump 可以打印数据类型和值 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:6:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.4.1 布尔型 布尔型通常用于条件判断 当echo遇上true的时候返回1，遇上false则返回空字符串 \u003c?php $a = true; echo $a; var_dump($a); $b = false; echo $b; var_dump($b); ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:6:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.4.2 整型 整数不能包含逗号或空格 整数是没有小数点的 整数可以是整数或负数 整数可以用三种格式来指定：十进制、十六进制、八进制 \u003c?php $number = 0; var_dump($number); //int(0) $number = 67; var_dump($number); //int(67) $number = -322; var_dump($number);//int(-322) ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:6:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.4.3 浮点型 \u003c?php $number = 10.03; var_dump($number); //float(10.03) $number = -88.23; var_dump($number); //float(-88.23) ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:6:3","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.4.4 字符串 \u003c?php $str = '你好'; var_dump($str); //string(6) \"你好\" 一个中文字符占3个字节 $str = 'Hello PHP!'; var_dump($str); //string(10) \"Hello PHP!\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:6:4","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.5 php复合数据类型 类型 描述 array 数组 object 对象 callable 可调用 iterable 可迭代 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:7:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.5.1 数组 类型 描述 数组 Array 数组可以在一个变量中存储多个值 创建空数组 \u003c?php $arr = array(); var_dump($arr); //array(0) {} $arrs = []; var_dump($arrs); //array(0) {} 创建索引数组 \u003c?php $arr = array( '足球', '篮球', '排球' ); var_dump($arr); /* array(3) { [0]=\u003e string(6) \"足球\" [1]=\u003e string(6) \"篮球\" [2]=\u003e string(6) \"排球\" } */ 创建关联数组 \u003c?php $arr = [ 'Football' =\u003e '足球', 'Basketball' =\u003e '篮球', 'Volleyball' =\u003e '排球' ]; var_dump($arr); /* array(3) { [\"Football\"]=\u003e string(6) \"足球\" [\"Basketball\"]=\u003e string(6) \"篮球\" [\"Volleyball\"]=\u003e string(6) \"排球\" } */ 输出数组值 \u003c?php $arr = array( '足球', '篮球', '排球' ); echo $arr[0]; //足球 echo $arr[1]; //篮球 echo $arr[2]; //排球 $arr = [ 'Football' =\u003e '足球', 'Basketball' =\u003e '篮球', 'Volleyball' =\u003e '排球' ]; echo $arr['Football']; //足球 echo $arr['Basketball']; //篮球 echo $arr['Volleyball']; //排球 打印数组print_r \u003c?php $arr = array( '足球', '篮球', '排球' ); print_r($arr); /* Array ( [0] =\u003e 足球 [1] =\u003e 篮球 [2] =\u003e 排球 ) php连接符 \u003c?php $var1 = 'Hello'; $var2 = 'World'; var_dump($var1 . $var2); //string(10) \"HelloWorld\" var_dump($var1 . ' ' . $var2); //string(11) \"Hello World\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:7:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.5.2 php多维数组 二维数组 \u003c?php $arr = array( array( 'name' =\u003e 'Joker', 'age' =\u003e 18 ), array( 'name' =\u003e 'desire', 'age' =\u003e 19 ), array( 'name' =\u003e 'tommy', 'age' =\u003e 20 ) ); var_dump($arr); /* array(3) { [0]=\u003e array(2) { [\"name\"]=\u003e string(5) \"Joker\" [\"age\"]=\u003e int(18) } [1]=\u003e array(2) { [\"name\"]=\u003e string(6) \"desire\" [\"age\"]=\u003e int(19) } [2]=\u003e array(2) { [\"name\"]=\u003e string(5) \"tommy\" [\"age\"]=\u003e int(20) } } */ print_r($arr); /* Array ( [0] =\u003e Array ( [name] =\u003e Joker [age] =\u003e 18 ) [1] =\u003e Array ( [name] =\u003e desire [age] =\u003e 19 ) [2] =\u003e Array ( [name] =\u003e tommy [age] =\u003e 20 ) ) */ 三维数组 \u003c?php $arr = [ [ 'name' =\u003e 'Joker', 'age' =\u003e 18, 'hobby' =\u003e [ '爬山', '读书', '徒步' ] ], [ 'name' =\u003e 'desire', 'age' =\u003e 19, 'hobby' =\u003e [ '篮球', '攀岩', '游泳' ] ], [ 'name' =\u003e 'tommy', 'age' =\u003e 20, 'hobby' =\u003e [ '足球', '潜水', '摄影' ] ] ]; var_dump($arr); /* array(3) { [0]=\u003e array(3) { [\"name\"]=\u003e string(5) \"Joker\" [\"age\"]=\u003e int(18) [\"hobby\"]=\u003e array(3) { [0]=\u003e string(6) \"爬山\" [1]=\u003e string(6) \"读书\" [2]=\u003e string(6) \"徒步\" } } [1]=\u003e array(3) { [\"name\"]=\u003e string(6) \"desire\" [\"age\"]=\u003e int(19) [\"hobby\"]=\u003e array(3) { [0]=\u003e string(6) \"篮球\" [1]=\u003e string(6) \"攀岩\" [2]=\u003e string(6) \"游泳\" } } [2]=\u003e array(3) { [\"name\"]=\u003e string(5) \"tommy\" [\"age\"]=\u003e int(20) [\"hobby\"]=\u003e array(3) { [0]=\u003e string(6) \"足球\" [1]=\u003e string(6) \"潜水\" [2]=\u003e string(6) \"摄影\" } } } */ print_r($arr); /* Array ( [0] =\u003e Array ( [name] =\u003e Joker [age] =\u003e 18 [hobby] =\u003e Array ( [0] =\u003e 爬山 [1] =\u003e 读书 [2] =\u003e 徒步 ) ) [1] =\u003e Array ( [name] =\u003e desire [age] =\u003e 19 [hobby] =\u003e Array ( [0] =\u003e 篮球 [1] =\u003e 攀岩 [2] =\u003e 游泳 ) ) [2] =\u003e Array ( [name] =\u003e tommy [age] =\u003e 20 [hobby] =\u003e Array ( [0] =\u003e 足球 [1] =\u003e 潜水 [2] =\u003e 摄影 ) ) ) */ 多维数组访问 \u003c?php $arr = [ [ 'name' =\u003e 'Joker', 'age' =\u003e 18, 'hobby' =\u003e [ '爬山', '读书', '徒步' ] ], [ 'name' =\u003e 'desire', 'age' =\u003e 19, 'hobby' =\u003e [ '篮球', '攀岩', '游泳' ] ], [ 'name' =\u003e 'tommy', 'age' =\u003e 20, 'hobby' =\u003e [ '足球', '潜水', '摄影' ] ] ]; echo $arr[0]['name'] . '----'; //Joker---- echo $arr[0]['age'] . '----'; //18---- echo $arr[0]['hobby'][0] . '----'; //爬山---- echo $arr[0]['hobby'][1] . '----'; //读书---- echo $arr[0]['hobby'][2] . '----'; //徒步---- ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:7:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.5.3 php数组循环 foreach \u003c?php $arr = [ 'Football' =\u003e '足球', 'Basketball' =\u003e '篮球', 'Volleyball' =\u003e '排球' ]; foreach ($arr as $v) { echo $v . \"\\n\"; } /* 足球 篮球 排球 */ key和value \u003c?php $arr = [ 'Football' =\u003e '足球', 'Basketball' =\u003e '篮球', 'Volleyball' =\u003e '排球' ]; foreach ($arr as $k =\u003e $v) { echo $k . \"=\u003e\" . $v . \"\\n\"; } /* Football=\u003e足球 Basketball=\u003e篮球 Volleyball=\u003e排球 */ $arr = array( '足球', '篮球', '排球' ); foreach ($arr as $k =\u003e $v) { echo $k . \"=\u003e\" . $v . \"\\n\"; } /* 0=\u003e足球 1=\u003e篮球 2=\u003e排球 */ ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:7:3","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.6 php特殊数据类型 类型 描述 控制 NULL 表示变量没有值 resource 资源 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:8:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.6.1 NULL \u003c?php $null; var_dump($null); // NULL 会有警告:Warning: Undefined variable $null in /var/www/html/php8/DataType/Data.php on line 25 $null = \"\"; var_dump($null); //string(0) \"\" $null = null; var_dump($null); //NULL ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:8:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.7 条件判断 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:9:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.7.1 三元运算符? : \u003c?php $name = 'Joker'; $res = $name ? \"我是$name\" : '我是谁？'; var_dump($res); // string(11) \"我是Joker\" $name = ''; $res = $name ? \"我是$name\" : '我是谁？'; var_dump($res); // string(12) \"我是谁？\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:9:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.7.2 if \u003c?php $name = 'Joker'; if ($name) { echo \"我是$name\"; //我是Joker } ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:9:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.7.3 if else \u003c?php $name = 'Joker'; if ($name) { echo \"我是$name\"; //我是Joker } else { echo \"我是谁？\"; } $name = ''; if ($name) { echo \"我是$name\"; } else { echo \"我是谁？\"; //我是谁？ } ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:9:3","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.7.4 if elseif else \u003c?php $score = 80; if ($score \u003e= 80) { echo \"良好\"; // 良好 } elseif ($score \u003e= 60) { echo \"及格\"; } else { echo \"差\"; } ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:9:4","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.7.5 switch case default \u003c?php $userID = 1; switch ($userID) { case 1: echo 'Joker'; case 2: echo 'Desire'; case 3: echo 'Tommy'; default: echo '未知'; } // 结果：JokerDesireTommy未知 // 出现的问题，会把所有的情况数据都打印出来 // 解决：使用break匹配到后自动结束掉 switch ($userID) { case 1: echo 'Joker'; // Joker break; case 2: echo 'Desire'; break; case 3: echo 'Tommy'; break; default: echo '未知'; break; } ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:9:5","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.7.6 PHP8新特性match \u003c?php $userID = 1003; echo match ($userID) { 1001 =\u003e 'Joker', 1002 =\u003e 'Desire', 1003 =\u003e 'Tommy' }; // Tommy $userID = 1004; echo match ($userID) { 1001 =\u003e 'Joker', 1002 =\u003e 'Desire', 1003 =\u003e 'Tommy', default =\u003e '未知' }; // 未知 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:9:6","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"2.7.7 switch和match对比 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:9:7","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"运算符 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:10:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"php运算符 运算符 描述 +、-、*、/ 加减乘除 % 取余 ++、-- 加加、减减 . 连接，用在字符串 \u003c?php var_dump(120 + 3); //int(123) var_dump(120 - 3); //int(117) var_dump(120 - 130); //int(-10) var_dump(120 * 3); //int(360) var_dump(120 / 7); //float(17.142857142857142) var_dump(120 % 7); //int(1) $num = 10; $num++; var_dump($num); //int(11) $num = 10; $num--; var_dump($num); //int(9) $num = 10; ++$num; var_dump($num); //int(11) $num = 10; --$num; var_dump($num); //int(9) // $a1 = 'Hello'; $a2 = 'World'; $num = 10; var_dump($a1 . $a2); //string(10) \"HelloWorld\" var_dump($a1 . $num);//string(7) \"Hello10\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:10:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"php赋值运算符 运算符 描述 = 赋值运算符 += 先加再赋值 -= 先减后赋值 *= 先乘后赋值 /= 先除后赋值 %= 先取余后赋值 .= 先连接后赋值 \u003c?php $count = 100; var_dump($count); //int(100) $count = 100; $count += 1; var_dump($count); //int(101) $count = 100; $count -= 1; var_dump($count); //int(99) $count = 100; $count *= 2; var_dump($count); //int(200) $count = 100; $count /= 3; var_dump($count); //float(33.333333333333336) $count = 100; $count %= 3; var_dump($count); //int(1) $count = 100; $count .= 3; var_dump($count); //string(4) \"1003\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:10:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"php比较运算符 运算符 描述 \u003e 大于 \u003e= 大于等于 \u003c 小于 \u003c= 小于等于 == 等于 != 不等于 === 恒等于 !== 恒不等 \u003c?php // 大于 var_dump(100 \u003e 100); //bool(false) var_dump(100 \u003e 90); //bool(true) var_dump(100 \u003e 110); //bool(false) var_dump(true \u003e false); //bool(true) var_dump('php' \u003e 'php'); //bool(false) // 大于等于 var_dump(100 \u003e= 100); //bool(true) var_dump(100 \u003e= 90); //bool(true) var_dump(100 \u003e= 110); //bool(false) var_dump(true \u003e= false); //bool(true) var_dump('php' \u003e= 'php'); //bool(true) // 小于 var_dump(100 \u003c 100); //bool(false) var_dump(100 \u003c 90); //bool(false) var_dump(100 \u003c 110); //bool(true) var_dump(true \u003c false); //bool(false) var_dump('php' \u003c 'php'); //bool(false) // 小于等于 var_dump(100 \u003c= 100); //bool(true) var_dump(100 \u003c= 90); //bool(false) var_dump(100 \u003c= 110); //bool(true) var_dump(true \u003c= false); //bool(false) var_dump('php' \u003c= 'php'); //bool(true) // 等于 var_dump(100 == 100); //bool(true) var_dump(true == true); //bool(true) var_dump('php' == 'php'); //bool(true) // 不等于 var_dump(100 != 100); //bool(false) var_dump(true != true); //bool(false) var_dump('php' != 'php'); //bool(false) // 恒等于 var_dump(100 === 100); //bool(true) var_dump(true === 'true'); //bool(false) // 恒不等 var_dump(100 !== 100); //bool(false) var_dump(true !== 'true'); //bool(true) // php8新特性：字符串与数字的比较 var_dump('中国' \u003e 100); //bool(true) var_dump('中国' == 100); //bool(false) ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:10:3","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"php逻辑运算符 运算符 描述 and 和 \u0026\u0026 与 or 和 ` xor 异或 ! 非 \u003c?php // and 和 \u0026\u0026 // 两个真返回真，有一个假则返回假 var_dump(100 \u0026\u0026 30); //bool(true) var_dump(true \u0026\u0026 true); //bool(true) var_dump(true \u0026\u0026 false); //bool(false) var_dump(false \u0026\u0026 false); //bool(false) // or 和 || // 一个真返回真，两个假返回假 var_dump(100 || 30); //bool(true) var_dump(true || true); //bool(true) var_dump(true || false); //bool(true) var_dump(false || false); //bool(false) // xor //一个真、返回真。两个真，返回假。两个假，也返回假。 var_dump(0 xor 1); //bool(true) var_dump(true xor true); //bool(false) var_dump(true xor false); //bool(true) var_dump(false xor false); //bool(false) // ! // 取反，如果是真，就是假。如果是假，就是真。 var_dump(!0); //bool(true) var_dump(!true); //bool(false) var_dump(!false); //bool(true) var_dump(!1); //bool(false) ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:10:4","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"循环 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:11:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"while \u003c?php // while $int = 1; while ($int \u003c 10) { var_dump($int); $int++; } /* int(1) int(2) int(3) int(4) int(5) int(6) int(7) int(8) int(9) */ ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:11:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"do while \u003c?php // do while $int = 1; do { var_dump($int); } while ($int \u003c 1); /* int(1) */ ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:11:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"for \u003c?php // for for ($int = 1; $int \u003c 10; $int++) { var_dump($int); } /* int(1) int(2) int(3) int(4) int(5) int(6) int(7) int(8) int(9) */ ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:11:3","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"continue 结束当前循环，进入下次循环 在循环语句中使用 while for \u003c?php // continue for ($int = 1; $int \u003c 10; $int++) { if ($int % 2 == 0) { continue; } var_dump($int); } /* int(1) int(3) int(5) int(7) int(9) */ ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:11:4","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"break 结束循环 在循环语句中使用 while for switch 可以跳出多层循环 \u003c?php // break for ($int = 1; $int \u003c 10; $int++) { if ($int % 2 == 0) { var_dump($int); break; } } /* int(2) */ $score = 80; switch ($score) { case $score == 100: echo '相当优秀'; break; case $score \u003e= 80 \u0026\u0026 $score \u003c 100: echo '优秀'; break; case $score \u003e= 60 \u0026\u0026 $score \u003c 80: echo '良好'; break; case $score \u003c 60: echo '不及格'; break; default: echo '得分有误'; break; } 三、函数 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:11:5","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"3.1 函数介绍 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:12:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"3.1.1 函数判断 \u003c?php // 直接判断不存在的变量，会有警告（不会报错） Warning: Undefined variable $name var_dump($name); //NULL if ($name) { echo \"我是$name\"; } else { echo \"我是谁？\"; } // 使用isset函数判断 var_dump(isset($name)); //bool(false) if (isset($name)) { echo \"我是$name\"; } // 使用empty函数判断,Warning: Undefined variable $name var_dump(empty($name)); //bool(true) if (empty($name)) { echo \"我是$name\"; } ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:12:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"3.1.2 函数的分类 根据函数的提供者分为两类： 系统函数：编写语言开发者事先写好提供给开发者直接是用的（内置函数） 自定义函数：用户根据自身需求，对系统功能进行扩展 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:12:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"3.2 系统函数 PHP拥有超过1000个内置函数 函数集合名 描述 String 字符串处理函数 Array 数组函数允许访问和操作数组 MySQLi 允许访问MySQL数据库服务器 Date 服务器上获取日期和时间 Filesystem 允许访问和操作文件系统 Mail 数学函数能处理integer和float范围内的值 HTTP 允许在其他输出被发送之前，对由web服务器发送到浏览器的信息进行操作 Calendar 日历扩展包括了简化不同日历格式间转换的函数 Directory 允许获得关于目录及其内容的信息 Error 允许对错误进行处理和记录 Filter 进行验证和过滤 FTP 通过文件传输协议(FTP)提供对文件服务器的客户端访问 MySQL 允许访问MySQL数据库服务器 SimpleXML 允许把XML转换为对象 XML 允许解析XML文档，但无法对其进行验证 Zip 压缩文件函数允许读取压缩文件 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:13:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"3.2.1 String字符串函数 函数 描述 strtolower() 将字符串转化为小写 strtoupper() 将字符串转化为大写 strlen() 获取字符串长度 trim() 去除字符串首尾处的空白字符 ltrim() 去除字符串开头处的空白字符 rtrim() 去除字符串结尾处的空白字符 str_replace() 字符串替换 strpbrk() 字符串中查找一组字符是否存在 explode() 将字符串分割为数组 md5() 将字符串进行md5加密 \u003c?php $msg = \"Hello World！\"; // 将字符串转化为小写 $msgLower = strtolower($msg); var_dump($msgLower); // string(14) \"hello world！\" // 将字符串转为大写 $msgUpper = strtoupper($msg); var_dump($msgUpper); //string(14) \"HELLO WORLD！\"s // 获取字符串长度 $msgLen = strlen($msg); var_dump($msgLen); //int(14) $msg = \" Hello World \"; var_dump($msg); //string(13) \" Hello World \" // 去除字符串首尾处的空白字符 $msgTrim = trim($msg); var_dump($msgTrim); //string(11) \"Hello World\" $msgTrim = trim(\"Hello World!\", \"!\"); var_dump($msgTrim); //string(11) \"Hello World\" // 去除字符串开头的空白字符 $msgLtrim = ltrim($msg); var_dump($msgLtrim); //string(12) \"Hello World \" // 去除字符串尾部的空白字符 $msgRtrim = rtrim($msg); var_dump($msgRtrim); //string(12) \" Hello World\" // 字符串替换 $msg2 = str_replace(\"World\", \"PHP\", $msg); var_dump($msg2); //string(11) \" Hello PHP \" // 字符串中查找一组字符是否存在 $res = strpbrk(\"w\", $msg); var_dump($res); //bool(false) $res = strpbrk('ord', $msg); var_dump($res); //string(3) \"ord\" // 将字符串分割成数组 $msgArr = explode(\",\", \"1,2,3,4\"); var_dump($msgArr); /* array(4) { [0]=\u003e string(1) \"1\" [1]=\u003e string(1) \"2\" [2]=\u003e string(1) \"3\" [3]=\u003e string(1) \"4\" } */ $msgMD5 = md5(\"我爱我家\"); var_dump($msgMD5); //string(32) \"b7e613a1cb13b29e4e63b9c596c1bb14\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:13:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"3.2.2 Array数组函数 函数 描述 count() 数组中元素的数量 implode() 把数组元素组合为字符串 array_merge() 两个数组合并为一个数组 in_array() 数组中是否存在指定的值 sort() 对数值数组进行升序排序 rsort() 对数值数组进行降序排序 array_unique() 移除数组中的重复的值 array_push() 将一个或多个元素插入数组的末尾 array_pop() 删除数组中的最后一个元素 \u003c?php $arr = [ 'Joker', 'Desire', 'Tommy', 'Ann' ]; // 数组中元素的数量 $count = count($arr); var_dump($count); //int(4) // 把数组元素组合为字符串 $implode = implode($arr); var_dump($implode); //string(19) \"JokerDesireTommyAnn\" $implode = implode(', ', $arr); var_dump($implode); //string(25) \"Joker, Desire, Tommy, Ann\" // 两个数组合并为一个数组 $arr2 = [ 'Ming', 'Ning' ]; $arr3 = array_merge($arr, $arr2); var_dump($arr3); // 数组中是否存在指定的值 $res = in_array(\"Desire\", $arr); var_dump($res); //bool(true) $res = in_array(\"Desire3\", $arr); var_dump($res); //bool(false) $arr = [1, 3, 4, 2, 23, 56, 14, 8, 9, 74, 3]; // 对数值数组进行升序排序 sort($arr); print_r($arr); /* Array ( [0] =\u003e 1 [1] =\u003e 2 [2] =\u003e 3 [3] =\u003e 3 [4] =\u003e 4 [5] =\u003e 8 [6] =\u003e 9 [7] =\u003e 14 [8] =\u003e 23 [9] =\u003e 56 [10] =\u003e 74 ) */ rsort($arr); print_r($arr); /* Array ( [0] =\u003e 74 [1] =\u003e 56 [2] =\u003e 23 [3] =\u003e 14 [4] =\u003e 9 [5] =\u003e 8 [6] =\u003e 4 [7] =\u003e 3 [8] =\u003e 3 [9] =\u003e 2 [10] =\u003e 1 ) */ $arr = [1, 2, 2, 3, 2, 6, 5, 6, 45, 34, 1]; $arr1 = array_unique($arr); print_r($arr1); /* Array ( [0] =\u003e 1 [1] =\u003e 2 [3] =\u003e 3 [5] =\u003e 6 [6] =\u003e 5 [8] =\u003e 45 [9] =\u003e 34 ) */ $arr = ['Joker']; array_push($arr, 'desire', 'tommy'); print_r($arr); /* Array ( [0] =\u003e Joker [1] =\u003e desire [2] =\u003e tommy ) */ // 删除数组中的最后一个元素 $arr = ['Joker', 'desire', 'tommy', 'Ann']; array_pop($arr); print_r($arr); /* Array ( [0] =\u003e Joker [1] =\u003e desire [2] =\u003e tommy ) */ ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:13:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"3.3 自定义函数 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:14:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"3.3.1 函数的基本语法 必须使用关键字: function声明 函数名称不区分大小写 function fun_name(参数列表) { // 函数体，可以为空 } ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:14:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"3.3.2 调用函数 function func_name() { return 'a Function'; } // 调用函数 $res = func_name(); var_dump($res); //\"a Function\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:14:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"3.3.3 函数参数 方法参数可以有默认值 function func_name2($name) { return \"我是$name\"; } var_dump(func_name2(\"Joker\")); // string(11) \"我是Joker\" function func_name3($name, $age = 18) { return \"我是{$name}, 今年{$age}岁!\"; } var_dump(func_name3(\"Joker\")); // string(25) \"我是Joker, 今年18岁!\" var_dump(func_name3(\"Joker\", 20)); // string(25) \"我是Joker, 今年20岁!\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:14:3","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"3.3.4 作用域 php中，只有函数作用域和全局作用域 所有函数作用域的变量，外部不可见 全局作用域声明变量，在函数中是可见的 $num = 1; function func() { global $num; $num = $num + 1; return $num; } var_dump(func());//int(2) ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:14:4","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"3.3.5 PHP8新特性：命名参数 function func2($a, $b = 0, $c = 0, $d = 0) { return $a . '--' . $b . '--' . $c . '--' . $d; } // php7 var_dump(func2(10, 20, 30, 40)); //string(14) \"10--20--30--40\" // php8 var_dump(func2(10, 20, d: 30, c: 40));//string(14) \"10--20--40--30\" 四、类与对象 类是具有相同属性和操作的一组对象的集合 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:14:5","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"创建类 // 创建类 class People { } ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:15:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"创建对象 // 调用类（实例化类） $p1 = new People(); $p2 = new People(); $p3 = new People(); ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:16:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"复合数据类型 类型 描述 object 对象 // 复合数据类型（object 对象） var_dump($p1); //object(People)#1 (0) {} var_dump($p2); //object(People)#2 (0) {} var_dump($p3); //object(People)#3 (0) {} var_dump($p1 == $p2); //bool(true) var_dump($p1 == $p3); //bool(true) var_dump($p2 == $p3); //bool(true) var_dump($p1 === $p2); //bool(false) var_dump($p1 === $p3); //bool(false) var_dump($p2 === $p3); //bool(false) ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:17:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"成员变量 成员变量：类属性 \u003c?php // 创建类 class People { public $name = 'Joker'; public $job = 'IT'; } // 调用类（实例化类） $p1 = new People(); // 获取类属性 var_dump($p1-\u003ename); //string(5) \"Joker\" var_dump($p1-\u003ejob); //string(2) \"IT\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:18:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"成员方法 \u003c?php // 创建类 class People { public $name = 'Joker'; public $job = 'IT'; public function fun1() { echo '我是People的没有返回值的fun1方法！'; } public function fun2() { return '我是People的有返回值的fun2方法！'; } public function fun3() { // 在类中使用伪变量:“$this”引用当前类的成员变量 return 'fun3方法获取类属性，name=\u003e' . $this-\u003ename . ' job=\u003e' . $this-\u003ejob; } public function fun4() { // 在类中使用伪变量:“$this”引用当前类的成员方法 return $this-\u003efun3(); } } // 调用类（实例化类） $p1 = new People(); $p1-\u003efun1(); //我是People的没有返回值的fun1方法！ var_dump($p1-\u003efun2()); //string(43) \"我是People的有返回值的fun2方法！\" var_dump($p1-\u003efun3()); //string(47) \"fun3方法获取类属性，name=\u003eJoker job=\u003eIT\" var_dump($p1-\u003efun4()); //string(47) \"fun3方法获取类属性，name=\u003eJoker job=\u003eIT\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:19:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"魔术方法 方法 描述 __construct 构造方法 __destruct 析构方法 __call 在对象中调用一个不可访问方法时调用 __callStatic 在静态方式中调用一个不可访问方法时调用 __get 获得一个类的成员变量时调用 __set 设置一个类的成员变量时调用 __isset 当对不可访问属性调用isset()或empty()时调用 __unset 当对不可访问属性调用unset()时被调用 __sleep 执行serialize()时，先会调用这个函数 __wakeup 执行unserialize()时，先会调用这个函数 __toString 类被当成字符串时的回应方法 __invoke 调用函数的方式调用一个对象时的回应方法 __set_state 调用var_export()导出类时，此静态方法会被调用 __clone 当对象复制完成时调用 __autoload 尝试加载未定义的类 debugInfo 打印所需调试信息 \u003c?php // 创建类 class People { public $name = 'Joker'; public $job = 'IT'; /** * 构造方法 */ public function __construct($name, $job) { $this-\u003ename = $name; $this-\u003ejob = $job; } /** * 析构方法 * 当类调用执行完毕后被执行 */ public function __destruct() { echo '类执行完毕，要关闭了'; } public function fun() { return \"姓名：{$this-\u003ename}, 工作：{$this-\u003ejob}\"; } } // 调用类（实例化类） $obj = new People('Desire', 'teacher'); var_dump($obj-\u003efun()); //string(33) \"姓名：Desire, 工作：teacher\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:20:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"类的三大特性 继承：可以让某个类型的对象获得另一个类型的对象的属性和方法 封装：指将客观事物抽象成类，每个类对自身的数据和方法实行保护 多态：指同一个实体同时具有多种形式，它主要体现在类的继承体系中 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:21:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"继承 extends关键词继承父类 \u003c?php // 创建类 class People { public $name = 'Joker'; public $job = 'IT'; /** * 构造方法 */ public function __construct($name, $job) { $this-\u003ename = $name; $this-\u003ejob = $job; } /** * 析构方法 * 当类调用执行完毕后被执行 */ public function __destruct() { echo '类执行完毕，要关闭了'; } public function fun() { return \"姓名：{$this-\u003ename}, 工作：{$this-\u003ejob}\"; } } // 继承People类 class Teacher extends People { } // 调用类（实例化类） $obj = new Teacher('Desire', 'teacher'); var_dump($obj-\u003efun()); //string(33) \"姓名：Desire, 工作：teacher\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:21:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"封装 public 默认，关键词定义，类内、类外、子类都可见 protected 关键词定义，类内、子类可见，类外不可见 pricate 关键词定义，类内可见，子类、类外不可见 \u003c?php // 创建类 class People { public $name; protected $job; //类内、子类可见，类外不可见 private $age; // 类内可见，子类、类外不可见 /** * 构造方法 */ public function __construct($name, $job, $age) { $this-\u003ename = $name; $this-\u003ejob = $job; $this-\u003eage = $age; } public function fun() { return \"姓名：{$this-\u003ename}, 工作：{$this-\u003ejob}, 年龄：{$this-\u003eage}\"; } /** * `protected` 关键词定义，类内、子类可见，类外不可见 */ protected function fun2() { return '类内、子类可见，类外不可见'; } /** * `pricate` 关键词定义，类内可见，子类、类外不可见 */ private function fun3() { return '类内可见，子类、类外不可见'; } } // 继承People类 class Teacher extends People { /** * 在子类调用被protected修饰的方法，不可调用× */ public function tecFunc() { return $this-\u003efunc2(); } /** * 在子类调用被private修饰的方法，不可调用× */ public function tecFunc2() { return $this-\u003efun3(); } public function getName() { return $this-\u003ename; } /** * 在子类中调用被protected修饰的类属性，可调用√ */ public function getJob() { return $this-\u003ejob; } /** * 在子类中调用被private修饰的类属性，不可调用× */ public function getAge() { return $this-\u003eage; } } // 调用类（实例化类） $obj = new People('Desire', 'teacher', 19); var_dump($obj-\u003efun()); //string(33) \"姓名：Desire, 工作：teacher\" // 访问被private定义的类属性，不可访问 // Fatal error: Uncaught Error: Cannot access private property People::$age // var_dump($obj-\u003eage); // 访问被protected定义的类属性，不可访问 // Fatal error: Uncaught Error: Cannot access protected property People::$job // var_dump($obj-\u003ejob); // 访问被protected定义的类方法，不可访问 // Fatal error: Uncaught Error: Call to protected method People::fun2() from global scope in // var_dump($obj-\u003efun2()); // 访问被private定义的类方法，不可访问 //Fatal error: Uncaught Error: Call to private method People::fun3() from global scope in // var_dump($obj-\u003efun3()); // 调用子类 $p1 = new Teacher('Joker', 'Teacher', 19); var_dump($p1-\u003etecFunc()); // var_dump($p1-\u003etecFunc2()); // var_dump($p1-\u003egetName()); var_dump($p1-\u003egetJob()); // string(7) \"Teacher\" // var_dump($p1-\u003egetAge()); ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:21:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"多态 实现多态的前提是要先继承再重写父类方法 \u003c?php // 创建类 class People { public $name; protected $job; //类内、子类可见，类外不可见 private $age; // 类内可见，子类、类外不可见 /** * 构造方法 */ public function __construct($name, $job, $age) { $this-\u003ename = $name; $this-\u003ejob = $job; $this-\u003eage = $age; } public function fun() { return \"姓名：{$this-\u003ename}, 工作：{$this-\u003ejob}, 年龄：{$this-\u003eage}\"; } /** * `protected` 关键词定义，类内、子类可见，类外不可见 */ protected function fun2() { return '类内、子类可见，类外不可见'; } /** * `pricate` 关键词定义，类内可见，子类、类外不可见 */ private function fun3() { return '类内可见，子类、类外不可见'; } } class Student extends People { /** * 通过重写父类方法实现多态 */ public function fun() { return '重写了父类的方法'; } } $stu = new Student('Tommy', 'student', 16); var_dump($stu-\u003efun()); //string(24) \"重写了父类的方法\" ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:21:3","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"静态成员 static 关键词定义静态成员 \u003c?php class Teacher { public static $name; public static $school; public static $gongfu = 'PHP'; public function fun() { echo '普通成员方法' . PHP_EOL; } /** * 定义静态方法 * 获取类静态属性，应该使用 :: 进行获取，静态方法只能获取静态属性 */ public static function fun2() { return '姓名：' . Teacher::$name . ', 学校：' . Teacher::$school . PHP_EOL; } } // 获取静态属性 echo Teacher::$gongfu . PHP_EOL; //PHP // 获取静态方法 echo Teacher::fun2(); //姓名：, 学校： // 可以修改静态属性值 Teacher::$name = 'Joker'; Teacher::$school = '家里蹲大学'; echo Teacher::fun2(); //姓名：Joker, 学校：家里蹲大学 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:22:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"抽象类 abstract 关键词定义抽象方法/抽象类 \u003c?php abstract class People { public function fun() { return \"普通方法\" . PHP_EOL; } abstract public function fun2(); } // 抽象类不可被实例化，只能被继承 // new People(); class Student extends People { public function fun2() { return \"继承抽象类，并实现抽象方法\" . PHP_EOL; } } $stu = new Student(); // 调用抽象类的普通方法 echo $stu-\u003efun(); //普通方法 // 调用子类实现的抽象类的抽象方法 echo $stu-\u003efun2(); //继承抽象类，并实现抽象方法 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:23:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"接口 interface 关键词创建接口。要求类必须实现的方法，但不需要定义方法的具体实现过程。 implements 关键词使用接口。 \u003c?php interface file { public function fly(); public function run(); } class Cat implements file { /** * 实现接口方法 */ function fly() { echo '飞起来了!' . PHP_EOL; } /** * 实现接口方法 */ function run() { echo '跑起来了！' . PHP_EOL; } } $cat = new Cat(); $cat-\u003efly(); //飞起来了! $cat-\u003erun(); //跑起来了！ ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:24:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"接口常量 const创建常量 interface config { // 使用const定义常量 const HOST = 'localhost'; const PORT = 3306; const USER = 'root'; const PWD = 'root'; } class DBConn implements config { private $host = config::HOST; private $port = config::PORT; private $user = config::USER; private $pwd = config::PWD; function database() { return \"mysql -P {$this-\u003eport} -h {$this-\u003ehost} -u {$this-\u003euser} -p {$this-\u003epwd} \" . PHP_EOL; } } $db = new DBConn(); echo $db-\u003edatabase(); //mysql -P 3306 -h localhost -u root -p root ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:25:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"常量 \u003c?php // 创建常量 // 方式一 define() define('HOST', '127.0.0.1'); echo HOST; // 127.0.0.1 // 方式二 const const NAME = 'PHP'; echo NAME; // PHP ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:26:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"关键词 关键词 类外声明 声明类 声明属性 声明方法 解释 const √ √ 定义类常量 extends √ 扩展类，用一个类去扩展它的父类 public √ √ 公用属性或方法 protected √ √ 私有属性或方法 pricate √ √ 受保护的属性或方法 static √ √ √ 静态成员 abstract √ √ 抽象类或方法 interface √ 创建接口 implements √ 实现接口 final √ √ 类不能被继承 parent:: 访问父类 $this-\u003e 访问本类 self:: 访问本类静态 namespace √ 创建命名空间 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:27:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"final类不能被继承 \u003c?php final class People { public string $name; public int $age; // 构造方法 public function __construct($name, $age) { $this-\u003ename = $name; $this-\u003eage = $age; } /** * @return string */ public function func(): string { return \"姓名：{$this-\u003ename}, 年龄：{$this-\u003eage}\"; } } // 子类继承被final定义的父类 class Student extends People { } $student = new Student('Joker', 19); echo $student-\u003efunc(); // 执行报错：Fatal error: Class Student cannot extend final class ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:27:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"parent:: 访问父类 \u003c?php class People { public string $name; public int $age; // 构造方法 public function __construct($name, $age) { $this-\u003ename = $name; $this-\u003eage = $age; } /** * @return string */ public function func(): string { return \"姓名：{$this-\u003ename}, 年龄：{$this-\u003eage}\"; } } class Student extends People { /** * 重写父类的方法，并且调用父类的此方法 * @return string */ public function func(): string { return parent::func(); } } $student = new Student('Joker', 19); echo $student-\u003efunc(); // 姓名：Joker, 年龄：19 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:27:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"命名空间 命名空间：解决全局成员的命名冲突问题，借鉴了文件目录的思想 空间：同一空间内不允许成员重名，但不同空间内，允许同名成员存在 ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:28:0","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"创建命名空间 命名空间使用 namespace 关键字声明 // ---- 方式一 \u003c?php namespace one { function php() { } } // ---- 方式二 \u003c?php namespace space; class demo { } ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:28:1","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"子命名空间 \u003c?php namespace one { const NAME = 'one 命名空间'; function php(): string { return '命名空间one定义的函数'; } } namespace one\\two { function php(): string { return 'one子命名空间two定义的函数'; } } ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:28:2","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["PHP"],"content":"访问命名空间 use 关键词引用命名空间 AS 解决类名过长、重名问题 \u003c?php namespace one { const NAME = 'one 命名空间'; } namespace one\\two { const NAME = 'one\\two 命名空间'; } namespace two\\one { const NAME = 'two\\one 命名空间'; } namespace three\\one { const NAME = 'three\\one 命名空间'; } namespace main { use one; use one\\two; use two\\one as to; use three\\one as tho; echo one\\NAME . PHP_EOL; // one 命名空间 echo two\\NAME . PHP_EOL; // one\\two 命名空间 echo to\\NAME . PHP_EOL; // two\\one 命名空间 echo tho\\NAME . PHP_EOL; // three\\one 命名空间 } ","date":"2023年04月27日","objectID":"/2023/04/php%E5%85%A5%E9%97%A8/:28:3","tags":["PHP"],"title":"PHP入门","uri":"/2023/04/php%E5%85%A5%E9%97%A8/"},{"categories":["踩坑记录"],"content":"需求 通过Sqlalchemy ORM进行新增数据，有个新的需求是：新增数据后，需要获取到当前数据自动递增的ID。 ","date":"2023年03月27日","objectID":"/2023/03/4/:1:0","tags":["Python","sqlalchemy"],"title":"sqlalchemy新增数据后获取递增ID报错解决","uri":"/2023/03/4/"},{"categories":["踩坑记录"],"content":"处理 通过sqlacodegen生成Model文件 class DailyStatistic(ModelDB2): __tablename__ = 'daily_statistics' id = Column(INTEGER(11), primary_key=True, nullable=False) ... 编写新增逻辑代码 ef add_by_schemas(db: Session, param: DailyStatisticSchemas): daily = DailyStatistic(**dict(param)) db.add(daily) db.commit() # 在commit后，模型对象会自动补充递增的ID，故可以直接使用.id获取递增的ID return daily.id ","date":"2023年03月27日","objectID":"/2023/03/4/:2:0","tags":["Python","sqlalchemy"],"title":"sqlalchemy新增数据后获取递增ID报错解决","uri":"/2023/03/4/"},{"categories":["踩坑记录"],"content":"运行报错了😱 ```bash sqlalchemy.orm.exc.ObjectDeletedError: Instance '\u003cDailyStatistic at 0x1376a7b20\u003e' has been deleted, or its row is otherwise not present. ``` 怎么会提示没有这个属性呢？我不李姐😷 ","date":"2023年03月27日","objectID":"/2023/03/4/:2:1","tags":["Python","sqlalchemy"],"title":"sqlalchemy新增数据后获取递增ID报错解决","uri":"/2023/03/4/"},{"categories":["踩坑记录"],"content":"排查问题 查看数据表是否是自增ID CREATE TABLE `daily_statistics` ( `id` int(11) NOT NULL AUTO_INCREMENT, ... ) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=latin1 COMMENT='日报统计表'; 查看sqlacodegen生成的Model文件 class DailyStatistic(ModelDB2): __tablename__ = 'daily_statistics' id = Column(INTEGER(11), primary_key=True, nullable=False) ... 比对不一样的地方 比对发现，在sqlacodegen生成的Model文件中，并没有自动递增的属性配置 ","date":"2023年03月27日","objectID":"/2023/03/4/:2:2","tags":["Python","sqlalchemy"],"title":"sqlalchemy新增数据后获取递增ID报错解决","uri":"/2023/03/4/"},{"categories":["踩坑记录"],"content":"解决问题 更改自动生成的Model文件ID属性，增加autoincrement=True配置 class DailyStatistic(ModelDB2): __tablename__ = 'daily_statistics' id = Column(INTEGER(11), primary_key=True, nullable=False, autoincrement=True, comment='主键id') 更改后，再次进行添加，无报错✌️ ","date":"2023年03月27日","objectID":"/2023/03/4/:2:3","tags":["Python","sqlalchemy"],"title":"sqlalchemy新增数据后获取递增ID报错解决","uri":"/2023/03/4/"},{"categories":["踩坑记录"],"content":"总结 不能完全相信自动生成的Model文件 再处理获取自增字段时，要优先检查下Model文件是否有autoincrement=True配置 ","date":"2023年03月27日","objectID":"/2023/03/4/:3:0","tags":["Python","sqlalchemy"],"title":"sqlalchemy新增数据后获取递增ID报错解决","uri":"/2023/03/4/"},{"categories":["爬虫","Python"],"content":"背景 ","date":"2023年03月24日","objectID":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/:1:0","tags":["爬虫","Python"],"title":"使用Mixin模式配置Scrapy日志输出","uri":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"},{"categories":["爬虫","Python"],"content":"为什么要重新配置Scrapy日志输出 在使用kafka进行处理爬虫数据后出现了一种现象：日志打印会将整个item数据打印出，由于使用kafka处理数据，都是将整个页面数据进行存入item的，每天的日志都将占很大的内存空间。之前的做法是提高整个爬虫的日志等级为LOG_LEVEL = \"ERROR\" ，这样处理会带来一个问题，如果想要写日志进行排查问题时，就只能往项目中添加logging.error() 级别的日志了，这样会造成日志输出混乱，不易排查问题。所以就需要放弃这种形式，进行重新配置日志输出，将一些不需要的日志输出进行排除掉。 ","date":"2023年03月24日","objectID":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/:1:1","tags":["爬虫","Python"],"title":"使用Mixin模式配置Scrapy日志输出","uri":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"},{"categories":["爬虫","Python"],"content":"Mixin模式 Mixin模式是一种面向对象编程的设计模式，它允许将一个类的方法和属性混合到另一个类中，从而实现代码的复用和灵活性。 在Mixin模式中，一个Mixin类通常只包含一组相关的方法和属性，而不是完整的类定义。这些Mixin类可以被多个类引用，从而实现代码的复用。Mixin类通常不会被单独实例化，而是被其他类继承或混合使用。 在一些编程语言中，如Python和Ruby，Mixin模式可以通过多重继承来实现。在这种情况下，一个类可以继承多个Mixin类，并从中继承方法和属性。在其他编程语言中，如Java和C#，Mixin模式可以通过接口和委托来实现。 Python中使用Mixin模式的示例代码: class SayHiMixin: def say(self): print(f\"Hi, {self.name}\") class User(SayHiMixin): def __init__(self, name): self.name = name user = User(\"Tommy\") user.say() # Hi, Tommy ","date":"2023年03月24日","objectID":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/:2:0","tags":["爬虫","Python"],"title":"使用Mixin模式配置Scrapy日志输出","uri":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"},{"categories":["爬虫","Python"],"content":"使用LogConfigMixin实现Scrapy日志配置 import logging class LogConfigMixin: def __init__(self, *args, **kwargs): super(LogConfigMixin, self).__init__(*args, **kwargs) # 去掉不需要的log handler（元组格式） remove_handlers = (logging.StreamHandler,) for handler in logging.root.handlers: if isinstance(handler, remove_handlers): logging.root.handlers.remove(handler) # 添加自定义 handler handler = logging.StreamHandler() handler.setLevel(logging.DEBUG) logger_fmt = '{asctime}.{msecs:03.0f} {levelname} 【{filename}:{funcName}:{lineno}】: {message}' _format = logging.Formatter(fmt=logger_fmt, style='{', datefmt='%Y-%m-%d %H:%M:%S') handler.setFormatter(fmt=_format) logging.root.addHandler(handler) # 设置 scrapy 某些组件的日志级别 # 此日志中包含了item的输出结果，由于是整个页面数据，故需要调整日志级别，防止日志过大 logging.getLogger('scrapy.core.scraper').setLevel(logging.WARNING) logging.getLogger('scrapy.core.engine').setLevel(logging.DEBUG) logging.getLogger('scrapy.middleware').setLevel(logging.DEBUG) logging.getLogger('scrapy.utils.log').setLevel(logging.DEBUG) # kafka相关日志设置级别 logging.getLogger(\"kafka.cluster\").setLevel(logging.WARNING) logging.getLogger(\"kafka.producer.sender\").setLevel(logging.WARNING) logging.getLogger(\"kafka.producer.record_accumulator\").setLevel(logging.WARNING) logging.getLogger(\"kafka.protocol.parser\").setLevel(logging.WARNING) logging.getLogger(\"kafka.metrics.metrics\").setLevel(logging.WARNING) logging.getLogger(\"kafka.client\").setLevel(logging.WARNING) logging.getLogger(\"kafka.conn\").setLevel(logging.WARNING) logging.getLogger(\"kafka.send\").setLevel(logging.WARNING) logging.getLogger(\"kafka.close\").setLevel(logging.WARNING) ","date":"2023年03月24日","objectID":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/:3:0","tags":["爬虫","Python"],"title":"使用Mixin模式配置Scrapy日志输出","uri":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"},{"categories":["爬虫","Python"],"content":"在爬虫中进行使用 ","date":"2023年03月24日","objectID":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/:4:0","tags":["爬虫","Python"],"title":"使用Mixin模式配置Scrapy日志输出","uri":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"},{"categories":["爬虫","Python"],"content":"自定义Spider和RedisSpider类 使用自定义的Spider和RedisSpider为官方的Spider和RedisSpider基础爬虫类增加日志配置功能 from abc import ABC from scrapy import Spider as _Spider from scrapy_redis.spiders import RedisSpider as _RedisSpider class Spider(LogConfigMixin, _Spider, ABC): pass class RedisSpider(LogConfigMixin, _RedisSpider, ABC): pass 这样做的好处：就可以在不改变原有的爬虫程序，只用修改导包路径即可，修改成本极低✌️ ","date":"2023年03月24日","objectID":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/:4:1","tags":["爬虫","Python"],"title":"使用Mixin模式配置Scrapy日志输出","uri":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"},{"categories":["爬虫","Python"],"content":"例子 原爬虫程序 from scrapy import Spider from estate.items import HuiLvItem class DemoSpider(Spider): name = \"demo\" custom_settings = { 'ITEM_PIPELINES': { 'estate.pipelines.DemoPipeline': 300 }, } start_urls = [ 'https://www.xxxx.cc/HKD_CNY/', ] def parse(self, response, **kwargs): rate = response.xpath('//div[@class=\"dollar_two\"]/span/text()').extract_first() if rate: rate = rate else: rate = 0.85551 item = HuiLvItem() item['rate'] = rate yield item 增加日志配置功能后爬虫程序 from estate.mixin import Spider from estate.items import HuiLvItem class DemoSpider(Spider): name = \"demo\" custom_settings = { 'ITEM_PIPELINES': { 'estate.pipelines.DemoPipeline': 300 }, } start_urls = [ 'https://www.xxxx.cc/HKD_CNY/', ] def parse(self, response, **kwargs): rate = response.xpath('//div[@class=\"dollar_two\"]/span/text()').extract_first() if rate: rate = rate else: rate = 0.85551 item = HuiLvItem() item['rate'] = rate yield item 修改成本极低 只需将官方导包from scrapy import Spider 更改为自定义导包路径 from estate.mixin import Spider ","date":"2023年03月24日","objectID":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/:4:2","tags":["爬虫","Python"],"title":"使用Mixin模式配置Scrapy日志输出","uri":"/2023/03/%E4%BD%BF%E7%94%A8mixin%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AEscrapy%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"},{"categories":["Redis","Python"],"content":"Incr Incr 命令将 key 中储存的数字值增一 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。 返回值为执行 INCR 命令之后 key 的值。 ","date":"2023年03月20日","objectID":"/2023/03/redis-incr%E8%AE%A1%E6%95%B0/:1:0","tags":["Redis","Python"],"title":"Redis-incr计数","uri":"/2023/03/redis-incr%E8%AE%A1%E6%95%B0/"},{"categories":["Redis","Python"],"content":"命令行使用 数值递增 INCR KEY_NAME 获取数值 GET KEY_NAME ","date":"2023年03月20日","objectID":"/2023/03/redis-incr%E8%AE%A1%E6%95%B0/:2:0","tags":["Redis","Python"],"title":"Redis-incr计数","uri":"/2023/03/redis-incr%E8%AE%A1%E6%95%B0/"},{"categories":["Redis","Python"],"content":"Python使用 from contextlib import contextmanager from redis import Redis @contextmanager def redis_connect() -\u003e Redis: conn = Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, db=0) yield conn conn.close() def redis_incr_count(key): with redis_connect() as redis: res = redis.incr(\"incr:count\") return res if __name__ == '__main__': from concurrent.futures import ThreadPoolExecutor # 多线程测试 with ThreadPoolExecutor(max_workers=200) as executor: for _ in range(200): # 模拟多个任务 future = executor.submit(redis_incr_count, \"incr:count\") print(future.result()) 执行结果： ","date":"2023年03月20日","objectID":"/2023/03/redis-incr%E8%AE%A1%E6%95%B0/:3:0","tags":["Redis","Python"],"title":"Redis-incr计数","uri":"/2023/03/redis-incr%E8%AE%A1%E6%95%B0/"},{"categories":["爬虫","Python"],"content":"一、思考 在使用Scrapy-Redis进行数据初始化时，你是如何进行数据写入Redis队列的？ 数据写入的格式如果是JSON，你是如何进行处理的？ ","date":"2023年03月20日","objectID":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/:1:0","tags":["爬虫","Python"],"title":"Scrapy-Redis初始化数据处理","uri":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"categories":["爬虫","Python"],"content":"二、数据初始化 ","date":"2023年03月20日","objectID":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/:2:0","tags":["爬虫","Python"],"title":"Scrapy-Redis初始化数据处理","uri":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"categories":["爬虫","Python"],"content":"2.1 之前的写法 2.1.1 在Scrapy文件头部进行Redis初始化写入 import redis from scrapy.utils.project import get_project_settings # 从配置文件中获取Redis配置 redis_host = get_project_settings().get('REDIS_HOST') redis_port = get_project_settings().get('REDIS_PORT') conn = redis.Redis(host=redis_host, port=redis_port, db=0) conn.sadd('scrapy:start_urls', 'https://www.xxxx.com/page01', 'https://www.xxxx.com/page02', 'https://www.xxxx.com/page03') 2.1.2 存在的问题 会在爬虫部署时就开始执行Redis数据初始化 如果此处的处理耗时比较长，则会导致部署超时失败 注：部署使用的是scrapydweb ","date":"2023年03月20日","objectID":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/:2:1","tags":["爬虫","Python"],"title":"Scrapy-Redis初始化数据处理","uri":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"categories":["爬虫","Python"],"content":"2.2 现在的写法 2.2.1 使用类的初始化方法进行Redis数据初始化 class ScrapySpider(RedisSpider): def __init__(self, name=None, **kwargs): redis_host = get_project_settings().get('REDIS_HOST') redis_port = get_project_settings().get('REDIS_PORT') conn = redis.Redis(host=redis_host, port=redis_port, db=0) conn.sadd('scrapy:start_urls', 'https://www.xxxx.com/page01', 'https://www.xxxx.com/page02', 'https://www.xxxx.com/page03') super(ScrapySpider, self).__init__(name, **kwargs) 2.2.2 执行出现的问题 在部署后进行执行，出现了报错信息，__init __() 得到了一个意外的关键字参数_ job 2.2.3 解决意外关键字参数_job 直接在初始化时删除即可，为了保证可靠性，先判断是否存在，然后再进行删除 class ScrapySpider(RedisSpider): def __init__(self, name=None, **kwargs): redis_host = get_project_settings().get('REDIS_HOST') redis_port = get_project_settings().get('REDIS_PORT') conn = redis.Redis(host=redis_host, port=redis_port, db=0) conn.sadd('scrapy:start_urls', 'https://www.xxxx.com/page01', 'https://www.xxxx.com/page02', 'https://www.xxxx.com/page03') # 判断是否存在 _job关键字参数 if kwargs.get('_job'): # 存在则删除 kwargs.pop('_job') super(ScrapySpider, self).__init__(name, **kwargs) ","date":"2023年03月20日","objectID":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/:2:2","tags":["爬虫","Python"],"title":"Scrapy-Redis初始化数据处理","uri":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"categories":["爬虫","Python"],"content":"三、数据JSON格式处理 在上面的初始化Redis数据时，传入的数据都是固定的一个链接，但是在实际的使用中，链接并不能满足需求，需要存储JSON格式的数据，那么再处理爬虫的时候，就要在Redis pop出数据后进行处理JSON字符串获得指定的链接进行处理。 ","date":"2023年03月20日","objectID":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/:3:0","tags":["爬虫","Python"],"title":"Scrapy-Redis初始化数据处理","uri":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"categories":["爬虫","Python"],"content":"3.1 查询源码，找到对应的处理逻辑 Scrapy-Redis » make_request_from_data : def make_request_from_data(self, data): \"\"\"Returns a Request instance from data coming from Redis. By default, ``data`` is an encoded URL. You can override this method to provide your own message decoding. Parameters ---------- data : bytes Message from redis. 直接读取Redis的数据 \"\"\" # 将Redis pop出的数据转成字符串 url = bytes_to_str(data, self.redis_encoding) # 调用Scrapy的方法进行发送请求 return self.make_requests_from_url(url) Scrapy » make_requests_from_url def make_requests_from_url(self, url): \"\"\" This method is deprecated. \"\"\" warnings.warn( \"Spider.make_requests_from_url method is deprecated: \" \"it will be removed and not be called by the default \" \"Spider.start_requests method in future Scrapy releases. \" \"Please override Spider.start_requests method instead.\" ) # 发送请求，并返回scrapy.http.Request对象 return Request(url, dont_filter=True) ","date":"2023年03月20日","objectID":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/:3:1","tags":["爬虫","Python"],"title":"Scrapy-Redis初始化数据处理","uri":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"categories":["爬虫","Python"],"content":"3.2 进行重写 从上面的源码中，我们可以直接重写make_request_from_data 方法，在方法内部进行处理JSON数据，并返回scrapy.http.Request对象即可。 import json import redis from scrapy import Request from scrapy.utils.project import get_project_settings from scrapy_redis.spiders import RedisSpider class ScrapySpider(RedisSpider): def __init__(self, name=None, **kwargs): redis_host = get_project_settings().get('REDIS_HOST') redis_port = get_project_settings().get('REDIS_PORT') conn = redis.Redis(host=redis_host, port=redis_port, db=0) conn.sadd('scrapy:start_urls', '{\"id\": 9531, \"source\": 1, \"mobile\": \"62196161\", \"url\": \"https://www.xxxx.com/detail001\"}', '{\"id\": 8160, \"source\": 0, \"mobile\": \"60376386\", \"url\": \"https://www.xxxx.com/detail002\"', '{\"id\": 7334, \"source\": 0, \"mobile\": \"62631381\", \"url\": \"https://www.28hse.com/detail003\"') # 判断是否存在 _job关键字参数 if kwargs.get('_job'): # 存在则删除 kwargs.pop('_job') super(ScrapySpider, self).__init__(name, **kwargs) def make_request_from_data(self, data): \"\"\" :param data: 从reids pop到的数据 :return: \"\"\" # 将获取的数据进行转换 req_data = json.loads(data) # 获取所需参数信息 url = req_data['url'] source = req_data['source'] mobile = req_data.get('mobile', '') id = req_data['id'] # 发送请求，并返回 return Request( url, meta={\"id\": id, \"source\": source, \"mobile\": mobile} # 将参数作为元数据传递 ) ","date":"2023年03月20日","objectID":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/:3:2","tags":["爬虫","Python"],"title":"Scrapy-Redis初始化数据处理","uri":"/2023/03/scrapy-redis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"categories":["踩坑记录"],"content":"描述 在HTML文件中引用js文件\u003cscript src=\"{{ url_for('static', path='/js/app.js') }}\"\u003e\u003c/script\u003e ，在本地调试正常，上线后发现网页打不开，打开控制台看到了如下报错信息： ","date":"2023年03月05日","objectID":"/2023/03/3/:1:0","tags":["Python","FastApi"],"title":"Mixed Content The page at was loaded over HTTPS but requested an insecure resource This request has been blocked the content must be served over HTTPS","uri":"/2023/03/3/"},{"categories":["踩坑记录"],"content":"原因 由于线上使用的协议是https协议，而生成的js文件链接是http的，HTML默认是不支持混合使用的，所以才出现上面的错误。 ","date":"2023年03月05日","objectID":"/2023/03/3/:2:0","tags":["Python","FastApi"],"title":"Mixed Content The page at was loaded over HTTPS but requested an insecure resource This request has been blocked the content must be served over HTTPS","uri":"/2023/03/3/"},{"categories":["踩坑记录"],"content":"解决 在HTML文件中添加 标记允许混合内容即可正常使用。 \u003cmeta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\"\u003e ","date":"2023年03月05日","objectID":"/2023/03/3/:3:0","tags":["Python","FastApi"],"title":"Mixed Content The page at was loaded over HTTPS but requested an insecure resource This request has been blocked the content must be served over HTTPS","uri":"/2023/03/3/"},{"categories":["踩坑记录"],"content":"附录 https://stackoverflow.com/questions/67765238/mixed-content-the-page-at-was-loaded-over-https-but-requested-an-insecure-resour ","date":"2023年03月05日","objectID":"/2023/03/3/:4:0","tags":["Python","FastApi"],"title":"Mixed Content The page at was loaded over HTTPS but requested an insecure resource This request has been blocked the content must be served over HTTPS","uri":"/2023/03/3/"},{"categories":["踩坑记录"],"content":"问题描述 在使用Selenium进行某一网站数据抓取的时候，出现一种现象 在页面中需要定位一个元素信息：pages = driver.find_elements(By.XPATH, \"//button[contains(@class,'page-button')]/span\") 本地调试的时候，一切正常，一放到线上就找不到此元素，日志信息2023-02-08 12:02:05 [scrapy.utils.log] ERROR: pages = [] 线上开启了无头模式，具体配置如下： options = webdriver.ChromeOptions() # 无界面模式 options.add_argument('--headless') options.add_argument('--no-sandbox') options.add_argument(\"--disable-blink-features=AutomationControlled\") options.add_experimental_option('excludeSwitches', ['enable-automation']) options.add_experimental_option('useAutomationExtension', False) driver = webdriver.Chrome(options=options) ","date":"2023年02月08日","objectID":"/2023/02/2/:1:0","tags":["Python","Selenium"],"title":"Selenium设置无头模式，页面自动切换H5模式问题解决","uri":"/2023/02/2/"},{"categories":["踩坑记录"],"content":"问题排查 使用driver.page_source将页面源码打印出来，拷贝到文本中，转成html进行查看后发现，页面竟然变成了H5的页面😱 那么到底是怎么回事呢，在原网站上我又重新试了后发现拖拽下网页窗口大小，网站的布局会随之而变化😳 所以要想解决就需要先事先控制窗口的大小。 ","date":"2023年02月08日","objectID":"/2023/02/2/:2:0","tags":["Python","Selenium"],"title":"Selenium设置无头模式，页面自动切换H5模式问题解决","uri":"/2023/02/2/"},{"categories":["踩坑记录"],"content":"问题解决 为了窗口大小来回变动，就使用最大化窗口进行处理：driver.maximize_window()，然而放到线上去执行的时候，依旧会出问题😅 我就在想我都最大化窗口了，怎么还会变成H5呢，让我百思不得其解。后来就想了下，最大化窗口不行，那要不试下自定义窗口大小呢，然后就改成了：driver.set_window_size(1280, 800)，上线-\u003e执行，竟然成功了✌️ 最后我的程序代码： options = webdriver.ChromeOptions() # 无界面模式 options.add_argument('--headless') options.add_argument('--no-sandbox') options.add_argument(\"--disable-blink-features=AutomationControlled\") options.add_experimental_option('excludeSwitches', ['enable-automation']) options.add_experimental_option('useAutomationExtension', False) driver = webdriver.Chrome(options=options) driver.set_window_size(1280, 800) # 自定义窗口大小 ","date":"2023年02月08日","objectID":"/2023/02/2/:3:0","tags":["Python","Selenium"],"title":"Selenium设置无头模式，页面自动切换H5模式问题解决","uri":"/2023/02/2/"},{"categories":["踩坑记录"],"content":"总结 由于是无头模式，最大化窗口（driver.maximize_window()）并不能确定窗口的大小（有可能最大化后还不能满足我们的需求，比如我这个需求）； 所以为了让我们程序更加准确，可以直接修改窗口大小（driver.set_window_size(1280, 800)），设置成我们需要的大小，这样更加精准无误。 ","date":"2023年02月08日","objectID":"/2023/02/2/:4:0","tags":["Python","Selenium"],"title":"Selenium设置无头模式，页面自动切换H5模式问题解决","uri":"/2023/02/2/"},{"categories":["踩坑记录"],"content":"问题 ","date":"2023年01月31日","objectID":"/2023/01/1/:1:0","tags":["Python"],"title":"ImportError: cannot import name 'get_distribution' from 'pkg_resources'问题解决","uri":"/2023/01/1/"},{"categories":["踩坑记录"],"content":"原因 在使用Docker部署的时候，首先进行了更新pip，更新命令：/usr/local/bin/python -m pip install --upgrade pip 在这里只确保了pip是最新的，从而忽略了setuptools和wheel，虽然仅 pip 就足以从预构建的二进制存档安装，但 setuptools 和 wheel 项目的最新副本有助于确保您也可以从源存档安装。「Python官方文档说明」 ","date":"2023年01月31日","objectID":"/2023/01/1/:2:0","tags":["Python"],"title":"ImportError: cannot import name 'get_distribution' from 'pkg_resources'问题解决","uri":"/2023/01/1/"},{"categories":["踩坑记录"],"content":"解决 将更新命令更改为：/usr/local/bin/python -m pip install --upgrade pip setuptools wheel ","date":"2023年01月31日","objectID":"/2023/01/1/:3:0","tags":["Python"],"title":"ImportError: cannot import name 'get_distribution' from 'pkg_resources'问题解决","uri":"/2023/01/1/"},{"categories":["Jenkins"],"content":"有一些构建任务可能会由于某些不可抗因素导致构建失败，但是重新构建一次就构建成功了，针对这种情况，可以使用Jenkins插件Naginator进行构建失败重试 ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/:0:0","tags":["Jenkins"],"title":"Jenkins构建失败重试","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/"},{"categories":["Jenkins"],"content":"使用Naginator ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/:1:0","tags":["Jenkins"],"title":"Jenkins构建失败重试","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/"},{"categories":["Jenkins"],"content":"安装Naginator插件 ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/:1:1","tags":["Jenkins"],"title":"Jenkins构建失败重试","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/"},{"categories":["Jenkins"],"content":"使用 在构建后操作中选择：Retry build after failure 配置信息 运行结果 构建历史，如果构建失败，则会重试三次 查看最后一次构建历史，可以看到是由Naginator启动的 ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/:1:2","tags":["Jenkins"],"title":"Jenkins构建失败重试","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/"},{"categories":["Jenkins"],"content":"构建后执行脚本-PostBuildScript 在执行完Jenkins构建失败时，想发起报警，通过shell脚本进行编写，然而Jenkins默认只能在构建前执行shell。 当有该需求时，Jenkins的PostBuildScript插件就能够帮助我们实现。 ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/:1:0","tags":["Jenkins"],"title":"Jenkins构建后执行脚本","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"},{"categories":["Jenkins"],"content":"使用步骤 ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/:2:0","tags":["Jenkins"],"title":"Jenkins构建后执行脚本","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"},{"categories":["Jenkins"],"content":"1、安装PostBuildScript插件 ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/:2:1","tags":["Jenkins"],"title":"Jenkins构建后执行脚本","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"},{"categories":["Jenkins"],"content":"2、在Job的构建后操作就可以看到Execute scripts ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/:2:2","tags":["Jenkins"],"title":"Jenkins构建后执行脚本","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"},{"categories":["Jenkins"],"content":"3、支持多种方式的脚本执行 Add generic script file：添加通用的脚本文件 Add Groovy script file: 添加 Groovy 脚本文件 Add Groovy script: 添加Groovy脚本 Add post build step：添加后期构建步骤 4、指定构建结果执行脚本 SUCCESS: 构建成功 UNSTABLE：构建不稳定 FAILURE：构建失败 NOT_BUILT：未构建 ABORTED：构建被终止 只有达到选定的构建结果之一时，才会执行脚本/步骤。使用键盘上的控制键选择多个结果。 ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/:2:3","tags":["Jenkins"],"title":"Jenkins构建后执行脚本","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"},{"categories":["Jenkins"],"content":"实践一下 在Jenkins执行构建失败时，通过shell脚本发送报警 ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/:3:0","tags":["Jenkins"],"title":"Jenkins构建后执行脚本","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"},{"categories":["Jenkins"],"content":"构建操作 ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/:3:1","tags":["Jenkins"],"title":"Jenkins构建后执行脚本","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"},{"categories":["Jenkins"],"content":"构建后操作 ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/:3:2","tags":["Jenkins"],"title":"Jenkins构建后执行脚本","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"},{"categories":["Jenkins"],"content":"执行结果 ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/:3:3","tags":["Jenkins"],"title":"Jenkins构建后执行脚本","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"},{"categories":["Jenkins"],"content":"构建成功的执行结果 ","date":"2022年08月05日","objectID":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/:3:4","tags":["Jenkins"],"title":"Jenkins构建后执行脚本","uri":"/2022/08/jenkins%E6%9E%84%E5%BB%BA%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"},{"categories":["Go笔记"],"content":"Map map是key-value数据结构，又称为字段或者关联数组。 ","date":"2022年07月27日","objectID":"/2022/07/go-map/:0:0","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"基本语法 语法：var map变量名 map[keytype]valuetype var a map[string]string var a map[string]int var a map[int]string var a map[string]map[string]string key的类型 可以是：bool、数字、string、指针、channel，还可以值包含前面几个类型的接口、结构体、数组，通常为int、string slice、map和function不可以当做key的类型，因为这几个没法用==来判断 value的类型 和key基本一样，通常为：数字（整数，浮点数）、string、map、struct //声明一个map var a map[string]string // 在使用map前，需要先make，make的作用个就是给map分配数据空间 a = make(map[string]string, 10) a[\"str1\"] = \"第一个字符串\" a[\"str2\"] = \"第二个字符串\" a[\"str3\"] = \"第三个字符串\" fmt.Println(a) //map[str1:第一个字符串 str2:第二个字符串 str3:第三个字符串] 注意：声明是不会分配内存的，初始化需要make分配内存后才能赋值和使用。 注意事项 map在使用前一定要make map的key是不能重复，如果重复了，则以最后这个key-value为准 map的value是可以相同的 map的key-value是无序的 ","date":"2022年07月27日","objectID":"/2022/07/go-map/:1:0","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"map的使用 方式一： var cities map[string]string fmt.Println(cities) //map[] // 分配一个map空间 cities = make(map[string]string, 10) fmt.Println(cities) //map[] 方式二： // 声明直接make var cities = make(map[string]string) fmt.Println(cities) //map[] 方式三： // 声明直接赋值 var cities map[string]string = map[string]string{ \"city1\": \"成都\", } cities[\"city2\"] = \"深圳\" fmt.Println(cities) //map[city1:成都 city2:深圳] ","date":"2022年07月27日","objectID":"/2022/07/go-map/:2:0","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"map的操作 ","date":"2022年07月27日","objectID":"/2022/07/go-map/:3:0","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"map的增加和更新 map[\"key\"] = value 如果key不存在就是增加，存在则修改。 cities := map[string]string{ \"city1\": \"成都\", } // 添加的key不存在，则新增 cities[\"city2\"] = \"深圳\" fmt.Println(cities) //map[city1:成都 city2:深圳] // 添加的key存在，则修改 cities[\"city1\"] = \"北京\" fmt.Println(cities) //map[city1:北京 city2:深圳] ","date":"2022年07月27日","objectID":"/2022/07/go-map/:3:1","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"map的删除 delete(map, \"key\") delete是一个内置函数，如果key存在，则删除key-value，如果key不存在，不操作，也不会报错。 // 删除的key存在 delete(cities, \"city1\") //删除的key不存在 delete(cities, \"city3\") fmt.Println(cities) //map[city2:深圳] 如果要删除map的所有key，没有专门的方法一次删除，可以遍历一下key，逐个删除 cities := map[string]string{ \"city1\": \"成都\", \"city2\": \"北京\", \"city3\": \"深圳\", } fmt.Println(cities) //map[city1:成都 city2:北京 city3:深圳] for key, _ := range cities { delete(cities, key) } fmt.Println(cities) //map[] 或者map = make(...) make一个新的，让原来的成为垃圾，被gc回收 cities := map[string]string{ \"city1\": \"成都\", \"city2\": \"北京\", \"city3\": \"深圳\", } fmt.Println(cities) //map[city1:成都 city2:北京 city3:深圳] cities = make(map[string]string) fmt.Println(cities) //map[] ","date":"2022年07月27日","objectID":"/2022/07/go-map/:3:2","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"map查找 cities[\"city1\"] 获取map的值时，返回结果有两个，第一个为值，第二个为是否存在，存在返回true，反之false，通过判断第二个值可得到是否存在该key cities := map[string]string{ \"city1\": \"成都\", \"city2\": \"北京\", \"city3\": \"深圳\", } val, ok := cities[\"city4\"] if ok { fmt.Printf(\"有 city1 key 值为%v\\n\", val) } else { fmt.Printf(\"没有 city1 key \\n\") } ","date":"2022年07月27日","objectID":"/2022/07/go-map/:3:3","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"map的遍历 map的遍历使用for-range的结果遍历 cities := map[string]string{ \"city1\": \"成都\", \"city2\": \"北京\", \"city3\": \"深圳\", } for key, value := range cities { fmt.Println(key, value) } /* 结果： city2 北京 city3 深圳 city1 成都 */ ","date":"2022年07月27日","objectID":"/2022/07/go-map/:4:0","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"map的长度 使用len(map) cities := map[string]string{ \"city1\": \"成都\", \"city2\": \"北京\", \"city3\": \"深圳\", } fmt.Println(len(cities)) //3 ","date":"2022年07月27日","objectID":"/2022/07/go-map/:5:0","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"map切片 ","date":"2022年07月27日","objectID":"/2022/07/go-map/:6:0","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"基本介绍 切片的数据类型如果是map，则我们称为slice of map，map切片，这样使用map个数就可以动态变化了 ","date":"2022年07月27日","objectID":"/2022/07/go-map/:6:1","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"使用 // 1. 声明一个map切片 var monsters []map[string]string monsters = make([]map[string]string, 2) //准备放两个信息 // 2. 添加第一个信息 if monsters[0] == nil { monsters[0] = make(map[string]string, 2) monsters[0][\"name\"] = \"Ronin\" monsters[0][\"age\"] = \"18\" } fmt.Println(monsters) //[map[age:18 name:Ronin] map[]] // 添加第二个信息 if monsters[1] == nil { monsters[1] = make(map[string]string, 2) monsters[1][\"name\"] = \"Tommy\" monsters[1][\"age\"] = \"20\" } fmt.Println(monsters) //[map[age:18 name:Ronin] map[age:20 name:Tommy]] // 使用append函数动态的增加map数据 // 1.先定义信息 monster := map[string]string{ \"name\": \"Desire\", \"age\": \"25\", } monsters = append(monsters, monster) fmt.Println(monsters) //[map[age:18 name:Ronin] map[age:20 name:Tommy] map[age:25 name:Desire]] ","date":"2022年07月27日","objectID":"/2022/07/go-map/:6:2","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"map排序 先将map的key放入到切片中 对切片进行排序 遍历切片，然后按照key来输出map的值 // map的排序 map1 := make(map[int]int, 10) map1[10] = 100 map1[2] = 40 map1[5] = 1 map1[3] = 10 map1[9] = 20 // 打印结果，可以看到每次打印的结果顺序都不一样 for k, _ := range map1 { fmt.Println(k) } // 如果按照map的key进行排序输出 // 1. 先将map的key放入到切片中 // 2. 对切片进行排序 // 3. 遍历切片，然后按照key来输出map的值 var keys []int for k, _ := range map1 { keys = append(keys, k) } fmt.Println(keys) // 排序 sort.Ints(keys) fmt.Println(keys) for _, k := range keys { fmt.Printf(\"map1[%v]=%v \\n\", k, map1[k]) } ","date":"2022年07月27日","objectID":"/2022/07/go-map/:7:0","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"map使用细节 map是引用类型，遵守引用类型传递的机制，在一个函数接收map，修改后，会直接修改原来的map map的容量达到后，再想map增加元素，会自动扩容，并不会发生panic，也就是说map能动态的增长键值对 map的value也经常使用struct类型，更适合管理复杂的数据 ","date":"2022年07月27日","objectID":"/2022/07/go-map/:8:0","tags":["Go笔记"],"title":"Go Map","uri":"/2022/07/go-map/"},{"categories":["Go笔记"],"content":"数组 数组可以存放多个同一类型数据。数据也是一种数据类型，在Go中，数组是值类型。 ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:1:0","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"数组的定义 语法：var 数组名 [数组大小]数据类型 注意：定义完数组后，其实数组的各个元素都是有默认值的，默认值为数据类型的零值 var nums [6]int 数组的地址可以通过数据名来获取\u0026nums 数组的第一个元素的地址，就是数组的首地址 数组的各个元素的地址间隔是依据数组的类型决定的，比如int64-\u003e8 int32-\u003e4…… var nums [6]int fmt.Printf(\"nums内存地址：%p \\n\", \u0026nums) //nums内存地址：0xc000018360 fmt.Printf(\"nums[0]内存地址：%p \\n\", \u0026nums[0]) //nums内存地址：0xc000018360 fmt.Printf(\"nums[1]内存地址：%p \\n\", \u0026nums[1]) //nums内存地址：0xc000018368 fmt.Printf(\"nums[2]内存地址：%p \\n\", \u0026nums[2]) //nums内存地址：0xc000018370 fmt.Printf(\"nums[3]内存地址：%p \\n\", \u0026nums[3]) //nums内存地址：0xc000018378 ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:1:1","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"数组的使用 访问数组元素 语法：数组名[下标] var nums [6]int fmt.Println(nums[0]) //0 初始化数组 var numsArray01 [3]int = [3]int{1, 2, 3} var numsArray02 = [3]int{4, 5, 6} var numsArray03 = [...]int{7, 8, 9} // 可以指定元素值对应的下标 var names = [3]string{1: \"tom\", 0: \"tommy\", 2: \"loss\"} fmt.Println(\"numsArray01：\", numsArray01) //numsArray01： [1 2 3] fmt.Println(\"numsArray02：\", numsArray02) //numsArray02： [4 5 6] fmt.Println(\"numsArray03：\", numsArray03) //numsArray03： [7 8 9] fmt.Println(\"names：\", names) //names： [tommy tom loss] 数组遍历 常规遍历 names := [3]string{1: \"tom\", 0: \"tommy\", 2: \"loss\"} for i := 0; i \u003c len(names); i++ { fmt.Printf(\"第%d个元素：%s\\n\", i, names[i]) } /* 遍历结果： 第0个元素：tommy 第1个元素：tom 第2个元素：loss */ for-range结构遍历 for index, value := range names { fmt.Printf(\"第%d个元素：%s\\n\", index, value) } 第一个返回值index是数组的下标 第二个value是在该下标位置的值 index和value 是仅在for循环内部可见的局部变量 遍历数组元素的时候，如果不需要下标index，可以使用_替代 index和value 名称不是固定的，可以自行指定 ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:1:2","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"数组的注意事项 数组是多个相同类型数据的组合，一个数组一旦声明/定义，其长度是固定的，不能动态变化。 数组中的元素可以是任意数据类型，包括值类型和引用类型，但是不能混用。 数组创建后，如果没有赋值，有默认值，默认值为数据类型的零值。 数组的下标是从0开始的，下标必须在指定范围内使用。 Go的数据属于值类型，在默认情况下是值传递，因此会进行值拷贝。数据间不会相互影响。 如果想在其他函数中，修改原来的数组，可以使用引用传递（指针方式）。 长度是数组类型的一部分，在传递函数参数时，需要考虑数组的长度。 ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:1:3","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"切片（slice） ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:2:0","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"基本介绍 切片是数组的一个引用，因此切片是引用类型，在进行传递时，遵守引用传递的机制。 切片的使用和数组类似，遍历切片、访问切片的元素和求切片长度len(slice)都一样。 切片的长度是可以变化的，因此切片是一个可以动态变化的数组。 ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:2:1","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"切片定义 语法：var 切片名 []类型 var a []int ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:2:2","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"切片在内存中的分布 intArr := [...]int{1, 2, 3, 4, 5, 6} // 声明一个切片 // 引用intArr数组的起始下标为1，最后下标为3（不包含3）的值 slice := intArr[1:3] fmt.Println(\"intArr=\", intArr) //intArr= [1 2 3 4 5 6] fmt.Println(\"slice 的元素是：\", slice) //slice 的元素是： [2 3] fmt.Println(\"slice 的元素个数：\", len(slice)) //slice 的元素个数： 2 fmt.Println(\"slice 的容量：\", cap(slice)) //slice 的容量： 5 fmt.Printf(\"intArr[0] 的内存地址: %p\\n\", \u0026intArr[0]) //intArr[0] 的内存地址: 0xc000018360 fmt.Printf(\"intArr[1] 的内存地址: %p\\n\", \u0026intArr[1]) //intArr[1] 的内存地址: 0xc000018368 fmt.Printf(\"intArr[2] 的内存地址: %p\\n\", \u0026intArr[2]) //intArr[2] 的内存地址: 0xc000018370 fmt.Printf(\"intArr[3] 的内存地址: %p\\n\", \u0026intArr[3]) //intArr[3] 的内存地址: 0xc000018378 fmt.Printf(\"intArr[4] 的内存地址: %p\\n\", \u0026intArr[4]) //intArr[4] 的内存地址: 0xc000018380 fmt.Printf(\"intArr[5] 的内存地址: %p\\n\", \u0026intArr[5]) //intArr[5] 的内存地址: 0xc000018388 fmt.Printf(\"slice[0] 的内存地址: %p\\n\", \u0026slice[0]) //slice[0] 的内存地址: 0xc0000aa068 fmt.Printf(\"slice[1] 的内存地址: %p\\n\", \u0026slice[1]) //slice[1] 的内存地址: 0xc000018370 ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:2:3","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"切片使用 方式一 定义一个切片，然后让切片去引用一个已经创建好的数组 intArr := [...]int{1, 2, 3, 4, 5, 6} // 声明一个切片 // 引用intArr数组的起始下标为1，最后下标为3（不包含3）的值 slice := intArr[1:3] 方式二 通过make来创建切片 基本语法：var 切片名 []type = make([]type, len, [cap]) type: 是数据类型 len: 大小 cap: 指定切片容量，可选 通过make方式创建的切片对应的数组是由make底层维护，对外不可见，即只能通过slice去访问各个元素 var slice2 = make([]int, 4, 10) fmt.Println(\"slice2= \", slice2) //slice2= [0 0 0 0] fmt.Println(\"slice2 的大小：\", len(slice2)) //slice2 的大小： 4 fmt.Println(\"slice2 的容量：\", cap(slice2)) //slice2 的容量： 10 方式三 定义一个切片，直接就指定具体数组，使用原理类似make的方式 var slice3 = []int{1, 3, 5} fmt.Println(\"slice3= \", slice3) //slice3= [1 3 5] fmt.Println(\"slice3 的大小：\", len(slice3)) //slice3 的大小： 3 fmt.Println(\"slice3 的容量：\", cap(slice3)) //slice3 的容量： 3 方式一、二的区别 方式一是直接引用数组，这个数组是事先存在的，是可见的 方式二通过make来创建切片，make也会创建一个数组，是由切片在底层进行维护，是不可见的 ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:2:4","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"切片遍历 常规方式遍历 slice4 := []int{1, 2, 3} for i := 0; i \u003c len(slice4); i++ { fmt.Printf(\"第%d个元素：%d\\n\", i, slice4[i]) } for-range遍历 for i, v := range slice4 { fmt.Printf(\"第%d个元素：%d\\n\", i, v) } ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:2:5","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"切片动态追加元素 用append内置函数，可以对切片进行动态追加 slice5 := []int{1, 2, 3} fmt.Println(\"slice5= \", slice5) //slice5= [1 2 3] fmt.Println(\"slice5 的大小：\", len(slice5)) //slice5 的大小： 3 fmt.Println(\"slice5 的容量：\", cap(slice5)) //slice5 的容量： 3 slice5 = append(slice5, 10, 20, 30) fmt.Println(\"slice5= \", slice5) //slice5= [1 2 3 10 20 30] fmt.Println(\"slice5 的大小：\", len(slice5)) //slice5 的大小： 6 fmt.Println(\"slice5 的容量：\", cap(slice5)) //slice5 的容量： 6 // 在切片上追加切片 slice6 := []int{1000, 2000} slice5 = append(slice5, slice6...) fmt.Println(\"slice5= \", slice5) //slice5= [1 2 3 10 20 30 1000 2000] fmt.Println(\"slice5 的大小：\", len(slice5)) //slice5 的大小： 8 fmt.Println(\"slice5 的容量：\", cap(slice5)) //slice5 的容量： 12 切片append操作的底层原理分析： 切片append操作的本质就是对数组扩容 Go底层会创建一个新的数组newArr（安装扩容后的大小） 将slice原来包含的元素拷贝到新的数组newArr slice重新引用到newArr（newArr是由底层来维护的，不可见） ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:2:6","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"切片的拷贝操作 切片使用copy内置函数完成拷贝 slice7 := []int{1, 2, 3, 4, 5} slice8 := make([]int, 10) fmt.Println(\"slice7 = \", slice7) //slice7 = [1 2 3 4 5] fmt.Println(\"slice8 = \", slice8) //slice8 = [0 0 0 0 0 0 0 0 0 0] copy(slice8, slice7) fmt.Println(\"拷贝后的slice8 = \", slice8) //拷贝后的slice8 = [1 2 3 4 5 0 0 0 0 0] ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:2:7","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"切片的注意事项 切片初始化时：var slice = arr[startIndex:endIndex] 说明：从arr数组下标为startIndex，取到下标为endIndex的元素（不含arr[endIndex]） 切片初始化时，不能越界，范围在[0~len(arr)]之间，但是可以动态增长 cap是一个内置函数，用户统计切片的容量，即最大可以存放多少个元素 切片定义完后，还不能使用，因为本身是一个空的，需要让其引用到一个数组，或者make一个空间供切片来使用 切片可以继续切片 用append内置函数，可以对切片进行动态追加 切片使用copy内置函数完成拷贝 切片是引用类型，所在在传递时，遵守引用传递机制 ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:2:8","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"string和slice string底层是一个byte数组，因此string也可以进行切片处理 s := \"Hello World\" fmt.Println(\"s = \", s) //s = Hello World fmt.Println(\"s[4:] = \", s[4:]) //s[4:] = o World string和切片在内存的形式 string是不可变的，不能通过str[0]='z'方式来修改字符串 如果要修改字符串，可以现将string转成[]byte或者[]runne，然后再进行修改，最后再转成string s := \"Hello World\" fmt.Println(\"原始s = \", s) //原始s = Hello World arr := []byte(s) arr[0] = 'z' s = string(arr) fmt.Println(\"更改后的s = \", s) //更改后的s = zello World // 细节：转成[]byte后，可以处理英文和数字，但是不能处理中文 // 原因：[]byte是按照字节来处理的，而一个中文，是3个字节，因此会出现乱码 //arr2 := []byte(s) //arr2[0] = '中' // 编译报错：constant 20013 overflows byte //s = string(arr2) //fmt.Println(\"更改后的s = \", s) // 解决：将string转成[]rune即可，因为[]rune是按字符处理，兼容汉字 arr3 := []rune(s) arr3[0] = '中' // 编译报错：constant 20013 overflows byte s = string(arr3) fmt.Println(\"更改后的s = \", s) //更改后的s = 中ello World ","date":"2022年07月27日","objectID":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/:3:0","tags":["Go笔记"],"title":"Go数组和切片","uri":"/2022/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"},{"categories":["Go笔记"],"content":"基本说明 默认情况下，当发生错误（panic），程序就会退出（崩溃） Go语言不支持传统的try……catch……finally Go中引入的处理方式为：defer panic recover 处理流程：抛出panic异常 –» 在defer中通过recover捕获异常 –» 正常处理 ","date":"2022年07月26日","objectID":"/2022/07/go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:0","tags":["Go笔记"],"title":"Go错误处理机制","uri":"/2022/07/go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["Go笔记"],"content":"使用 func test() { // 使用defer + recover 捕获和处理异常 defer func() { err := recover() // recover 内置函数，可以捕获到异常 if err != nil { fmt.Println(\"err=\", err) } }() num1 := 10 num2 := 0 res := num1 / num2 fmt.Println(\"res=\", res) } func main() { test() fmt.Printf(\"main()结束\") } ","date":"2022年07月26日","objectID":"/2022/07/go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:2:0","tags":["Go笔记"],"title":"Go错误处理机制","uri":"/2022/07/go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["Go笔记"],"content":"自定义错误 使用errors.New和panic内置函数 errorsNew(\"错误说明\")，会返回一个error类型的值，表示一个错误 panic内置函数，接收一个interface{}类型的值（也就是任意值）作为参数。可以接受error类型的变量，输出错误信息，并退出程序 package main import ( \"errors\" \"fmt\" ) func readConf(name string) (err error) { if name == \"config.ini\" { return nil } else { return errors.New(\"文件名输入有误\") } } func main() { err := readConf(\"config.json\") if err != nil { panic(err) // 把异常抛出，如果有异常则会抛出异常并且终止程序 } fmt.Println(\"main()\") // 有异常抛出，则不会执行 } ","date":"2022年07月26日","objectID":"/2022/07/go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:3:0","tags":["Go笔记"],"title":"Go错误处理机制","uri":"/2022/07/go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["Go笔记"],"content":"并行（并发）问题 ","date":"2022年07月24日","objectID":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/:1:0","tags":["Go笔记"],"title":"Go协程并发(并行)资源竞争问题","uri":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/"},{"categories":["Go笔记"],"content":"使用协程实现求n的阶乘 // 定义一个map集合用来存放数据 var MyMap = make(map[int]int, 10) // 求n的阶乘，并把数据存放到MyMap集合 func test2(n int) { res := 1 for i := 1; i \u003c= n; i++ { res *= i } MyMap[n] = res } func main() { // 开启200个协程执行 for i := 1; i \u003c= 200; i++ { go test2(i) } // 遍历map集合 for i, v := range MyMap { fmt.Println(i, v) } } ","date":"2022年07月24日","objectID":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/:1:1","tags":["Go笔记"],"title":"Go协程并发(并行)资源竞争问题","uri":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/"},{"categories":["Go笔记"],"content":"执行结果 ❌报错：并发映射写入 fatal error: concurrent map writes fatal error: concurrent map writes ","date":"2022年07月24日","objectID":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/:1:2","tags":["Go笔记"],"title":"Go协程并发(并行)资源竞争问题","uri":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/"},{"categories":["Go笔记"],"content":"执行图 ","date":"2022年07月24日","objectID":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/:1:3","tags":["Go笔记"],"title":"Go协程并发(并行)资源竞争问题","uri":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/"},{"categories":["Go笔记"],"content":"如何解决 ","date":"2022年07月24日","objectID":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/:2:0","tags":["Go笔记"],"title":"Go协程并发(并行)资源竞争问题","uri":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/"},{"categories":["Go笔记"],"content":"不同协程之间如何通讯 全局变量加锁同步 使用channel（管道） ","date":"2022年07月24日","objectID":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/:2:1","tags":["Go笔记"],"title":"Go协程并发(并行)资源竞争问题","uri":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/"},{"categories":["Go笔记"],"content":"使用全局变量加锁同步解决 因为没有对全局变量 MyMap 加锁，因此会出现资源争夺问题，代码会出现错误：concurrent map writes 解决方案：加入互斥锁 var ( MyMap = make(map[int]uint64, 10) // lock 是一个全局互斥锁 lock sync.Mutex ) func test2(n int) { var res uint64 = 1 for i := 1; i \u003c= n; i++ { res *= uint64(i) } //加锁 lock.Lock() MyMap[n] = res //解锁 lock.Unlock() } func main() { for i := 1; i \u003c= 200; i++ { go test2(i) } // 添加等待时间，等协程执行完毕 time.Sleep(time.Second * 5) lock.Lock() for i, v := range MyMap { fmt.Println(i, v) } lock.Unlock() } 执行流程示意图 ","date":"2022年07月24日","objectID":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/:2:2","tags":["Go笔记"],"title":"Go协程并发(并行)资源竞争问题","uri":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/"},{"categories":["Go笔记"],"content":"使用等待组（sync.WaitGroup）主线程等待协程执行完毕 var ( MyMap = make(map[int]uint64, 10) // lock 是一个全局互斥锁 lock sync.Mutex wg sync.WaitGroup ) func test2(n int) { var res uint64 = 1 for i := 1; i \u003c= n; i++ { res *= uint64(i) } //加锁 lock.Lock() MyMap[n] = res //解锁 lock.Unlock() wg.Done() } func main() { for i := 1; i \u003c= 200; i++ { wg.Add(1) go test2(i) } wg.Wait() lock.Lock() for i, v := range MyMap { fmt.Println(i, v) } lock.Unlock() } ","date":"2022年07月24日","objectID":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/:2:3","tags":["Go笔记"],"title":"Go协程并发(并行)资源竞争问题","uri":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/"},{"categories":["Go笔记"],"content":"使用channel 为什么需要channel 上面使用全局变量等待所有协程全部完成的时间很难确定 如果主线程休眠的时间长了，会加长等待时间，如果短了，可能还有协程处于工作状态，这时也会随主线程的退出而销毁 通过全局变量加锁同步来实现通讯，也并不利于多个协程对全局变量的读写操作 channel实现 定义一个结果channel 计算后的阶乘结果，放入到channel中 最后在从channel取出结果打印出来 func main() { type MyMap map[int]uint64 resChan := make(chan MyMap, 200) var wg sync.WaitGroup for i := 1; i \u003c= 200; i++ { wg.Add(1) go func(n int, resChan chan\u003c- MyMap, wg *sync.WaitGroup) { var res uint64 = 1 for i := 1; i \u003c= n; i++ { res *= uint64(i) } resChan \u003c- MyMap{n: res} wg.Done() }(i, resChan, \u0026wg) } wg.Wait() label: for { select { case res := \u003c-resChan: fmt.Println(res) default: fmt.Println(\"无数据\") break label } } } ","date":"2022年07月24日","objectID":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/:2:4","tags":["Go笔记"],"title":"Go协程并发(并行)资源竞争问题","uri":"/2022/07/go%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98/"},{"categories":["Go笔记"],"content":"channel介绍 channel本质就是一个数据结构-队列 数据是先进先出（FIFO） 线程安全，多goroutine访问时，不需要加锁 channel是有类型的，一个string的channel只能存放string数据类型 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:1:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"channel使用 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:2:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"channel定义/声明 var 变量名 chan 数据类型 var intChan chan int // intChan用于存放int类型 var mapChan chan map[int]string // mapChan用于存放map[int]string类型 var perChan chan Person // 用于存放结构体类型 var perChan2 chan *Person // 用于存放指针类型 var allChan chan interface{} // 用于存放任意数据类型 channel 是引用类型 channel 必须初始化才能写入数据，即make后才能使用 管道是有类型的，intChan 只能写入整数 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:2:1","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"channel初始化 使用make进行初始化 var intChan chan int intChan = make(chan int, 10) fmt.Printf(\"intChan值：%v \\n\", intChan) //intChan值：0xc0000b4000 fmt.Printf(\"intChan本身地址：%p \\n\", \u0026intChan) //intChan本身地址：0xc0000ac018 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:2:2","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"向channel中写入数据 当给channel写入数据时，写入的数量不能超过其容量大小，超过则报错：all goroutines are asleep - deadlock! vat intChan chan int intChan = make(chan int, 3) num:=99 intChan \u003c- 10 intChan \u003c- num // 管道的长度和cap（容量） fmt.Printf(\"intChan的长度：%v\\n\", len(intChan)) // intChan的长度：2 fmt.Printf(\"intChan的容量：%v\\n\", cap(intChan)) // intChan的容量：3 // 再次向channel中写入数据 intChan \u003c- 44 intChan \u003c- 11 // 报错：fatal error: all goroutines are asleep - deadlock! ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:2:3","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"从channel中读取数据 当读取channel数据时，如果管道数据已经全部取出，再取则会报错：all goroutines are asleep - deadlock! var intChan chan int intChan = make(chan int, 3) num := 99 intChan \u003c- 10 intChan \u003c- num fmt.Printf(\"intChan的长度：%v\\n\", len(intChan)) // intChan的长度：2 fmt.Printf(\"intChan的容量：%v\\n\", cap(intChan)) // intChan的容量：3 // 取数据赋值给num2 num2 := \u003c-intChan fmt.Println(\"取出的数据：\", num2) //取出的数据： 10 fmt.Printf(\"intChan的长度：%v\\n\", len(intChan)) // intChan的长度：1 fmt.Printf(\"intChan的容量：%v\\n\", cap(intChan)) // intChan的容量：3 // 继续取 \u003c-intChan \u003c-intChan //fatal error: all goroutines are asleep - deadlock! ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:2:4","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"channel使用注意事项 channel中只能存放指定的数据类型 channel的数据放满后，就不能再放入了 如果从channel取出数据后，可以继续放入 如果channel数据取完了，再取，就会报错：deadlock! ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:2:5","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"channel的遍历和关闭 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:3:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"channel的关闭 使用内置函数close可以关闭channel，当channel关闭后，就不能再向channel写数据了，但是仍然可以从该channel读取数据。 intChan := make(chan int, 3) intChan \u003c- 10 intChan \u003c- 20 close(intChan) //关闭管道 // 关闭管道后不可再写数据 // intChan \u003c- 30 //panic: send on closed channel n1 := \u003c-intChan // 关闭管道后，可以继续读 fmt.Println(n1) //10 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:3:1","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"channel的遍历 channel支持for-range的方式进行遍历，需要注意两点： 在遍历时，如果channel没有关闭，则会出现deadlock!错误 intChan := make(chan int, 100) for i := 0; i \u003c 100; i++ { intChan \u003c- i } for v := range intChan { fmt.Println(\"v = \", v) } // 取完后，会报错：fatal error: all goroutines are asleep - deadlock! 在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历 intChan := make(chan int, 100) for i := 0; i \u003c 100; i++ { intChan \u003c- i } close(intChan) //关闭管道 for v := range intChan { fmt.Println(\"v = \", v) } ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:3:2","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"多路选择和超时 select：进行多路选择 \u003c-time.After(time.Microsecond * 100)：检测超时 package main import ( \"fmt\" \"time\" ) func service() string { return fmt.Sprintf(\"%d\", time.Now()) } func AsyncService() chan string { retCh := make(chan string, 1) go func() { ret := service() fmt.Println(\"returned result.\") retCh \u003c- ret fmt.Println(\"service exited.\") }() return retCh } func main() { select { case ret := \u003c-AsyncService(): fmt.Println(ret) case \u003c-time.After(time.Microsecond * 100): fmt.Println(\"超时\") } } ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:4:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"goroutine和channel结合 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:5:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"案例一 开启一个writeData协程，向管道intChan中写入50个整数 开启一个readData协程，从管道intChan中读取writeData写入的数据 writeData和readData操作的是同一个管道 主线程需要等待writeData和readData协程都完成工作才能退出 func main() { var intChan = make(chan int, 50) var exitChan = make(chan bool, 1) go func(intChan chan int) { for i := 0; i \u003c 50; i++ { intChan \u003c- i fmt.Println(\"write Data写入管道信息 --\u003e\u003e \", i) } close(intChan) //关闭 }(intChan) go func(intChan chan int, exitChan chan bool) { for { v, ok := \u003c-intChan if !ok { break } fmt.Println(\"read Data读取管道信息 --\u003e\u003e \", v) } // 读取完数据，即任务完成 exitChan \u003c- true close(exitChan) }(intChan, exitChan) for { _, ok := \u003c-exitChan if !ok { break } } fmt.Println(\"主线程结束\") } ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:5:1","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"案例二 启动一个协程，将1~2000的数放入到一个channel（numChan）中 启动8个协程，从numChan取出数（n）,并计算1+……+n的值，并存放到resChan 最后8个协程协同完成工作后，再遍历resChan，显示结果 package main import ( \"fmt\" \"sync\" ) func writeNum(ch chan\u003c- int, wg *sync.WaitGroup) { for i := 1; i \u003c= 2000; i++ { ch \u003c- i } close(ch) wg.Done() } func readNum(ch \u003c-chan int, resChan chan\u003c- map[int]int, wg *sync.WaitGroup) { for num := range ch { res := 0 for i := 0; i \u003c= num; i++ { res += i } resChan \u003c- map[int]int{num: res} } wg.Done() } func main() { numChan := make(chan int, 2000) resChan := make(chan map[int]int, 2000) var wg sync.WaitGroup wg.Add(1) go writeNum(numChan, \u0026wg) for i := 0; i \u003c 8; i++ { wg.Add(1) go readNum(numChan, resChan, \u0026wg) } wg.Wait() label: for { select { case v := \u003c-resChan: fmt.Println(v) default: fmt.Println(\"无数据\") break label } } } ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:5:2","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"案例三 要求统计1~200000的数字中，哪些是素数 package main import ( \"fmt\" \"sync\" ) func IsPrime(n int) bool { if n == 1 { return false } //从2遍历到n-1，看看是否有因子 for i := 2; i \u003c n; i++ { if n%i == 0 { //发现一个因子 return false } } return true } func writeNum(ch chan\u003c- int, wg *sync.WaitGroup) { for i := 1; i \u003c= 200000; i++ { ch \u003c- i } close(ch) wg.Done() } func primeNum(ch \u003c-chan int, resChan chan\u003c- int, wg *sync.WaitGroup) { for num := range ch { res := IsPrime(num) if res { resChan \u003c- num } } wg.Done() } func main() { numChan := make(chan int, 200000) primeChan := make(chan int, 200000) var wg sync.WaitGroup wg.Add(1) go writeNum(numChan, \u0026wg) for i := 0; i \u003c 10; i++ { wg.Add(1) go primeNum(numChan, primeChan, \u0026wg) } wg.Wait() label: for { select { case num := \u003c-primeChan: fmt.Println(num) default: break label } } } ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:5:3","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"channel使用细节和注意事项 channel可以声明为只读，或者只写性质 // 1. 默认情况下，管道是双向的 var chan1 chan int // 可读可写 // 2. 声明只写 var chan2 chan\u003c- int //只写 chan2 = make(chan int, 3) chan2 \u003c- 20 //写 // 3. 声明只读 var chan3 \u003c-chan int num2 := \u003c-chan3 // 读 channel只读和只写的最佳时间案例 // 只写 func send(ch chan\u003c- int, exitChan chan struct{}) { for i := 0; i \u003c 10; i++ { ch \u003c- i } close(ch) var a struct{} exitChan \u003c- a } //只读 func recv(ch \u003c-chan int, exitChan chan struct{}) { for { v, ok := \u003c-ch if !ok { break } fmt.Println(v) } var a struct{} exitChan \u003c- a } func main() { var ch chan int ch = make(chan int, 10) exitChan := make(chan struct{}, 2) go send(ch, exitChan) go recv(ch, exitChan) var total = 0 for _ = range exitChan { total++ if total == 2 { break } } fmt.Println(\"主线程结束。。。\") } 使用select可以解决从管道取数据的阻塞问题 func main() { intChan := make(chan int, 10) for i := 0; i \u003c 10; i++ { intChan \u003c- i } stringChan := make(chan string, 5) for i := 0; i \u003c 5; i++ { stringChan \u003c- \"Hello\" + fmt.Sprintf(\"%d\", i) } // 传统的方法再遍历管道时，如果不关闭会阻塞而导致 deadlock // 使用select解决从管道取数据的阻塞问题 label: for { select { case v := \u003c-intChan: fmt.Println(\"从intChan读取的数据：\", v) case v := \u003c-stringChan: fmt.Println(\"从stringChan读取的数据：\", v) default: fmt.Println(\"都取不到数据\") break label } } } goroutine中使用recover，解决协程中出现panic，导致程序崩溃问题 func sayHello() { for i := 0; i \u003c 10; i++ { time.Sleep(time.Second) fmt.Println(\"Hello World\") } } func test() { //可是使用defer + recover捕获异常 defer func() { //捕获test抛出的panic if err := recover(); err != nil { fmt.Println(\"test() 发生错误: \", err) } }() var myMap map[int]string myMap[0] = \"golang\" //panic: assignment to entry in nil map } func main() { //goroutine中使用recover，解决协程中出现panic，导致程序崩溃问题 go sayHello() go test() for i := 0; i \u003c 10; i++ { fmt.Println(\"main() ok=\", i) time.Sleep(time.Second) } } 任务 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:6:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"任务的取消 package main import ( \"fmt\" \"time\" ) func isCancelled(cancelCh chan int) bool { select { case \u003c-cancelCh: return true default: return false } } // 往管道里添加一个int数据，由于只会被一个任务获取到值，故只会取消一个任务 func cancel_1(cancelCh chan int) { cancelCh \u003c- 0 } // 关闭管道，以达到取消全部任务作用 func cancel_2(cancelCh chan int) { close(cancelCh) } func main() { cancelChan := make(chan int, 0) for i := 0; i \u003c 5; i++ { go func(i int, cancelCh chan int) { for { if isCancelled(cancelCh) { break } time.Sleep(time.Second * 5) } fmt.Println(i, \"Done\") }(i, cancelChan) } //cancel_1(cancelChan) // 只会取消一个任务 cancel_2(cancelChan) //全部取消 time.Sleep(time.Second) } ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:7:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"Context上下文 根Context：通过context.Background()创建 子Context：通过context.WithChancel(parentContext)创建 ctx, cancel := context.WithChancel(context.Baceground()) 当前Context被取消时，基于他的子context都会被取消 接收取消通知\u003c-ctx.Done() package main import ( \"context\" \"fmt\" \"time\" ) func isCancelled(ctx context.Context) bool { select { case \u003c-ctx.Done(): return true default: return false } } func main() { ctx, cancel := context.WithCancel(context.Background()) for i := 0; i \u003c 5; i++ { go func(i int, ctx context.Context) { for { if isCancelled(ctx) { break } time.Sleep(time.Second * 5) } fmt.Println(i, \"Cancelled\") }(i, ctx) } cancel() time.Sleep(time.Second) } ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:8:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"只运行一次（单例） 确保在多线程的情况下，只运行一次 package main import ( \"fmt\" \"sync\" \"unsafe\" ) type Singleton struct { } var singleInstance *Singleton var once sync.Once func GetSingletonObj() *Singleton { once.Do(func() { fmt.Println(\"Create Obj\") singleInstance = new(Singleton) }) return singleInstance } func main() { var wg sync.WaitGroup for i := 0; i \u003c 10; i++ { wg.Add(1) go func() { obj := GetSingletonObj() fmt.Printf(\"%x\\n\", unsafe.Pointer(obj)) wg.Done() }() } wg.Wait() } ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:9:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"仅需任意任务完成 package main import ( \"fmt\" \"runtime\" \"time\" ) func runTask(id int) string { time.Sleep(10 * time.Millisecond) return fmt.Sprintf(\"The result is from %d\", id) } func FirstResponse() string { numOfRunner := 10 ch := make(chan string, numOfRunner)// buffChannel防止协程泄漏 for i := 0; i \u003c numOfRunner; i++ { go func(i int) { ret := runTask(i) ch \u003c- ret }(i) } return \u003c-ch } func main() { fmt.Println(\"Before: \", runtime.NumGoroutine()) response := FirstResponse() fmt.Println(response) time.Sleep(time.Second) fmt.Println(\"After: \", runtime.NumGoroutine()) } ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:10:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"所有任务完成 方式一：sync.WaitGroup 方式二：利用channel的CSP的机制 package main import ( \"fmt\" \"runtime\" \"time\" ) func runTask(id int) string { time.Sleep(10 * time.Millisecond) return fmt.Sprintf(\"The result is from %d\", id) } func AllResponse() string { numOfRunner := 10 ch := make(chan string, numOfRunner) // buffChannel防止协程泄漏 for i := 0; i \u003c numOfRunner; i++ { go func(i int) { ret := runTask(i) ch \u003c- ret }(i) } finalRet := \"\" for j := 0; j \u003c numOfRunner; j++ { finalRet += \u003c-ch + \"\\n\" } return finalRet } func main() { fmt.Println(\"Before: \", runtime.NumGoroutine()) response := AllResponse() fmt.Println(response) time.Sleep(time.Second) fmt.Println(\"After: \", runtime.NumGoroutine()) } 使用buffered channel 实现对象池 package main import ( \"errors\" \"fmt\" \"time\" ) type ReusableObj struct { } type ObjPool struct { bufChan chan *ReusableObj //用于缓冲可重用对象 } func NewObjPool(numOfObj int) *ObjPool { objPool := ObjPool{} objPool.bufChan = make(chan *ReusableObj, numOfObj) for i := 0; i \u003c numOfObj; i++ { objPool.bufChan \u003c- \u0026ReusableObj{} } return \u0026objPool } // GetObj 从对象池中获取对象 func (p *ObjPool) GetObj(timeout time.Duration) (*ReusableObj, error) { select { case ret := \u003c-p.bufChan: return ret, nil case \u003c-time.After(timeout): //超时控制 return nil, errors.New(\"time out\") } } // ReleaseObj 放回对象到对象池 func (p *ObjPool) ReleaseObj(obj *ReusableObj) error { select { case p.bufChan \u003c- obj: return nil default: return errors.New(\"overflow\") } } func main() { pool := NewObjPool(10) for i := 0; i \u003c 11; i++ { if v, err := pool.GetObj(time.Second); err != nil { panic(err) } else { fmt.Printf(\"%T\\n\", v) // 如果不放回，当循环达到10次后，再次获取对象则会超时 if err := pool.ReleaseObj(v); err != nil { panic(err) } } } fmt.Println(\"Done\") } sync.Pool对象缓存 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:11:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"sync.Pool对象获取 尝试从私有对象获取 私有对象不存在，尝试从当前Processor的共享池获取 如果当前Processor共享池也是空的，那么就尝试去其他Processor的共享池获取 如果所有子池都是空的，最后就用用户指定的New函数产生一个新的对象返回 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:12:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"sync.Pool对象的放回 如果私有对象不存在则保存为私有对象 如果私有对象存在，放入到当前Processor子池的共享池中 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:13:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"sync.Pool使用 pool := \u0026sync.Pool{ New: func() interface{} { return 100 }, } v := pool.Get().(int) //取数据并做断言 ... pool.Put(3) // 放数据 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:14:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"使用实例 pool := \u0026sync.Pool{ New: func() interface{} { fmt.Println(\"Create a new object.\") return 100 }, } v := pool.Get().(int) //取数据并做断言 fmt.Println(v) pool.Put(3) // 放数据 runtime.GC() // GC 会清除sync.pool中缓存的对象 v1, _ := pool.Get().(int) fmt.Println(v1) v2, _ := pool.Get().(int) fmt.Println(v2) /* 不使用GC清除结果： Create a new object. 100 3 Create a new object. 100 使用GC清除sync.pool中缓存的对象结果： Create a new object. 100 Create a new object. 100 Create a new object. 100 */ 在协程中使用 pool := \u0026sync.Pool{ New: func() interface{} { fmt.Println(\"Create a new object.\") return 100 }, } pool.Put(100) pool.Put(100) pool.Put(100) var wg sync.WaitGroup for i := 0; i \u003c 10; i++ { wg.Add(1) go func(id int) { fmt.Println(pool.Get()) wg.Done() }(i) } wg.Wait() /* 结果： 100 100 100 Create a new object. 100 Create a new object. 100 Create a new object. 100 Create a new object. 100 Create a new object. 100 Create a new object. 100 Create a new object. 100 */ ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:14:1","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"sync.Pool总结： 适用于通过复用，降低复杂对象的创建和GC代价 协程安全，会有锁的开销 生命周期受GC影响，不适合于做连接池等，需自己管理生命周期的资源的池化 ","date":"2022年07月23日","objectID":"/2022/07/go-channel%E7%AE%A1%E9%81%93/:15:0","tags":["Go笔记"],"title":"Go channel（管道）、任务和sync","uri":"/2022/07/go-channel%E7%AE%A1%E9%81%93/"},{"categories":["Go笔记"],"content":"进程和线程 进程就是程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位 线程是进程的一个执行实例，是程序执行的最小单位，它是比进程更小的能独立运行的基本单位 一个进程可以创建和销毁多个线程，同一个进程中的多个线程可以并发执行 一个程序至少有一个进程，一个进程至少有一个线程 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:1:0","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"并发和并行 多线程程序在单核上运行，就是并发 多线程程序在多核上运行，就是并行 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:2:0","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"并发 因为是在一个CPU上，比如有10个线程，每个线程执行10毫秒（进行轮训操作），从人的角度看，好像这10个线程都在运行，但是从微观上看，在某一时间点看，其实只有一个线程在执行，这就是并发 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:2:1","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"并行 因为是在多个CPU上（比如有10个CPU），比如有10个线程，每个线程执行10毫秒（各自在不同CPU上执行），从人的角度看，这10个线程都在运行，但是从微观上看，在某一个时间点看，也同时有10个线程在执行，这就是并行 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:2:2","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"Go协程和主线程 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:3:0","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"Go主线程 一个Go线程上，可以起多个协程，可以理解为，协程是轻量级的线程（编译器做的优化） ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:3:1","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"Go协程的特点 有独立的栈空间 共享程序堆空间 调度由用户控制 协程是轻量级的线程 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:3:2","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"示例 // 每隔1秒输出 func test() { for i := 1; i \u003c= 5; i++ { fmt.Println(\"Hello,World\" + strconv.Itoa(i)) time.Sleep(time.Second) } } func main() { go test() //开启了一个协程 for i := 1; i \u003c= 5; i++ { fmt.Println(\"（main）Hello,World\" + strconv.Itoa(i)) time.Sleep(time.Second) } } 结果 （main）Hello,World1 Hello,World1 Hello,World2 （main）Hello,World2 （main）Hello,World3 Hello,World3 （main）Hello,World4 Hello,World4 Hello,World5 （main）Hello,World5 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:3:3","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"执行流程图 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:3:4","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"结论 主线程是一个物理线程，直接作用在CPU上，是重量级的，非常耗费CPU资源。 协程从主线程开启的，是轻量级的线程，是逻辑态。对资源消耗相对小。 Go的协程机制是重要的特点，可以轻松的开启上万个协程。 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:3:5","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"MPG模式 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:4:0","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"MPG模式基本介绍 M: 操作系统的主线程（物理线程） P: 协程执行需要的上下文 G: 协程 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:4:1","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"MPG模式运行的状态1 当前程序有三个M，如果三个M都在一个CPU运行，就是并发，如果在不同的CPU运行就是并行 M1、M2、M3正在执行一个G，M1的协程队列有3个，M2的协程队列有3个，M3协程队列有2个 从上图可以看到：Go的协程是轻量级的线程，是逻辑态的，Go可以容易的起上万个协程 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:4:2","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"MPG模式运行的状态2 分两部分看 原来的情况是M0主线程正在执行G0协程，另外有三个协程在队列等待 如果G0协程阻塞，比如读取文件或者数据库操作等 这时就会创建M1主线程（也可能是从已有的线程池中取出M1），并且将等待的3个协程挂到M1下开始执行，M0的主线程下的G0任然继续执行 这样的MPG调度模式，既可以让G0执行，同样也不会让队列的其他协程一直阻塞，仍然可以并发/并行执行 等到G0不阻塞的，M0会被放到空闲的主线程继续执行（从已有的线程池中取），同时G0又会被唤醒 ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:4:3","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Go笔记"],"content":"设置Go运行的CPU数 为了充分利用CPU优势，可以在Golang程序中，设置运行的CPU数目 // 获取当前系统的CPU数量 num := runtime.NumCPU() // 设置运行go程序可同时执行的最大CPU数 runtime.GOMAXPROCS(num) fmt.Println(\"当前系统CPU数量：\", num) //当前系统CPU数量： 8 go1.8后，默认程序运行在多个核上，可以不用设置 go1.8前，需要设置，可以更高效的利用CPU ","date":"2022年07月22日","objectID":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/:5:0","tags":["Go笔记"],"title":"Go-goroutine协程","uri":"/2022/07/goroutine%E5%8D%8F%E7%A8%8B/"},{"categories":["Jenkins"],"content":"前言 📍pipenv是Python官方推荐的包管理工具。 📍在使用Python环境，基本上都是使用虚拟环境进行处理的。 📍在Jenkins任务shell中使用常用的方式却无法使用pipenv虚拟环境😤 🩸那么如何解决这个问题呢❓ ","date":"2022年07月15日","objectID":"/2022/07/jenkins%E4%BB%BB%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8pipenv/:1:0","tags":["Jenkins"],"title":"Jenkins任务中使用Pipenv","uri":"/2022/07/jenkins%E4%BB%BB%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8pipenv/"},{"categories":["Jenkins"],"content":"探索在本地pipenv使用流程 ✍️pipenv使用指南 安装pipenv包 pip3 install pipenv 创建pipenv虚拟环境 # 指定Python版本 pipenv --python 3.10 进入虚拟环境 # 激活当前项目的虚拟环境 pipenv shell 虚拟环境存放路径 /Users/`USER`/.local/share/virtualenvs/ 虚拟环境文件夹规则 前缀为创建虚拟环境时的文件夹名，后面部分为随机生成：python_file-ZSRTT-ad 查找此文件夹可使用 # 通过当前任务名，查询虚拟环境文件夹名称 ➜ ~ echo $(ls $HOME/.local/share/virtualenvs | grep \"python_file-\") python_file-ZSRTT-ad 进入到虚拟环境后，查看当前系统环境变量：env PATH环境变量：PATH=/Users/USER/.local/share/virtualenvs/python_file-ZSRTT-ad/bin:... VIRTUAL_ENV变量（启动虚拟环境变量后新增的）：VIRTUAL_ENV=/Users/USER/.local/share/virtualenvs/python_file-ZSRTT-ad 通过查看系统环境变量，可以得到结论 使用虚拟环境后，会自动在环境变量中增加一个变量VIRTUAL_ENV，值为虚拟环境变量路径 在PATH环境变量中，增加了虚拟环境的bin目录 VIRTUAL_ENV=\"虚拟环境路径\" PATH=$VIRTUAL_ENV:$PATH ","date":"2022年07月15日","objectID":"/2022/07/jenkins%E4%BB%BB%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8pipenv/:2:0","tags":["Jenkins"],"title":"Jenkins任务中使用Pipenv","uri":"/2022/07/jenkins%E4%BB%BB%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8pipenv/"},{"categories":["Jenkins"],"content":"在Jenkins中实践 创建一个名为py3.10的任务 在构建步骤中添加shell # 初始化虚拟环境 pipenv --python 3.10 # 获取当前任务的虚拟环境路径 virName=$(ls $HOME/.local/share/virtualenvs | grep \"$JOB_NAME-\") # 设置虚拟环境临时环境变量 export VIRTUAL_ENV=$HOME/.local/share/virtualenvs/$virName # 把bin加入到path环境变量中 export PATH=${VIRTUAL_ENV}/bin:$PATH # 检查当前python版本 python3 --version 构建，查看打印的python版本是否为3.10 成功了✌️ ","date":"2022年07月15日","objectID":"/2022/07/jenkins%E4%BB%BB%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8pipenv/:3:0","tags":["Jenkins"],"title":"Jenkins任务中使用Pipenv","uri":"/2022/07/jenkins%E4%BB%BB%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8pipenv/"},{"categories":["Jenkins"],"content":"优化构建步骤中的shell 从上面的shell可以看到，每次构建一个新的项目，都需要写五行shell脚本，总是做重复性的工作，对于这一块进行了优化，如下： 把重复性的shell单独存放在一个文件(initPipenv.sh)中，存放在/tmp文件夹下，通过传递参数执行 #! /bin/bash # Author: Joker-desire # Date: 2022-07-15 initPipfile() { echo \"Init python virtual env\" # 参数1：python版本 if [ -f \"Pipfile\" ]; then echo \"Python virtual env is existed\" else echo \"Start build python virtual env\" pipenv --python $1 fi } getVirtName() { # 参数1: 虚拟环境名称，实际就是Jenkins任务名 # 通过当前任务名，查询虚拟环境文件夹名称 echo $(ls $HOME/.local/share/virtualenvs | grep \"$1-\") } addEnv() { echo \"Add temporary system env variables\" # 设置虚拟环境临时环境变量 export VIRTUAL_ENV=$HOME/.local/share/virtualenvs/$1 # 把bin加入到path环境变量中 export PATH=${VIRTUAL_ENV}/bin:$PATH } main() { echo \"come into workspace\" cd $3 py=$1 jobName=$2 initPipfile $py virtName=`getVirtName $jobName` addEnv $virtName # 检查当前python版本 python3 --version } # 参数1 python版本 # 参数2 Jenkins任务名称 $JOB_NAME # 参数3 Jenkins Job文件夹路径 main $1 $2 $3 在构建shell中，直接执行此shell脚本即可 # 参数1：python版本 # 参数2：当前Jenkins任务名称 # 参数3：当前的路径 . /tmp/initPipenv.sh \"3.10\" $JOB_NAME `pwd` 构建，输出结果和上面一样 每次如果有新的Jenkins py任务，就可以直接在构建shell中加一行执行initPipenv.sh即可使用虚拟环境 ‼️需要注意执行shell脚本的方式，需要使用.执行shell ","date":"2022年07月15日","objectID":"/2022/07/jenkins%E4%BB%BB%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8pipenv/:4:0","tags":["Jenkins"],"title":"Jenkins任务中使用Pipenv","uri":"/2022/07/jenkins%E4%BB%BB%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8pipenv/"},{"categories":["Go笔记"],"content":"Go语言标准库文档中文版 ","date":"2022年07月14日","objectID":"/2022/07/go%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/:0:0","tags":["Go笔记"],"title":"Go常用的函数","uri":"/2022/07/go%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["Go笔记"],"content":"字符串中常用的函数 统计字符串的长度，按字节：len(str) //统计字符串的长度，按字节 s1 := \"Hello World\" t.Logf(\"s1的长度为：%v\", len(s1)) //s1的长度为：11 s2 := \"Hello 小明\" // golang的编码统一为utf-8(ASCII的字符（字母和数字）占一个字节，汉字占3个字节) t.Logf(\"s2的长度为：%v\", len(s2)) // s2的长度为：12 字符串遍历，同时处理有中文的问题：r := []rune(str) //字符串遍历，同时处理有中文的问题 s3 := \"Hello World！\" for _,v := range []rune(s3) { t.Log(string(v)) } /* 打印结果 function_test.go:15: H function_test.go:15: e function_test.go:15: l function_test.go:15: l function_test.go:15: o function_test.go:15: function_test.go:15: W function_test.go:15: o function_test.go:15: r function_test.go:15: l function_test.go:15: d function_test.go:15: ！ */ 字符串转整数：i := strconv.Atoi(\"12\") // 字符串转整数 i, _ := strconv.Atoi(\"12\") t.Logf(\"i:的值为：%v, 类型为%T\", i, i) //i:的值为：12, 类型为int 整数转字符串：str = strconv.Itoa(12345) //整数转字符串 s4 := strconv.Itoa(12345) t.Logf(\"s4的值为：%v, 类型为%T\", s4, s4) //s4的值为：12345, 类型为string 字符串转[]byte：var bytes = []byte(\"hello go\") // 字符串转[]byte var bytes = []byte(\"Hello go\") t.Logf(\"bytes的值为：%v, 类型为%T\", bytes, bytes) //bytes的值为：[72 101 108 108 111 32 103 111], 类型为[]uint8 []byte转字符串：str := string([]byte{97, 98, 99}) //[]byte转字符串 s5 := string([]byte{72, 101, 108, 108, 111, 32, 103, 111}) t.Logf(\"s5的值为：%v, 类型为%T\", s5, s5) //s5的值为：Hello go, 类型为string 10进制转2,8,16进制：str := strconv.FormatInt(123, 2) // 10进制转2,8,16进制 s6 := strconv.FormatInt(123, 2) t.Logf(\"123转2进制：%v\", s6) //123转2进制：1111011 s7 := strconv.FormatInt(123, 8) t.Logf(\"123转8进制：%v\", s7) //123转8进制：173 s8 := strconv.FormatInt(123, 16) t.Logf(\"123转16进制：%v\", s8) //123转16进制：7b 查找子串是否在指定的字符串中：strings.Contains(\"Hello World!\", \"ll\") // 查找子串是否在指定的字符串中 res := strings.Contains(\"Hello World!\", \"ll\") t.Log(res) // true 统计一个字符串有几个指定的子串：strings.Count(\"ceheese\", \"e\") //统计一个字符串有几个指定的子串 count := strings.Count(\"Hello World!\", \"l\") t.Log(count) //3 不区分大小写的字符串比较（==是区分大小写的）：fmt.Println(strings.EqualFold(\"abc\", \"ABC\")) // 不区分大小写的字符串比较（==是区分大小写的） fmt.Println(strings.EqualFold(\"abc\", \"ABC\")) //true 返回子串在字符串第一次出现的index值，如果没有返回-1：strings.index(\"NLT_abc\", \"abc\") //返回子串在字符串第一次出现的index值，如果没有返回-1 fmt.Println(strings.Index(\"NLT_abc\", \"abc\")) //4 返回子串在字符串最后一次出现的index，如果没有返回-1：strings.LastIndex(\"go golang\", \"go\") //返回子串在字符串最后一次出现的index，如果没有返回-1 fmt.Println(strings.LastIndex(\"go golang\", \"go\")) //3 将指定的子串替换成另外一个子串：strings.Replace(\"go go hell\", \"go\", \"golang\", n) n: 可以指定希望替换几个，如果n=-1表示全部替换 //将指定的子串替换成另外一个子串 fmt.Println(strings.Replace(\"go go hell\", \"go\", \"golang\", -1)) //golang golang hell 按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组：strings.Split(\"hello, work, ok\", \",\") //按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组 fmt.Println(strings.Split(\"hello, work, ok\", \",\")) //[hello work ok] 将字符串的字母进行大小写的转换：转小写：strings.ToLower(\"Go\") 转大写： strings.ToUpper(\"Go\") //将字符串的字母进行大小写的转换 fmt.Println(strings.ToLower(\"Go\")) //go fmt.Println(strings.ToUpper(\"Go\")) //GO 将字符串左右两边的空格去掉：strings.TrimSpace(\" tn \") //将字符串左右两边的空格去掉 fmt.Println(strings.TrimSpace(\" tn \")) //tn 将字符串左右两边指定的字符去掉：strings.Trim(\"! hello !\", \"!\") //将字符串左右两边指定的字符去掉 fmt.Println(strings.Trim(\"!hello!\", \"!\")) //hello 将字符串左边指定的字符去掉：strings.TrimLeft(\"! hello !\", \"!\") //将字符串左边指定的字符去掉 fmt.Println(strings.TrimLeft(\"!hello!\", \"!\")) //hello! 将字符串右边指定的字符去掉：strings.TrimRight(\"! hello !\", \"!\") //将字符串右边指定的字符去掉 fmt.Println(strings.TrimRight(\"!hello!\", \"!\")) //!hello 判断字符串是否以指定的字符串开头：strings.HasPrefix(\"ftp://192.168.0.0.1\", \"ftp\") //判断字符串是否以指定的字符串开头 fmt.Println(strings.HasPrefix(\"ftp://192.168.0.0.1\", \"ftp\")) //true 判断字符串是否以指定的字符串结束：strings.HasSuffix(\"NLT_ABC.png\", \".png\") // 判断字符串是否以指定的字符串结束 fmt.Println(strings.HasSuffix(\"NLT_ABC.png\", \".png\")) //true ","date":"2022年07月14日","objectID":"/2022/07/go%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/:1:0","tags":["Go笔记"],"title":"Go常用的函数","uri":"/2022/07/go%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["Go笔记"],"content":"时间和日期相关函数 time.Time类型，用于表示时间 now := time.Now() fmt.Printf(\"type: %T，val = %v\\n\", now, now) //type: time.Time，val = 2022-07-14 17:00:12.930889 +0800 CST m=+0.001793251 获取当前时间的方法：time.Now() fmt.Println(time.Now()) //2022-07-14 17:01:01.243621 +0800 CST m=+0.002719584 获取其他的日期信息 now := time.Now() fmt.Println(\"当前年：\", now.Year()) // 当前年： 2022 fmt.Println(\"当前月：\", now.Month()) //当前月： July fmt.Println(\"当前日：\", now.Day()) //当前日： 14 fmt.Println(\"当前星期：\", now.Weekday()) //当前星期： Thursday fmt.Println(\"当前小时：\", now.Hour()) //当前小时： 17 fmt.Println(\"当前分钟：\", now.Minute()) //当前分钟： 4 fmt.Println(\"当前秒：\", now.Second()) //当前秒： 58 格式化日期时间 方式一：使用Printf or SPrintf 日期字符串各个数字是固定的，必须这样写 //当前年月日 2022-7-14 17:17:16 fmt.Printf(\"当前年月日 %d-%d-%d %d:%d:%d \\n\", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()) dateStr := fmt.Sprintf(\"当前年月日 %d-%d-%d %d:%d:%d \\n\", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()) fmt.Println(dateStr) //当前年月日 2022-7-14 17:17:16 方式二：使用Format格式化 日期字符串各个数字可以自由的组合 fmt.Println(now.Format(\"2006/01/02 15:04:05\")) //2022/07/14 17:21:12 fmt.Println(now.Format(\"2006-01-02\")) //2022-07-14 fmt.Println(now.Format(\"20060102\")) //20220714 fmt.Println(now.Format(\"15:04:05\")) //17:21:12 内置的常量 // time内置的时间常量 const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) // 星期常量 const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) // 月份常量 const ( January Month = 1 + iota February March April May June July August September October November December ) 休眠：time.Sleep time.Sleep(time.Millisecond * 1500) //休眠1.5s 获取当前Unix时间戳和UnixNano时间戳 作用：可以获取随机数字 fmt.Printf(\"unix时间戳=%v unixnano时间戳=%v \\n\", now.Unix(), now.UnixNano()) //unix时间戳=1657790593 unixnano时间戳=1657790593798028000 ","date":"2022年07月14日","objectID":"/2022/07/go%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/:2:0","tags":["Go笔记"],"title":"Go常用的函数","uri":"/2022/07/go%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["Go笔记"],"content":"内置函数 len：用来求长度，比如string、array、slice、map、channel new：用来分配内存，主要用来分配值类型，比如：int、float32、struct……返回的是指针 make：用来分配内存，主要用来分配引用类型，比如：chan、map、slice ","date":"2022年07月14日","objectID":"/2022/07/go%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/:3:0","tags":["Go笔记"],"title":"Go常用的函数","uri":"/2022/07/go%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["Jenkins"],"content":"Jenkins参数化构建 ","date":"2022年07月13日","objectID":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/:1:0","tags":["Jenkins"],"title":"Jenkins参数化构建与触发","uri":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/"},{"categories":["Jenkins"],"content":"创建一个带参数的任务 勾选参数化构建 添加选项参数 字符参数 文本参数 文件参数 ","date":"2022年07月13日","objectID":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/:1:1","tags":["Jenkins"],"title":"Jenkins参数化构建与触发","uri":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/"},{"categories":["Jenkins"],"content":"获取参数信息 ","date":"2022年07月13日","objectID":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/:1:2","tags":["Jenkins"],"title":"Jenkins参数化构建与触发","uri":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/"},{"categories":["Jenkins"],"content":"构建带参数化的任务 ","date":"2022年07月13日","objectID":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/:1:3","tags":["Jenkins"],"title":"Jenkins参数化构建与触发","uri":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/"},{"categories":["Jenkins"],"content":"构建结果 注：文件参数，则会上传到当前的工作空间 ","date":"2022年07月13日","objectID":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/:1:4","tags":["Jenkins"],"title":"Jenkins参数化构建与触发","uri":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/"},{"categories":["Jenkins"],"content":"Jenkins任务触发 在实际工作总结，经常会遇到，执行完任务1，然后再执行任务2。 像这种的连续触发任务，可以在任务1中添加构建后操作-\u003e构建其他工程 ","date":"2022年07月13日","objectID":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/:2:0","tags":["Jenkins"],"title":"Jenkins参数化构建与触发","uri":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/"},{"categories":["Jenkins"],"content":"构建其他工程配置 填写要构建的项目名称 选择什么时候触发 ","date":"2022年07月13日","objectID":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/:2:1","tags":["Jenkins"],"title":"Jenkins参数化构建与触发","uri":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/"},{"categories":["Jenkins"],"content":"任务详情展示效果 ","date":"2022年07月13日","objectID":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/:2:2","tags":["Jenkins"],"title":"Jenkins参数化构建与触发","uri":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/"},{"categories":["Jenkins"],"content":"构建效果 构建任务1 任务1构建完成后，如果构建稳定则自动构建任务2 在任务1的日志中，可以看到成功的触发新构建 在任务2的日志中，第一行可以看到任务2是由上游项目第2次构建启动的 ","date":"2022年07月13日","objectID":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/:2:3","tags":["Jenkins"],"title":"Jenkins参数化构建与触发","uri":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/"},{"categories":["Jenkins"],"content":"Jenkins参数化任务触发 当任务1中有构建后需要传递给任务2的参数时（或者任务2需要传递参数时），要想实现带参数构建，需要借助一个Jenkins插件：Parameterized Trigger 在任务1中，将执行完毕的参数保存在profile.txt文件中 因为终端shell执行完毕后变量都会回收，所以不能够将变量直接传递给任务2，需要将其写入到文件中然后以文件的形式传递，在构建的shell脚本中，添加一行写入文件 echo \"env=$env\" \u003e profile.txt 在任务1中进行更改构建其他工程的方式，选择Trigger parameterized build on other projects 进行配置参数 在任务2中接收参数 运行任务1 任务2自动触发，获取到参数 ","date":"2022年07月13日","objectID":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/:3:0","tags":["Jenkins"],"title":"Jenkins参数化构建与触发","uri":"/2022/07/jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%A7%A6%E5%8F%91/"},{"categories":["Go笔记"],"content":"Go包 ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:1:0","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"包的基本概念 go的每一个文件都是属于一个包的，也就是说go是以包的形式来管理文件和项目目录结构的 ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:1:1","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"包的三大作用 区分相同名字的函数、变量等标识符 当程序文件很多时，可以很好的管理项目 控制函数、变量等访问范围，即作用域 ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:1:2","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"包的使用 打包基本语法 package util 导包基本语法 import \"包的路径\" 注意事项 在给一个文件打包时，该包对应一个文件夹 当一个文件要使用其他包函数或变量时，需要先引入对应的包 为了让其他包的文件，可以访问到本包的函数，则该函数名的首字母需要大写 func Call(...){ ... } package指令在文件第一行，然后是import指令 package error import ( \"errors\" \"fmt\" \"strconv\" \"testing\" ) 在访问其他包函数变量时，其语法是：包名.函数名 m := cm.CreateConcurrentMap(99) m.Set(cm.StrKey(\"key\"), 10) t.Log(m.Get(cm.StrKey(\"key\"))) 如果包名较长，Go支持给包取别名，注意细节：取别名后，原来的包名就不能使用了 import ( cm \"github.com/easierway/concurrent_map\" \"testing\" ) 在同一包下，不能有相同的函数名。 如果要编译成一个可执行程序文件，就需要将这个包声明为main，即package main这个就是一个语法规范，如果是写一个库，包名可以自定义 ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:1:3","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"Go函数 为完成某一功能的程序执行（语句）的集合，称为函数。 在Go中，函数分为：自定义函数、系统函数 ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:2:0","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"基本语法 func 函数名 (形参列表) (返回值列表) { 执行语句... return 返回值列表 } 形参列表：表示函数的输入 函数中的语句：表示为了实现某一功能代码块 函数可以有返回值，也可以没有 ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:2:1","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"示例 func compute(a int, b int, operator string) int { var result int switch operator { case \"+\": result = a + b case \"-\": result = a - b case \"*\": result = a * b case \"/\": result = a / b default: panic(\"运算符错误\") } return result } ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:2:2","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"函数参数的传递方式 值传递：基本数据类型int系列、float系列、bool、string、数组和结构体struct 引用传递：指针、slice切片、map、管道chan、interface等 不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的数据大小，数据越大，效率越低。 ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:2:3","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"变量作用域 函数内部声明/定义的变量叫局部变量，作用域仅限于函数内部 函数外部声明/定义的变量叫全局变量，作用域在整个包都有效，如果其首字母为大写，则作用域在整个程序有效 如果变量是在一个代码块，比如for/if中，那么这个变量的作用域就在改代码块 ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:2:4","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"函数注意事项 函数的形参列表可以是多个，返回值列表也可以是多个 形参列表和返回值列表的数据类型可以是值类型和引用类型 函数的命名遵循标识符命名规范，首字母不能是数字，首字母大写该函数可以被本包文件和其他包文件使用，类似public，首字母小写，只能被本包文件使用，其他包文件不能使用，类似private 函数中的变量是局部的，函数外不生效 基本数据类型和数组默认都是值传递的，即进行值拷贝。在函数内修改，不会影响到原来的值 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址\u0026，函数内以指针的方式操作变量。从效果上看类似引用。 Go函数不支持重载 在Go中，函数也是一种数据类型，可以赋值给一个变阿玲，则该变量就是一个函数类型的变量了。通过该变量可以对函数调用。 函数既然是一种数据类型，因此在Go中，函数可以作为形参，并且调用 为了简化数据类型定义，Go支持自定义数据类型 基本语法：type 自定义数据类型名 数据类型 // 相当于一个别名 支持函数返回值命名 func call(n1 int, n2 int) (sum int, sub int) { sum = n1 + n2 sub = n1 - n2 return } 使用_表示符，忽略返回值 func TestFunc(t *testing.T) { sum, _ := call(1, 2) fmt.Println(sum) } Go支持可变参数 args是slice，通过args[index]可以访问到各个值 如果一个函数的形参列表中有可变参数，则可变参数需要放在形参列表最后 // 支持0到多个参数 func call2(args ...int) int { sum := 0 for _, arg := range args { sum += arg } return sum } // 支持1到多个参数 func call3(n1 int, args ...int) int { sum := n1 for _, arg := range args { sum += arg } return sum } func TestFunc(t *testing.T) { println(call2(1, 2, 3, 4)) println(call3(10, 1, 2, 3, 4)) } ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:2:5","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"init函数 每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前被调用 package main import \"fmt\" func init() { fmt.Println(\"main init...\") } func main() { fmt.Println(\"main ...\") } ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:3:0","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"注意细节 如果一个文件同时包含全局变量定义，init函数和main函数，则执行的流程是变量定义-\u003einit函数-\u003emain函数 init函数最主要的作用，就是完成一些初始化的工作 ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:3:1","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"匿名函数 Go支持匿名函数，如果我们某个函数只是希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用。 ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:4:0","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"使用方式1 在定义匿名函数时就直接调用 result := func(a int, b int) int { return a + b }(1, 2) fmt.Println(result) ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:4:1","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"使用方式2 将匿名函数赋给一个变量（函数变量），在通过该变量来调用匿名函数 sum := func(a int, b int) int { return a + b } fmt.Println(sum(1, 2)) ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:4:2","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"全局匿名函数 如果将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序有效 ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:4:3","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"闭包 闭包就是一个函数和与其相关的引用环境组合的一个整体（实体） func AddUpper() func(int) int { var n int = 30 return func(x int) int { n = n + x return n } } func main() { f := AddUpper() //返回一个闭包 fmt.Println(f(1)) //31 fmt.Println(f(2)) //33 fmt.Println(f(3)) //36 } ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:5:0","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"defer延时机制 在函数中，程序员经常需要创建资源（比如：数据库连接、文件句柄、锁等），为了在函数执行完毕后，及时的释放资源，Go的设计者提供了defer（延时机制），类似于finally。 func TestDefer(t *testing.T) { defer func() { //匿名函数 t.Log(\"Clear resources.\") }() fmt.Println(\"Started\") panic(\"Fatal error\") //抛出异常，defer仍会执行 } ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:6:0","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"细节说明 当go执行到一个defer时，不会立即执行defer后的语句，而是将defer后的语句压入到一个栈中，然后继续执行函数下一个语句 当函数执行完毕后（或者抛出异常后），在从defer栈中，一次从栈顶取出语句执行（注：遵守栈先入后出的机制） 在defer将语句放入到栈时，也会将相关的值拷贝同时入栈 ","date":"2022年07月09日","objectID":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/:6:1","tags":["Go笔记"],"title":"Go函数和方法","uri":"/2022/07/go%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"},{"categories":["Go笔记"],"content":"顺序控制 程序从上到下逐行地执行，中间没有任何判断和跳转。 ","date":"2022年07月09日","objectID":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:1:0","tags":["Go笔记"],"title":"Go流程控制","uri":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Go笔记"],"content":"分支控制 分支控制有三种：单分支、双分支和多分支 ","date":"2022年07月09日","objectID":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:0","tags":["Go笔记"],"title":"Go流程控制","uri":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Go笔记"],"content":"单分支 var age int fmt.Println(\"请输入年龄：\") fmt.Scanln(\u0026age) if age \u003e 18{ fmt.Println(\"你已成年\") } ","date":"2022年07月09日","objectID":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:1","tags":["Go笔记"],"title":"Go流程控制","uri":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Go笔记"],"content":"双分支 if age \u003e 18{ fmt.Println(\"你已成年\") } else { fmt.Println(\"未成年\") } ","date":"2022年07月09日","objectID":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:2","tags":["Go笔记"],"title":"Go流程控制","uri":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Go笔记"],"content":"多分支 if score == 100{ fmt.Println(\"很优秀\") } else if score \u003e=80 \u0026\u0026 score \u003c100 { fmt.Println(\"优秀\") } else if score \u003e=60 \u0026\u0026 score \u003c80 { fmt.Println(\"良好\") } else{ fmt.Println(\"不及格\") } ","date":"2022年07月09日","objectID":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:3","tags":["Go笔记"],"title":"Go流程控制","uri":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Go笔记"],"content":"循环控制 ","date":"2022年07月09日","objectID":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:0","tags":["Go笔记"],"title":"Go流程控制","uri":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Go笔记"],"content":"switch分支结构 switch语句用于基于不同条件执行不同动作，每一个case分支都是唯一的，从上到下逐一测试，直到匹配到为止。 case后是一个表达式（即：常量值、变量、一个有返回值的函数等） case后的各个表达式的值的数据类型，必须和switch的表达式数据类型一致 case后面可以带多个表达式，使用逗号间隔， case后的表达式如果是常量值（字面量），则要求不能重复 匹配项后面不需要再加break default语句不是必须的 Type Switch: switch语句还可以被用于type-switch来判断某个interface变量中实际指向的变量类型 var x interface{} var y = 10.0 x = y switch i := x.(type) { case nil: fmt.Printf(\"x 的类型：%T\", i) case int: fmt.Printf(\"x 的类型：int\") case float32: fmt.Printf(\"x 的类型：float32\") case float64: fmt.Printf(\"x 的类型：float64\") default: fmt.Printf(\"未知\") } ","date":"2022年07月09日","objectID":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:1","tags":["Go笔记"],"title":"Go流程控制","uri":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Go笔记"],"content":"for循环控制 for i := 0; i \u003c= 10; i++ { fmt.Println(i) } for-range 可以方便的遍历字符串和数组 arr1 := [4]int{1, 2, 3, 4} for index, val := range arr1 { fmt.Println(index, \"-\", val) } “while\"循环 在Go语言中是没有while循环的，可以使用for循环进行替换 break跳出循环 continue跳过当循环，进入下一次循环 for { fmt.Println(\"while循环\") } ","date":"2022年07月09日","objectID":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:2","tags":["Go笔记"],"title":"Go流程控制","uri":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Go笔记"],"content":"goto Go语言的goto语句可以无条件地转移到程序中指定的行 goto语句通常与条件语句配合使用。可用来实现条件转移，跳出循环体等功能。 在Go程序设计中一般不主张使用goto语句，以免造成程序流程的混乱，使理解和调试程序都产生困难。 fmt.Println(\"run 001\") fmt.Println(\"run 002\") goto label1 fmt.Println(\"run 003\") // 不会被打印 fmt.Println(\"run 004\") // 不会被打印 fmt.Println(\"run 005\") // 不会被打印 label1: fmt.Println(\"run 006\") ","date":"2022年07月09日","objectID":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:4:0","tags":["Go笔记"],"title":"Go流程控制","uri":"/2022/07/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Go笔记"],"content":"运算符分类 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。 算术运算符 赋值运算符 比较运算符/关系运算符 逻辑运算符 位运算符 其他运算符 ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"算术运算符 ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"介绍 算术运算符是对数值类型的变量进行运算的，比如：加减乘除。 运算符 运算 示例 结果 + 正好 +3 3 - 负号 -4 -4 + 加 5 + 5 10 - 减 6 - 4 2 * 乘 3 * 4 12 / 除 5 / 5 1 % 取模（取余） 7 % 5 计算公式：a%b = a - a/b *b 2 ++ 自增 a := 2;a++ a=3 – 自减 a :=2;a– a=1 + 字符串相加 “He” + “llo” “Hello” ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:2:1","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"示例 // 如果运算的数都是整数，那么除后，去掉小数部分，保留整数部分 fmt.Println(10 / 4) //2 var n1 float32 = 10 / 4 fmt.Println(n1) //2 // 如果希望保留小数部分，则需要有浮点数参与运算 var n2 float32 = 10.0 / 4 fmt.Println(n2) //2.5 // % 计算公式：a % b = a - a / b * b fmt.Println(\"10%3=\", 10%3) //10%3= 1 fmt.Println(\"-10%3=\", -10%3) //-10%3= -1 fmt.Println(\"10%-3=\", 10%-3) //10%-3= 1 fmt.Println(\"-10%-3=\", -10%-3) //-10%-3= -1 //++和-- var i int = 10 i++ //等价于 i = i + 1 fmt.Println(\"i=\", i) //i= 11 i-- //等价于 i = i - 1 fmt.Println(\"i=\", i) //i= 10 ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:2:2","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"细节 对于除号/，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。例如x:=19/5，结果是3 当对一个数取模时，可以等价a%b=a-a/b*b，这样可以看到取模的一个本质运算。 Go的自增自减只能当做一个独立语言使用，不能这样使用：b := a++或者b := a-- Go的++和--只能卸载变量的后面，不能写在前面，只有a++,a--，没有++a,--a ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:2:3","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"关系运算符（比较运算符） ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"介绍 关系运算符的结果都是bool型，也就是说：要么是true，要么是false 关系表达式经常用在if结构的条件中或for循环结构的条件中 运算符 运算 示例 结果 == 相等于 4==3 false != 不等于 4!=3 true \u003c 小于 4\u003c3 false \u003e 大于 4\u003e3 true \u003c= 小于等于 4\u003c=3 false \u003e= 大于等于 4\u003e=3 True ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:3:1","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"示例 var ( a int = 9 b int = 8 ) fmt.Println(\"a\u003eb=\", a \u003e b) //a\u003eb= true fmt.Println(\"a\u003e=b=\", a \u003e= b) //a\u003e=b= true fmt.Println(\"a\u003c=b=\", a \u003c= b) //a\u003c=b= false fmt.Println(\"a\u003cb=\", a \u003c b) //a\u003cb= false fmt.Println(\"a==b=\", a == b) //a==b= false fmt.Println(\"a!=b=\", a != b) //a!=b= true ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:3:2","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"细节 关系运算符的结果都是bool型 关系运算符组成的表达式，称为关系表达式 比较运算符==不能误写成= ❗ ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:3:3","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"逻辑运算符 ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"介绍 用于连接多个条件（一般来讲就是关系表达式），最终的结果也是一个 bool值 运算符 描述 示例(A:True,B:False) \u0026\u0026 逻辑与运算符。 如果两边的操作都是True，则为True，否则为False (A \u0026\u0026 B)为False || 逻辑或运算符。 如果两边的操作数有一个True，则为True，否则为False (A || B)为True ! 逻辑非运算符。 如果条件为True，则逻辑为False，否则为True !(A \u0026\u0026 B)为True ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:4:1","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"示例 fmt.Println(true \u0026\u0026 false) //false fmt.Println(false \u0026\u0026 true) //false fmt.Println(false || true) //true fmt.Println(true || false) //true fmt.Println(!(true \u0026\u0026 false)) //true ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:4:2","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"细节 \u0026\u0026也叫短路与；如果第一个条件为false，则第二个条件不会判断，最终结果为false fmt.Println(false \u0026\u0026 true) //false ||也叫短路或；如果第一个条件为true，则第二个条件不会判断，最终结果为true fmt.Println(true || false) //true ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:4:3","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"赋值运算符 ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"介绍 赋值运算符就是将某个运算后的值，赋给指定的变量。 运算符 描述 示例 = 简单的赋值运算符，将一个表达式的值赋给变量 C = A + B += 相加后再赋值 C += A -= 相减后再赋值 C -= A *= 相乘后再赋值 C *= A /= 相除后再赋值 C /= A %= 求余(取模)后再赋值 C %= A ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:5:1","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"示例 var a int = 20 var b int = 10 var c int c = a + b fmt.Println(c) //30 = 20 + 10 c += a fmt.Println(c) //50 = 30 + 20 c -= a fmt.Println(c) //30 = 50 - 20 c *= a fmt.Println(c) // 600 = 30 * 20 c /= a fmt.Println(c) //30 = 600 / 20 c %= a fmt.Println(c) //10 = 30 % 20 ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:5:2","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"细节 运算顺序从右往左 赋值运算符的左边，只能是变量，右边可以是变量、表达式、常量值 复合赋值运算等价于下面的效果:a += 3 等价于 a = a + 3 ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:5:3","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"位运算符 运算符 描述 \u0026 按位与运算符\u0026是双目运算符。其功能是参与运算的两数各对应的二进位相与。 运算规则：同时为1，结果为1，否则为0 | 按位或运算符|是双目运算符。其功能是参与运算的两数各对应的二进位相或。 运算规则：有一个为1，结果为1，否则为0 ^ 按位异或运算符^是双目运算符。其功能是参与运算的两数相对应的二进位相异或。 运算规则：当二进制位不同时，结果为1，否则为0 « 左移运算符\u003c\u003c是双目运算符。其功能把\u003c\u003c左边的运算数的各二进制位全部左移若干位，高位丢弃，低位补0. 左移n位就是乘以2的n次方。 » 右移运算符\u003e\u003e是双目运算符。其功能把\u003e\u003e左边的运算数的各二进制位全部右移若干位。 右移n位就是除以2的n次方。 var num1 int = 25 //11001 var num2 int = 20 // 10100 //二进制位，同时为1，结果为1，否则为0 fmt.Println(num1 \u0026 num2) // 16 10000 //二进制位，有一个为1，结果为1，否则为0 fmt.Println(num1 | num2) // 29 11101 //二进制位，当二进制位不同时，结果为1，否则为0 fmt.Println(num1 ^ num2) // 13 01101 //各二进制位全部左移若干位，高位丢弃，低位补0 fmt.Println(num1 \u003c\u003c 2) //100 1100100 25*2^2=100 //各二进制位全部右移若干位 fmt.Println(num1 \u003e\u003e 2) // 6 110 25/2^2=6 ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"其他运算符 运算符 描述 示例 \u0026 返回变量存储地址 \u0026a 将给出变量的存储地址 * 指针变量 *a 是一个指针变量 var name string = \"Joker\" var prt *string = \u0026name fmt.Printf(\"name的内存地址：%v\\n\", \u0026name) //name的内存地址：0xc00004a530 fmt.Println(\"prt=\", prt) //prt= 0xc00004a530 fmt.Printf(\"prt指针变量的值为：%v\\n\", *prt) //prt指针变量的值为：Joker ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:7:0","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"运算符优先级 优先级 分类 运算符 结合性 1 逗号运算符 , 从左到右 2 赋值运算符 =、+=、-=、*=、/=、 %=、 \u003e=、 «=、\u0026=、^=、|= 从右到左 3 逻辑或 || 从左到右 4 逻辑与 \u0026\u0026 从左到右 5 按位或 | 从左到右 6 按位异或 ^ 从左到右 7 按位与 \u0026 从左到右 8 相等/不等 ==、!= 从左到右 9 关系运算符 \u003c、\u003c=、\u003e、\u003e= 从左到右 10 位移运算符 «、» 从左到右 11 加法/减法 +、- 从左到右 12 乘法/除法/取余 *（乘号）、/、% 从左到右 13 单目运算符 !、*（指针）、\u0026 、++、–、+（正号）、-（负号） 从右到左 14 后缀运算符 ( )、[ ]、-\u003e 从左到右 ❣️注意：优先级值越大，表示优先级越高。 ","date":"2022年06月30日","objectID":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/:8:0","tags":["Go笔记"],"title":"Go运算符","uri":"/2022/06/go%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"Go标识符的命名规范 ","date":"2022年06月30日","objectID":"/2022/06/go%E6%A0%87%E8%AF%86%E7%AC%A6/:1:0","tags":["Go笔记"],"title":"Go标识符","uri":"/2022/06/go%E6%A0%87%E8%AF%86%E7%AC%A6/"},{"categories":["Go笔记"],"content":"标识符概念 Go对各种变量、方法、函数等命名时使用的字符序列称为标识符 凡是自己可以起名字的地方都叫标识符 ","date":"2022年06月30日","objectID":"/2022/06/go%E6%A0%87%E8%AF%86%E7%AC%A6/:1:1","tags":["Go笔记"],"title":"Go标识符","uri":"/2022/06/go%E6%A0%87%E8%AF%86%E7%AC%A6/"},{"categories":["Go笔记"],"content":"标识符的命名规则 由26个英文字母大小写，0-9，_组成 数字不可以开头 Go中严格区分大小写 标识符不能包含空格 下划线本身在Go中是一个特殊的标识符，称为空标识符。可以代表任何其它的标识符，但是它对应的值会被忽略（比如：忽略某个返回值）。所以仅能被作为占位符使用，不能作为标识符使用 不能以系统保留关键字作为标识符，比如：break, if等…… ","date":"2022年06月30日","objectID":"/2022/06/go%E6%A0%87%E8%AF%86%E7%AC%A6/:1:2","tags":["Go笔记"],"title":"Go标识符","uri":"/2022/06/go%E6%A0%87%E8%AF%86%E7%AC%A6/"},{"categories":["Go笔记"],"content":"标识符命名注意事项 包名：保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，不要和标准库冲突 变量名、函数名、常量名：采用驼峰法 如果变量名、函数名、常量名首字母大写，则可以被其他的包访问；如果首字母小写，则只能在本包中使用（注：首字母大写是共有的，首字母小写是私有的 ","date":"2022年06月30日","objectID":"/2022/06/go%E6%A0%87%E8%AF%86%E7%AC%A6/:1:3","tags":["Go笔记"],"title":"Go标识符","uri":"/2022/06/go%E6%A0%87%E8%AF%86%E7%AC%A6/"},{"categories":["Go笔记"],"content":"系统保留关键字 在Go中，为了简化代码编译过程中对代码的解析，其定义的保留关键字只有25个 关键字 关键字 关键字 关键字 关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var ","date":"2022年06月30日","objectID":"/2022/06/go%E6%A0%87%E8%AF%86%E7%AC%A6/:2:0","tags":["Go笔记"],"title":"Go标识符","uri":"/2022/06/go%E6%A0%87%E8%AF%86%E7%AC%A6/"},{"categories":["Go笔记"],"content":"预定义标识符 Go提供了36个预定义的标识符，其包括基础数据类型和系统内嵌函数 标识符 标识符 标识符 标识符 标识符 标识符 append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintprt ","date":"2022年06月30日","objectID":"/2022/06/go%E6%A0%87%E8%AF%86%E7%AC%A6/:3:0","tags":["Go笔记"],"title":"Go标识符","uri":"/2022/06/go%E6%A0%87%E8%AF%86%E7%AC%A6/"},{"categories":["Go笔记"],"content":"说明 值类型：基本数据类型 int系列、float系列、bool、string、数组和结构体struct 引用类型：指针、slice切片、map、管道chan、interface等都是引用类型 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/:1:0","tags":["Go笔记"],"title":"Go值类型和引用类型","uri":"/2022/06/go%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"特点 值类型：变量直接存储值，内存通常在栈中分配 引用类型：变量存储的是一个地址，这个地址对应的空间才真正存储数据（值）。内存通常在对上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收。 内存的栈区和堆区示意图： ","date":"2022年06月30日","objectID":"/2022/06/go%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/:2:0","tags":["Go笔记"],"title":"Go值类型和引用类型","uri":"/2022/06/go%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"基本介绍 基本数据类型，变量存的就是值，也叫值类型 获取变量的地址，用\u0026 var i int = 10 fmt.Println(\"i的地址：\", \u0026i) //i的地址： 0xc0000162d8 指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值 // ptr是一个指针变量 // ptr的类型 *int // ptr本身的值是\u0026i var ptr *int = \u0026i fmt.Printf(\"ptr=%v\\n\", ptr) //ptr=0xc00011c1b0 fmt.Printf(\"ptr的地址：%v\\n\", \u0026ptr) //ptr的地址：0xc000114028 获取指针类型所指向的值，用* fmt.Printf(\"ptr指向的值=%v\\n\", *ptr) //ptr指向的值=10 ","date":"2022年06月30日","objectID":"/2022/06/go%E6%8C%87%E9%92%88/:1:0","tags":["Go笔记"],"title":"Go指针","uri":"/2022/06/go%E6%8C%87%E9%92%88/"},{"categories":["Go笔记"],"content":"变量在内存中的分布： ","date":"2022年06月30日","objectID":"/2022/06/go%E6%8C%87%E9%92%88/:2:0","tags":["Go笔记"],"title":"Go指针","uri":"/2022/06/go%E6%8C%87%E9%92%88/"},{"categories":["Go笔记"],"content":"指针在内存中的分布： ","date":"2022年06月30日","objectID":"/2022/06/go%E6%8C%87%E9%92%88/:3:0","tags":["Go笔记"],"title":"Go指针","uri":"/2022/06/go%E6%8C%87%E9%92%88/"},{"categories":["Go笔记"],"content":"指针细节说明 值类型，都有对应的指针类型，形式为*数据类型,比如：int对应的指针就是*int，float32对应的指针类型就是*float 值类型包括：基本数据类型int系列、float系列、bool、string、数组和结构体struct ","date":"2022年06月30日","objectID":"/2022/06/go%E6%8C%87%E9%92%88/:4:0","tags":["Go笔记"],"title":"Go指针","uri":"/2022/06/go%E6%8C%87%E9%92%88/"},{"categories":["Go笔记"],"content":"介绍 Go在不同类型的变量之间赋值时需要显式转换。Go中数据类型不能自动转换。 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/:0:1","tags":["Go笔记"],"title":"Go基本数据类型的转换","uri":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Go笔记"],"content":"基本语法 表达式T(v) 将值v转换为类型T T: 就是数据类型，比如：int32/int64/float32等 v: 就是需要转换的变量 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/:0:2","tags":["Go笔记"],"title":"Go基本数据类型的转换","uri":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Go笔记"],"content":"示例 var i int = 42 var f float64 = float64(i) var u uint8 = uint8(f) fmt.Println(i, f, u) //42 42 42 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/:0:3","tags":["Go笔记"],"title":"Go基本数据类型的转换","uri":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Go笔记"],"content":"细节说明 Go中，数据类型的转换可以是从表示范围小-\u003e表示范围大，也可以 范围大-\u003e范围小 被转换的是变量存储的数据（即值），变量本身的数据类型并没有变化 在转换中，比如将int64转成int8，编译时不会报错，只是转换的结果是按溢出处理，和期望结果不一样 var num int64 = 999999 var num2 int8 = int8(num) fmt.Println(num2) //63 转换的结果被按照溢出处理，跟预期结果不一致 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/:0:4","tags":["Go笔记"],"title":"Go基本数据类型的转换","uri":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Go笔记"],"content":"基本数据类型和string的转换 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/:1:0","tags":["Go笔记"],"title":"Go基本数据类型的转换","uri":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Go笔记"],"content":"基本数据类型转string 方式一：fmt.Sprintf(\"%参数\", 表达式) 参数需要和表达式的数据类型相匹配 fmt.Sprintf(...)会返回转换后的字符串 var ( num1 int = 99 num2 float64 = 23.34 isChecked bool = true myChar byte = 'h' str string // 空字符串 ) // int -\u003e string str = fmt.Sprintf(\"%d\", num1) fmt.Printf(\"str type %T str=%q\\n\\n\", str, str) //str type string str=\"99\" // float -\u003e string str = fmt.Sprintf(\"%f\", num2) fmt.Printf(\"str type %T str=%q\\n\\n\", str, str) //str type string str=\"23.340000\" // bool -\u003e string str = fmt.Sprintf(\"%t\", isChecked) fmt.Printf(\"str type %T str=%q\\n\\n\", str, str) //str type string str=\"true\" // char -\u003e string str = fmt.Sprintf(\"%c\", myChar) fmt.Printf(\"str type %T str=%q\\n\\n\", str, str) //str type string str=\"h\" 方式二：使用strconv包的函数 var ( num1 int = 99 num2 float64 = 23.34 isChecked bool = true str string // 空字符串 ) // int -\u003e string str = strconv.FormatInt(int64(num1), 10) fmt.Printf(\"str type %T str=%q\\n\\n\", str, str) //str type string str=\"99\" str = strconv.Itoa(num1) fmt.Printf(\"str type %T str=%q\\n\\n\", str, str) //str type string str=\"99\" // float -\u003e string // 参数说明：'f'：格式 10：表示小数位保留10位 64：表示float64 str = strconv.FormatFloat(num2, 'f', 10, 64) fmt.Printf(\"str type %T str=%q\\n\\n\", str, str) //str type string str=\"23.3400000000\" // bool -\u003e string str = strconv.FormatBool(isChecked) fmt.Printf(\"str type %T str=%q\\n\\n\", str, str) //str type string str=\"true\" ","date":"2022年06月30日","objectID":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/:1:1","tags":["Go笔记"],"title":"Go基本数据类型的转换","uri":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Go笔记"],"content":"string类型转基本数据类型 使用strconv包的函数 var str string = \"true\" var b bool b, _ = strconv.ParseBool(str) fmt.Printf(\"b type %T b=%v\\n\", b, b) //b type bool b=true var str1 string = \"10\" var b1 int64 b1, _ = strconv.ParseInt(str1, 10, 64) fmt.Printf(\"b1 type %T b1=%v\\n\", b1, b1) //b1 type int64 b1=10 var str2 string = \"10.0000001\" var b2 float64 b2, _ = strconv.ParseFloat(str2, 64) fmt.Printf(\"b2 type %T b2=%v\\n\", b2, b2) //b2 type float64 b2=10.0000001 var str3 string = \"10\" var b3 uint64 b3, _ = strconv.ParseUint(str3, 10, 64) fmt.Printf(\"b3 type %T b3=%v\\n\", b3, b3) ","date":"2022年06月30日","objectID":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/:1:2","tags":["Go笔记"],"title":"Go基本数据类型的转换","uri":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Go笔记"],"content":"注意事项 在将string转成基本数据类型时，要确保string类型能够转成有效的数据，否则会将其转成零值 var str4 string = \"hello\" // 把此字符串转成整数，Go会直接将其转成0 var num int64 num, _ = strconv.ParseInt(str4, 10, 64) fmt.Printf(\"num type %T num=%v\\n\", num, num) // num type int64 num=0 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/:1:3","tags":["Go笔记"],"title":"Go基本数据类型的转换","uri":"/2022/06/go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Go笔记"],"content":"Go变量 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["Go笔记"],"title":"Go变量和基本数据类型","uri":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"概念 变量相当于内存中一个数据存储空间的表示。通过变量名可以访问到变量（值）。 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:1","tags":["Go笔记"],"title":"Go变量和基本数据类型","uri":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"变量使用的基本步骤 声明变量（定义变量） 赋值 使用 var name string //声明变量 name = \"Joker\" //赋值 fmt.Println(\"name: \", name) //使用 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:2","tags":["Go笔记"],"title":"Go变量和基本数据类型","uri":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"变量使用注意事项 变量表示内存中的一个存储区域 该区域有自己的名称（变量名）和类型（数据类型） Go变量使用的三种方式 指定变量类型，声明后若不赋值，使用默认值 var i int var name string fmt.Println(\"i: \", i) //i: 0 fmt.Println(\"name: \", name) //name: 根据值自行判定变量类型（类型推导） i := 100 fmt.Printf(\"i: %d, i的类型：%T\\n\", i, i) //i: 100, i的类型：int 省略var，注意：:= 左侧的变量不应该是已经声明过的，否则会导致编译错误 多变量声明 var a, b, c, d int fmt.Println(a, b, c, d) //0 0 0 0 a1, b1, c1, d1 := 1, 2, 3, 4 fmt.Println(a1, b1, c1, d1) //1 2 3 4 var a2, b2, c2, d2 = \"a2\", 2, \"c2\", 23.09 fmt.Println(a2, b2, c2, d2) //a2 2 c2 23.09 该区域的数据值可以在同一类型范围内不断变化 var name = \"Joker\" fmt.Println(name) //Joker name = \"Tom\" fmt.Println(name) //Tom name = \"Sony\" fmt.Println(name) //Sony // name = 10 //cannot use 10 (type untyped int) as type string in assignment 变量在同一作用域（在一个函数或者在代码块）内不能重名 var name = \"Joker\" fmt.Println(name) //Joker // 变量不能再同一作用域下重名 var name = \"Tom\" //previous declaration 变量=变量名+值+数据类型 Go的变量如果没有赋初始值，编译器会使用默认值，比如:int默认值是0，string默认值为空，float默认值也是0 var ( name string //默认值为空 age int //默认值为0 score float64//默认值为0.0 ) fmt.Printf(\"name: %s,age:%d,score:%f\\n\", name, age, score) //name:,age:0,score:0.000000 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:3","tags":["Go笔记"],"title":"Go变量和基本数据类型","uri":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"程序中+号的使用 当左右两边都是数值型时，则做加法运算 var ( n1 = 100 n2 = 200 ) fmt.Println(\"n1 + n2 = \", n1+n2) //n1 + n2 = 300 当左右两边都是字符串，则做字符串拼接 var ( n3 = \"Hello\" n4 = \"World!\" ) fmt.Println(\"n3 + n4 = \", n3+n4) //n3 + n4 = HelloWorld! ","date":"2022年06月30日","objectID":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:4","tags":["Go笔记"],"title":"Go变量和基本数据类型","uri":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"变量的数据类型 每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间。 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["Go笔记"],"title":"Go变量和基本数据类型","uri":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"整数类型 基本介绍 用于存放整数值，比如0,-1,233等 示例 var a int = 8900 fmt.Println(\"a = \", a) var b uint = 1 fmt.Println(\"b = \", b) var c byte = 255 fmt.Println(\"c = \", c) var d rune = 1000 fmt.Println(\"d = \", d) 整型的类型 类型 有无符号 占用存储空间 数值范围 备注 int8 有 1字节 -128~127 int16 有 2字节 -2^15~2^15-1 int32 有 4字节 -2^31~2^31-1 int64 有 8字节 -2^63~2^63-1 int 有 32位系统4个字节 64位系统8个字节 -2^31~2^31-1 -2^63~2^63-1 uint 无 32位系统4个字节 64位系统8个字节 0~2^32-1 0~2^64-1 rune 有 与int32一样 -2^31~2^31-1 等价int32，表示一个Unicode码 byte 无 与uint8等价 0~255 当要存储字符时，选用byte 整型的使用细节 Go各整数类型分类：有符号和无符号，int uint的大小和系统有关 Go的整型默认声明为int型 num := 100 fmt.Printf(\"num=%d, num的类型：%T\\n\", num, num) //num=100, num的类型：int Go程序中整型变量在使用时，遵守保小不保大的原则，即：在保证程序正确运行下，尽量使用占用空间小的数据类型，比如：年龄 bit: 计算机中的最小存储单位。byte: 计算机中基本存储单元 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:1","tags":["Go笔记"],"title":"Go变量和基本数据类型","uri":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"浮点型 基本介绍 浮点型就是用于存放小数的，比如：1.2, 0.3, -1.293 示例 var price float32 = 89.02 fmt.Println(\"price = \", price) //price = 89.02 var ( num1 float32 = -0.00089 num2 float64 = -7890976.09 ) fmt.Println(\"num1 = \", num1, \"，num2 = \", num2) //num1 = -0.00089 ，num2 = -7.89097609e+06 浮点类型的分类 类型 占用存储空间 数值范围 单精度 float32 4字节 -3.403E38~3.403E38 双精度 float64 8字节 -1.798E308~1.798E308 说明： 浮点型的存储分为三部分：符号位+指数位+尾数位，在存储过程中，精度会有丢失 var ( n1 float32 = -123.0000901 n2 float64 = -123.0000901 ) fmt.Println(\"n1 = \", n1, \" n2 = \", n2) //n1 = -123.00009 n2 = -123.0000901 float64的精度比float32的要准确 如果需要保存一个精度高的数，则应该选用float64 浮点型的使用细节 Go浮点类型有固定的范围和字段长度，不受具体OS的影响 Go的浮点型默认声明为float64类型 num3 := 12.09 fmt.Printf(\"num3的类型：%T\\n\", num3) //num3的类型：float64 浮点型常量有两种表示形式 十进制形式：如： num4 := 5.12 num5 := .123 //0.123 fmt.Println(\"num4 = \", num4, \" num5 = \", num5) //num4 = 5.12 num5 = 0.123 科学计数法形式：如： num6 := 5.12e2 num7 := 5.12e-2 fmt.Println(\"num6 = \", num6, \" num7 = \", num7) //num6 = 512 num7 = 0.0512 通常情况下，应该使用float64，因为它比float32更精准 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:2","tags":["Go笔记"],"title":"Go变量和基本数据类型","uri":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"字符类型（char） 基本介绍 Go中没有专门的字符类型，如果要存储单个字符（字母），一般使用byte来保存。 字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的，也就是说对于传统的字符串是由字符组成的，而Go的字符串不同，它是由字节组成的（官方将string归属到基本数据类型中）。 示例 var ( c1 byte = 'a' c2 byte = '0' //字符的0 ) // 当我们直接输出byte值，就是输出了对应的字符的码值 fmt.Println(\"c1 = \", c1) //c1 = 97 fmt.Println(\"c2 = \", c2) //c2 = 48 // 如果希望输出对应的字符，则需要使用格式化输出，%c fmt.Printf(\"c1 = %c, c2 = %c\\n\", c1, c2) //c1 = a, c2 = 0 //var c3 byte = '北' //constant 21271 overflows byte var c3 int = '北' // 由于上面一行定义的字符类型，对应码大于255，建议大于255的考虑使用int类型保存 fmt.Printf(\"c3 = %c, c3对应码值=%d\\n\", c3, c3) //c3 = 北, c3对应码值=21271 说明： 如果我们保存的字符在ASCII表中，那么可以直接保存到byte 如果我们保存的字符对应码大于255，这时我们可以考虑使用int类型保存 如果我们需要按照字符的方式输出，这时我们需要格式化输出fmt.Printf(\"%c 对应的码值：%d\", c, c) 字符类型的使用细节 字符常量是用单引号（’’）括起来的单个字符。例如： var c1 byte = 'a' var c2 byte = '中' var c3 byte = '9' Go中允许使用转义字符\\来表示将其后的字符转变为特殊字符型常量，例如: var c3 char = '\\n' //'\\n'表示换行符 Go语言的字符使用UTF-8编码； 在Go中，字符的本质是一个整数，直接输出时，是该字符对应的UTF-8编码的码值； var ( c1 byte = 'a' c2 byte = '0' //字符的0 ) // 当我们直接输出byte值，就是输出了对应的字符的码值 fmt.Println(\"c1 = \", c1) //c1 = 97 fmt.Println(\"c2 = \", c2) //c2 = 48 可以直接给某个变量赋一个数字，然后按格式化输出时使用%c会输出该数字对应的unicode字符； //可以直接给某个变量赋一个数字，然后按照格式化输出使用%c，会输出该数字对应的Unicode字符 var c4 int = 22269 fmt.Printf(\"c4=%c\\n\", c4) //c4=国 字符类型是可以进行运算的，相当于一个整数，因为它都对应的有Unicode码。 //字符类型是可以进行运算的，相当于一个整数，运算时按照码值运行 var n1 = 10 + 'a' // 10 + 97 fmt.Println(\"n1 = \", n1) // n1 = 107 字符类型的本质 字符型 存储到计算机中，需要将字符对应的码值（整数）找出来 存储：字符 -\u003e 对应码值 -\u003e 二进制 -\u003e 存储 读取：二进制 -\u003e 码值 -\u003e 字符 -\u003e 读取 字符和码值的对应关系是通过字符编码表来决定的（是已经规定好的） Go语言的编码都统一成了utf-8，再也没有编码的困扰了 ","date":"2022年06月30日","objectID":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:3","tags":["Go笔记"],"title":"Go变量和基本数据类型","uri":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"布尔类型（bool） 基本介绍 布尔类型也叫bool类型，bool类型数据只允许取值true和false bool类型占1个字节 bool类型适用于逻辑运算，一般用于程序流程控制 示例 var b = false fmt.Println(\"b=\", b) //b= false fmt.Println(\"b的占用空间 = \", unsafe.Sizeof(b)) //b的占用空间 = 1 布尔类型的使用细节 不可以0或非0的整数替代false和true ","date":"2022年06月30日","objectID":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:4","tags":["Go笔记"],"title":"Go变量和基本数据类型","uri":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"字符串类型（string） 基本介绍 字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本 示例 var name string // 显示声明string变量 name = \"Joker\" fmt.Println(name) //Joker address := \"深圳\"//隐式声明string变量 fmt.Printf(\"address=%s type=%T\", address, address) //address=深圳 type=string 字符串类型的使用细节 Go语言的字符串的字节使用UTF-8编码标识Unicode文本； 字符串一旦赋值了，字符串就不能修改了：在Go中字符串是不可变的 字符串的两种表示形式 双引号，会识别转义字符 反引号，以字符串的原生形式输出，包括换行和特殊字符，可以实现防止攻击、输出源代码等效果 字符串拼接方式 var str string str = \"hello \" + \"world!\" fmt.Println(str) //hello world! str += \"ok\" //+=等价于 str = str + \"ok\" fmt.Println(str) //hello world!ok 当一行字符串太长时，需要使用到多行字符串 str2 := \"hello \" + // 使用多行字符串，+号必须在结尾 \"world!\" fmt.Println(str2) //hello world! ","date":"2022年06月30日","objectID":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:5","tags":["Go笔记"],"title":"Go变量和基本数据类型","uri":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"基本数据类型默认值 在Go中，数据类型都有一个默认值，当没有赋值时，就会保留默认值，在Go中默认值又叫零值。 数据类型 默认值 整型 0 浮点型 0 字符串 \"\" 布尔类型 false var ( a int b float32 c float64 isMarried bool name string ) // %v：表示按照变量的值输出 fmt.Printf(\"a=%d,b=%v,c=%v,isMarried=%v,name=%v\\n\", a, b, c, isMarried, name) //输出结果：a=0,b=0,c=0,isMarried=false,name= ","date":"2022年06月30日","objectID":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:6","tags":["Go笔记"],"title":"Go变量和基本数据类型","uri":"/2022/06/go%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Go笔记"],"content":"Go支持C语言风格的/* */块注释，也支持C++风格的//行注释。 行注释更通用，块注释要勇于针对包的详细说明或者屏蔽大块的代码。 ","date":"2022年06月29日","objectID":"/2022/06/go%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A/:0:0","tags":["Go笔记"],"title":"Go语言注释","uri":"/2022/06/go%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A/"},{"categories":["Go笔记"],"content":"1）行注释 格式：//注释文字 示例： fmt.Println(\"Hello World!\")//输出：Hello World! ","date":"2022年06月29日","objectID":"/2022/06/go%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A/:0:1","tags":["Go笔记"],"title":"Go语言注释","uri":"/2022/06/go%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A/"},{"categories":["Go笔记"],"content":"2）块注释（多行注释） 格式：/* 注释文字 */ 示例： /* Multipart/Urlencoded 表单 两个参数都传： curl -v --form message=msg --form nick=nick2 http://localhost:8080/v1/form_post 结果：{\"message\":\"msg\",\"nick\":\"nick2\",\"status\":\"posted\"} 只传一个参数，另一个使用默认值： curl -v --form message=msg http://localhost:8080/v1/form_post 结果：{\"message\":\"msg\",\"nick\":\"anonymous\",\"status\":\"posted\"} */ v1.POST(\"/form_post\", fast_started.Form_post) ","date":"2022年06月29日","objectID":"/2022/06/go%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A/:0:2","tags":["Go笔记"],"title":"Go语言注释","uri":"/2022/06/go%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A/"},{"categories":["Go笔记"],"content":"使用细节 对于行注释和块注释，被注释的文字，不会被Go编译器解释执行 块注释里面不允许有块注释嵌套 ","date":"2022年06月29日","objectID":"/2022/06/go%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A/:0:3","tags":["Go笔记"],"title":"Go语言注释","uri":"/2022/06/go%E8%AF%AD%E8%A8%80%E6%B3%A8%E9%87%8A/"},{"categories":["Go笔记"],"content":"Go常用的转义字符（escape char） \\t : 一个制表位，实现对齐的功能 \\n : 换行符 \\\\ : 一个\\ \\\" : 一个\" \\r : 一个回车 ，从当前行的最前面开始输出，覆盖掉以前内容 ","date":"2022年06月29日","objectID":"/2022/06/go%E8%AF%AD%E8%A8%80%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/:1:0","tags":["Go笔记"],"title":"Go语言转义字符","uri":"/2022/06/go%E8%AF%AD%E8%A8%80%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":"示例 package escaptechar import ( \"fmt\" \"testing\" ) func TestEscapteChar(t *testing.T) { // \\t制表符 fmt.Println(\"tom\\tjack\") //tom jack // \\n换行 fmt.Println(\"hello\\nword\") // \\\\ fmt.Println(\"c:\\\\Users\\\\Administrator\\\\Desktop\\\\Go语言\") //c:\\Users\\Administrator\\Desktop\\Go语言 // \\\" fmt.Println(\"Joker say \\\"Welcome to China!\\\"\") // Joker say \"Welcome to China!\" // \\r回车，从当前行的最前面开始输出，覆盖掉以前的内容 fmt.Println(\"天龙八部雪山飞狐\\r张飞\") //张飞 } === RUN TestEscapteChar tom jack hello word c:\\Users\\Administrator\\Desktop\\Go语言 Joker say \"Welcome to China!\" 张飞 --- PASS: TestEscapteChar (0.00s) ","date":"2022年06月29日","objectID":"/2022/06/go%E8%AF%AD%E8%A8%80%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/:1:1","tags":["Go笔记"],"title":"Go语言转义字符","uri":"/2022/06/go%E8%AF%AD%E8%A8%80%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"},{"categories":["Go笔记"],"content":" Go源文件以go为扩展名 Go应用程序的执行入口是main()方法 Go语言严格区分大小写 Go方法由一条条语句构成，每个语句后不需要分号（Go语言会在每行后自动加分号），这也体现了Golang的简洁性 Go编译器是一行行进行编译的，因此我们一行就写一条语句，不能把多条语句写在同一个，否则报错 Go语言定义的变量或者import的包，如果没有使用到，代码不能编译通过 大括号都是成对出现的，缺一不可 ","date":"2022年06月29日","objectID":"/2022/06/go%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/:0:0","tags":["Go笔记"],"title":"Go程序编写注意事项","uri":"/2022/06/go%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"categories":["Go笔记"],"content":"对源码编译后，再执行 Go的执行流程如下 ","date":"2022年06月29日","objectID":"/2022/06/go%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/:1:0","tags":["Go笔记"],"title":"Go执行流程分析","uri":"/2022/06/go%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"},{"categories":["Go笔记"],"content":"对源码直接执行 使用 go run 源码进行执行 ","date":"2022年06月29日","objectID":"/2022/06/go%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/:2:0","tags":["Go笔记"],"title":"Go执行流程分析","uri":"/2022/06/go%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"},{"categories":["Go笔记"],"content":"两种执行流程的方式区别 如果我们先编译生成了可执行文件，那么我们可以将该可执行文件拷贝到没有go开发环境的机器上，仍然可以运行 如果我们是直接go run 源码，那么如果要在另外一个机器上这么运行，也需要go开发环境，否则无法执行 在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以，可执行文件变大了很多 ","date":"2022年06月29日","objectID":"/2022/06/go%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/:3:0","tags":["Go笔记"],"title":"Go执行流程分析","uri":"/2022/06/go%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"},{"categories":["Python"],"content":"一、为什么要重构 之前的方式，比较low 二、Dynaconf是什么 Dynaconf 是一个旨在成为 Python 中管理配置的最佳选择的库。 它可以从各种来源读取设置，包括环境变量、文件、配置服务器、保险库等。 它适用于任何类型的 Python 程序，包括 Flask 和 Django 扩展。 它是高度可定制且经过大量测试的。 三、怎么使用Dynaconf ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:0:0","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"3.1、安装Dynaconf pip install dynaconf ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:1:0","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"3.2、Dynaconf初始化文档说明 ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:2:0","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"3.3、初始化一个配置 dynaconf init -f toml 自动生成文件↓ ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:3:0","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"3.4、文件说明 .gitignore: git 要忽略的文件模式 # Ignore dynaconf secret files .secrets.* .secrets.toml: 密码和令牌等敏感数据(可选) TOKEN = xxxx config.py: 导入设置对象的地方(必需的) from dynaconf import Dynaconf settings = Dynaconf( envvar_prefix=\"DYNACONF\", settings_files=['settings.toml', '.secrets.toml'], # 在项目中此列表元素要填写文件基于项目的相对路径 environments=True, ENV_FOR_DYNACONF=\"develop\" # 修改默认使用的环境，默认为：[development] ) # `envvar_prefix` = export envvars with `export DYNACONF_FOO=bar`. # `settings_files` = Load these files in the order. settings.toml: 应用setttings(可选) 分为三部分：[default] [develop] [master] 通过设置环境变量 【ENV_FOR_DYNACONF】进行控制 [develop] [master] 如果没有设置环境变量，则根据 config.py文件中设置的默认使用环境进行使用 [default] ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 44640 # 一个月过期 SQLALCHEMY_DATABASE_URL_1 = \"@format mysql+pymysql://{this.DB_USER}:{this.DB_PASSWORD}@{this.DB_HOST}:3306/xxx?charset=utf8\" SQLALCHEMY_DATABASE_URL_2 = \"@format mysql+pymysql://{this.DB_USER}:{this.DB_PASSWORD}@{this.DB_HOST}:3306/xxx_ddd?charset=utf8\" SQLALCHEMY_DATABASE_URL_3 = \"@format mysql+pymysql://{this.DB_USER}:{this.DB_PASSWORD}@{this.DB_HOST}:3306/xxx_lll?charset=utf8\" [develop] BASE_URL = \"https://fastapi.debug.com.hk/\" SECRET_KEY = \"xxxxxx\" DB_HOST = \"192.00.00.00\" DB_USER = \"xxxx\" DB_PASSWORD = \"xxxxxxxx\" REDIS_HOST = '192.22.22.22' REDIS_PORT = 6380 [master] BASE_URL = \"https://fastapi.com.hk/\" SECRET_KEY = \"zzzzzzzzz\" DB_HOST = \"192.00.1.12\" DB_USER = \"eeee\" DB_PASSWORD = \"ddxrrr\" REDIS_HOST = '192.00.00.100' REDIS_PORT = 6381 ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:4:0","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"3.5、简单使用 ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:5:0","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"3.5.1. 导包 from config.config import settings ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:5:1","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"3.5.2. 获取配置项 # default print(f\"{'*'*10}==\u003e\u003edefault\") print(f\"{settings.ALGORITHM=}\") print(f\"{settings.ACCESS_TOKEN_EXPIRE_MINUTES=}\") # 环境区分 print(f\"{'*'*10}==\u003e\u003e环境区分: {settings.ENV_FOR_DYNACONF}\") print(f\"{settings.BASE_URL=}\") print(f\"{settings.SECRET_KEY=}\") print(f\"{settings.DB_HOST=}\") print(f\"{settings.DB_USER=}\") print(f\"{settings.DB_PASSWORD=}\") print(f\"{settings.REDIS_HOST=}\") print(f\"{settings.REDIS_PORT=}\") # 在default中使用通过环境区分的变量 print(f\"{'*'*10}==\u003e\u003e在default中使用通过环境区分的变量\") print(f\"{settings.SQLALCHEMY_DATABASE_URL_1=}\") print(f\"{settings.SQLALCHEMY_DATABASE_URL_2=}\") print(f\"{settings.SQLALCHEMY_DATABASE_URL_3=}\") 1）使用默认情况（或者 ENV_FOR_DYNACONF=develop）的配置项 2）使用 ENV_FOR_DYNACONF=master的自定义配置项 ① 设置环境变量 export ENV_FOR_DYNACONF=master ② 结果 ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:5:2","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"3.6、使用系统环境变量值 ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:6:0","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"3.6.1. 自定义系统环境变量前缀 设置的系统环境变量需要以指定的前缀命名 settings = Dynaconf( envvar_prefix=\"DYNACONF\", # 读取系统环境变量的前缀（可自定义） settings_files=['settings.toml', '.secrets.toml'], environments=True, ENV_FOR_DYNACONF=\"develop\" # 修改默认使用的环境，默认为：[development] ) ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:6:1","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"3.6.2. 设置环境变量 export DYNACONF_USER=Desire export DYNACONF_PWD=123456 export DYNACONF_ACCESS_TOKEN_EXPIRE_MINUTES=60 # 这一个环境变量和配置文件中的名称【ACCESS_TOKEN_EXPIRE_MINUTES】一样 ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:6:2","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"3.6.3. 读取系统环境变量 按照指定的前缀添加系统环境变量，读取的时候直接忽略前缀即可 如果读取不存在的系统环境变量则会抛出异常 如果设置的系统环境变量和配置文件中的同名，则会优先读取系统环境变量的值 print(f\"{settings.USER=}\") print(f\"{settings.PWD=}\") print(f\"{settings.ACCESS_TOKEN_EXPIRE_MINUTES=}\") 四、项目中应用 ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:6:3","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"4.1、配置文件路径结构（fast_api/app/core/config） ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:7:0","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"4.2、config.py配置项中修改 settings_files使用基于项目的相对路径 如果此处直接使用 settings_files=['settings.toml','.secrets.toml']在 fast_api/app/core/config文件夹之外的模块中使用则会报错找不到配置文件位置 ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:8:0","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"4.3、添加 __init__.py文件 from app.core.config.config import settings 在 __init__.py文件中就一行导包语句，那么我为什么要多此一举呢，是为了在进行配置项导包的时候可以少导一层，这样导包看起来也比较整洁 ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:9:0","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"添加之前使用配置文件 # 导包 from app.core.config.config import settings ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:9:1","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"添加之后使用配置文件 # 导包 from app.core.config import settings ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:9:2","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"4.4、新增配置项（有代码块的配置项） 可以放在 __init__.py文件中，也可以放在 settings.py文件中。 # 项目绝对路径配置项 settings.BASE_APP_DIR = os.path.dirname(os.path.dirname(os.path.dirname(__file__))) # or 也可以通过__setattr__()进行添加 # settings.__setattr__(\"BASE_APP_DIR\", os.path.dirname(os.path.dirname(os.path.dirname(__file__)))) # or 通过字典添加键值对的方式进行添加 # settings[\"BASE_APP_DIR\"] = os.path.dirname(os.path.dirname(os.path.dirname(__file__))) 附件 【Dynaconf官方文档】 ","date":"2022年04月06日","objectID":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/:10:0","tags":["Python"],"title":"配置文件重构","uri":"/2022/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E6%9E%84/"},{"categories":["Python"],"content":"之前的命令行编写方式 ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:1:0","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"getopt实现方式（不讨论具体代码实现）👇🏻 class ALSRun(object): def __init__(self, in_file, out_file=None): self.csv = in_file self.out_file = out_file def recommend(self): ...... if not self.out_file: self.out_file = f'{time.strftime(\"%Y%m%d%H%M%S\")}.csv' nrecommendations.coalesce(1).write.csv(self.out_file) print(\"🗣执行完毕🤝🤝🤝\") if __name__ == '__main__': # 获取文件名 file_name = sys.argv[0] usage = f'用法：{file_name} -i \u003cinputfile\u003e -o \u003coutputfile\u003e\\n参数解释 \\n\\t-i|--ifile: 执行（必填）\\n\\t\u003cinputfile\u003e: 表示要执行的csv文件\\n\\t-o|--ofile:输出（非必填） \\n\\t\u003coutputfile\u003e: 表示要输出的csv文件,默认以当前时间为文件名' try: opts, args = getopt.getopt(sys.argv[1:], \"hi:o:\", [\"ifile=\", \"ofile=\"]) except getopt.GetoptError: print(f'{file_name} -i \u003cinputfile\u003e -o \u003coutputfile\u003e') sys.exit(2) inputfile = None outputfile = None if len(opts) == 0: print(usage) sys.exit() for opt, arg in opts: if opt == '-h': print(usage) sys.exit() elif opt in (\"-i\", \"--ifile\"): inputfile = arg elif opt in (\"-o\", \"--ofile\"): outputfile = arg if inputfile.endswith(\".csv\") and (outputfile is None or outputfile.endswith(\".csv\")): print(\"==========开始执行ALS==========\") als = ALSRun(in_file=inputfile, out_file=outputfile) als.recommend() else: print(\"错误的传参，请看如下用法↓\") print(usage) ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:1:1","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"不足之处 太繁琐，不简洁（仅仅就是为了实现一个 python3 100als.py -i article.csv -o t.csv命令就要多写20+行） 不易懂（啥玩意儿，过段时间再看就费劲了） 如何解决命令行的问题呢？ ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:1:2","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"使用Click处理命令行 ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:2:0","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"什么是Click Click是一个Python包，用于以可组合的方式使用尽可能少的代码创建漂亮的命令行界面，是 命令行界面创建工具、是高度可配置的，但带有开箱即用的合理默认值。 它旨在使编写命令行工具的过程变得快速而有趣，同时还防止因无法实现预期的 CLI API 而导致的任何挫败感。 ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:2:1","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"Click的优点 命令的任意嵌套 自动帮助页面生成 支持在运行时延迟加载子命令 ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:2:2","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"Click安装 pip install click ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:2:3","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"简单的例子 import click @click.command() @click.option('--count', default=1, help='Number of greetings.') @click.option('--name', prompt='Your name', help='The person to greet.') def hello(count, name): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" for x in range(count): click.echo(f\"Hello {name}!\") if __name__ == '__main__': hello() 从上面的例子可以看到，就仅仅的使用了三个装饰器，就把命令行实现了（并且自带–help）👍🏻 ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:2:4","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"简单的使用说明 @click.command()：用来声明被装饰的类/方法是一个命令行 @click.option()：给命令添加选项 @click.option('--count', default=1, help='Number of greetings.') 以上面为例 参数1：命令行选项名 default参数：默认值 help：帮助信息 prompt：提示信息（在没有传递选项的时候，会在控制台提示输入） 函数接收的值具体规则如下： 选择名称的顺序： 如果名称没有前缀，则将其用作Python参数名称，而不将其视为命令行上的选项名称 @click.command() @click.option(\"-f\", \"--filename\", \"dest\") # 名称为 dest def echo(dest): print(f\"{dest=}\") 2. 如果至少有一个名称以两个破折号为前缀，则将给定的第一个名称用作名称 @click.command() @click.option(\"--f\", \"--foo-bar\") # 名称为f def echo(f): print(f\"{f=}\") 3. 否则使用以一个破折号为前缀的名字 @click.command() @click.option(\"-f\", \"-fb\") # 名称为 f def echo(f): print(f\"{f=}\") ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:2:5","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"解决问题 ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:3:0","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"解决步骤 清除掉之前使用getopt编写命令行方式的代码 定义一个函数 def run(infile, outfile):，用来处理命令行（也可以直接在原有类上使用，但是不建议使用，会破坏原有逻辑） 在 __main__中调用函数 run() 在控制台使用命令行执行程序 python3 als.py -i article.csv ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:3:1","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"代码展示 @click.command() @click.option(\"-i\", \"--in\", \"infile\", prompt=\"输入文件\", help=\"输入文件（以.csv为后缀）\") @click.option(\"-o\", \"--out\", \"outfile\", default=None, help=\"输出文件（默认为当前时间戳，以.csv为后缀）\") def run(infile, outfile): if infile.endswith(\".csv\") and (outfile is None or outfile.endswith(\".csv\")): ALSRun(infile=infile, outfile=outfile) else: print(\"参数格式有误！！！\") class ALSRun(object): def __init__(self, infile, outfile): ... if __name__ == '__main__': run() ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:3:2","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"结果展示 $ python3 100als.py --help Usage: als.py [OPTIONS] Options: -i, --in TEXT 输入文件（以.csv为后缀） -o, --out TEXT 输出文件（默认为当前时间戳，以.csv为后缀） --help Show this message and exit. $ python3 100als.py -i article.csv 输入文件：article.csv 输出文件：20220308175307.csv ==========开始执行ALS========== ... ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:3:3","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"优点说明 简洁、易用、易读 不污染原逻辑 功能强大、拓展性强 ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:3:4","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"总结 ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:3:5","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"附件 具体Click用法请参考官方文档「链接」 ","date":"2022年03月08日","objectID":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/:4:0","tags":["Allure","Python"],"title":"简洁易用的命令行实践","uri":"/2022/03/%E7%AE%80%E6%B4%81%E6%98%93%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"一、结构模式匹配（新增PEP 635） 如果你熟悉别的语言，你肯定知道 switch-\u003ecase语句，python3.10之前的版本是一直没有这种语法的，但是这一次的更新中3.10+版本（20211004）开始支持这种结构模式匹配的语法书写了–match-\u003ecase ","date":"2021年11月10日","objectID":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/:1:0","tags":["Python"],"title":"Python3.10新特性初体验","uri":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Python"],"content":"1、基本语法 match expression: # 条件，可为任意表达式、变量 case pattern_1: # 模式，待匹配的条件1 ... # 需要执行的代码块 case pattern_2: # 模式，待匹配的条件2 ... # 需要执行的代码块 case _: # 模式，表示default ... # 需要执行的代码块 ","date":"2021年11月10日","objectID":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/:1:1","tags":["Python"],"title":"Python3.10新特性初体验","uri":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Python"],"content":"2、模式 1. as模式(AS) def simplify_expr(tokens): match tokens: case [('(' | '[') as l, *expr, (')' | ']') as r] if (l + r) in ('()', '[]'): # 第一个参数得为('(' | '['),取别名为l # 最后一个参数得为('(' | '['),取别名为r # 并且需判断(l + r) in ('()', '[]')为True才会进入此代码块执行 print(expr) case [0, ('+' | '-') as op, right]: # 第一个参数必须为0 # 第二个参数得为('+' | '-'),取别名为op # 第三个参数为任意数 # 序列的长度必须为3个 print(op, right) case [(int() | float()) as value]: # 序列的长度只能有1个 # 并且，类型只能是int或者float print(value) case _: # 匹配不到则走这里 print(\"未匹配到\") simplify_expr(['(', \"aaa\", \"bbb\", \")\"]) # ['aaa', 'bbb'] simplify_expr(['[', \"aaa\", \"bbb\", \"]\"]) # ['aaa', 'bbb'] simplify_expr(['[', \"aaa\", \"bbb\", \")\"]) # 未匹配到 simplify_expr(['[', \"]\"]) # [] simplify_expr(['bbb', '[', \"]\"]) # 未匹配到 simplify_expr([0, \"+\", 3]) # + 3 simplify_expr([0, \"-\", 3]) # - 3 simplify_expr([0, \"-\", 3, 34]) # 未匹配到 simplify_expr([1]) # 1 simplify_expr([1.0]) # 1.0 simplify_expr([1.0, 1]) # 未匹配到 simplify_expr([\"aaaa\"]) # 未匹配到 2. or模式(|) def demo(code): match code: case 200: print(\"200成功了\") case 400 | 404: print(\"出问题了\") case (1002 | 1006, 200): # 把两个值组织起来（组织模式） print(\"接口请求成功\") case _: print(\"匹配不到\") demo(200) # 200成功了 demo(400) # 出问题了 demo(404) # 出问题了 demo((1006, 200)) # 接口请求成功 demo(502) # 匹配不到 3. 文字模式(Literal) def simplify(expr): match expr: case ('+', 0, x): return x case ('+' | '-', x, 0): return x case ('and', True, x): return x case ('and', False, x): return False case ('or', False, x): return x case ('or', True, x): return True case ('not', ('not', x)): return x return expr print(simplify(('+', 0, 12))) # 12 print(simplify(('+', 13, 0))) # 13 print(simplify(('-', 13, 0))) # 13 print(simplify(('and', True, 0))) # 0 print(simplify(('and', False, 0))) # False print(simplify(('or', False, 1))) # 1 print(simplify(('or', True, 1))) # True print(simplify(('not', ('not', 23)))) # 23 4. 捕获模式(Capture) def average(*args): match args: case [x, y]: return (x + y) / 2 case [x]: return x case []: return 0 case [x, y, z]: return x + y + z case a: return sum(a) / len(a) print(average(1, 2, 3, 4)) # 2.5 ==\u003e a ==\u003e sum(a) / len(a)==\u003e (1+2+3+4)/4 = 2.5 print(average(1, 2)) # 1.5 ==\u003e [x, y] ==\u003e (x+y)/2 ==\u003e (1+2)/2=1.5 print(average(1)) # 1 ==\u003e [x] ==\u003e x=1 print(average()) # 0 ==\u003e [] ==\u003e 0 # 如果传递的是三个元素，则会按照长度进行匹配，跟传字典类型不同 print(average(1, 2, 3)) # 6 ==\u003e [x, y, z] ==\u003e 1+2+3=6 5. 通配符模式(Wildcard) _：在前面就表示任意字符 case __：这里的__在末尾，表示default默认 def is_closed(sequence): match sequence: case [_]: # 只有一个元素的序列 return True case [start, *_, end]: # 至少含有两个元素的序列 return start == end case _: # 匹配任意类型 return False print(is_closed(1)) # False ==\u003e _ ==\u003e False print(is_closed([1])) # True ==\u003e [_] ==\u003e True print(is_closed([1, 2, 3])) # False ==\u003e [start, *_, end] ==\u003e\u003e1 ==3 ==\u003eFalse 6. 值模式(value) class HttpStatus(object): OK = 200 MOVED_PERMANENTLY = 301 NOT_FOUND = 404 class MimeType(object): TEXT = \"text\" APPL_ZIP = \"appl_zip\" def handle_reply(reply): match reply: case (HttpStatus.OK, MimeType.TEXT, body): print(f\"请求成功，类型是TEXT,body==\u003e{body}\") case (HttpStatus.OK, MimeType.APPL_ZIP, body): print(f\"请求成功，类型是APPL_ZIP,body==\u003e{body}\") case (HttpStatus.MOVED_PERMANENTLY, new_URI): print(f\"301了，赶紧检查下URI==\u003e{new_URI}\") case (HttpStatus.NOT_FOUND): print(\"网站挂了。。。\") handle_reply([200, \"text\", \"dddddd\"]) # 请求成功，类型是TEXT,body==\u003edddddd handle_reply([200, \"appl_zip\", \"dddddd\"]) # 请求成功，类型是APPL_ZIP,body==\u003edddddd handle_reply([200, \"appl_zip\", \"dddddd\"]) # 请求成功，类型是APPL_ZIP,body==\u003edddddd handle_reply([301, \"sip:smith@zte.com.cn\"]) # 301了，赶紧检查下URI==\u003esip:smith@zte.com.cn handle_reply(404) # 网站挂了。。。 7. 组织模式(Group) 使用or模式实现 def demo(code): match code: case 200: print(\"200成功了\") case 400 | 404: print(\"出问题了\") case (1002 | 1006, 200): # 把两个值组织起来（组织模式） print(\"接口请求成功\") case _: print(\"匹配不到\") demo((1006, 200)) # 接口请求成功 8. 序列模式(Sequence) def is_closed(sequence): match sequence: case [_]: # 只有一个元素的序列 return True case [start, *_, end]: # 至少含有两个元素的序列 return start == end case _: # 匹配任意类型 return False print(is_closed(1)) # False ==\u003e _ ==\u003e False print(is_closed([1])) # True ==\u003e [_] ==\u003e True print(is_closed([1, 2, 3])) #","date":"2021年11月10日","objectID":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/:1:2","tags":["Python"],"title":"Python3.10新特性初体验","uri":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Python"],"content":"3、匹配要注意的顺序 当 match 的对象是一个 list 或者 tuple 的时候，需要长度和元素值都能匹配，才能命中，在 捕获模式中体现的有。 当 match 的对象是一个 dict 的时候，规则却有所不同，只要 case 表达式中的 key 在所 match 的对象中有存在，即可命中，在 映射模式中体现的有。 而当 match 的对象是类对象时，匹配的规则是，跟 dict 有点类似，只要对象类型和对象的属性有满足 case 的条件，就能命中，在 类模式中体现的有。 ","date":"2021年11月10日","objectID":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/:1:3","tags":["Python"],"title":"Python3.10新特性初体验","uri":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Python"],"content":"二、union类型允许X | Y （PEP 604） 新的语法union接受函数,变量和参数注释。 ","date":"2021年11月10日","objectID":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/:2:0","tags":["Python"],"title":"Python3.10新特性初体验","uri":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Python"],"content":"1、简单的语法 # before from typing import List, Union, Optional def f(list: List[Union[int, str]], param: Optional[int]) -\u003e Union[float, str]: pass # now 更加简洁了 from typing import List def f(list: List[int | str], param: int | None) -\u003e float | str: pass ","date":"2021年11月10日","objectID":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/:2:1","tags":["Python"],"title":"Python3.10新特性初体验","uri":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Python"],"content":"2、typing.Union 和 | 是等价的 int | str == typing.Union[int, str] # True ","date":"2021年11月10日","objectID":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/:2:2","tags":["Python"],"title":"Python3.10新特性初体验","uri":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Python"],"content":"3、顺序是没有要求的 (int | str) == (str | int) # True (int | str | float) == typing.Union[str, float, int] # True ","date":"2021年11月10日","objectID":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/:2:3","tags":["Python"],"title":"Python3.10新特性初体验","uri":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Python"],"content":"4、isinstance和issubclass支持 isinstance(5, int | str) # True isinstance(\"aaa\", int | str) # True isinstance(1.22, int | str) # False issubclass(bool, int | float) # True isinstance(None, int | None) # True isinstance(42, None | int) # True ","date":"2021年11月10日","objectID":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/:2:4","tags":["Python"],"title":"Python3.10新特性初体验","uri":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Python"],"content":"三、带圆括号的上下文管理器 已支持使用外层圆括号来使多个上下文管理器可以连续多行地书写。 这允许将过长的上下文管理器集能够以与之前 import 语句类似的方式格式化为多行的形式。 一下四种格式都是支持的 # 之前的格式不影响使用 with open(\"readme.md\", 'r') as f: pass with (open(\"readme.md\", 'r') as f): pass with (open(\"readme.md\", 'r') as f1, open(\"readme.md\", 'r') as f2): pass with (open(\"readme.md\", 'r'), open(\"readme.md\", 'r') as f2): pass with (open(\"readme.md\", 'r'), open(\"readme.md\", 'r'), ): pass ","date":"2021年11月10日","objectID":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/:3:0","tags":["Python"],"title":"Python3.10新特性初体验","uri":"/2021/11/python3.10%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["Python"],"content":"一、getattr解析 ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:0:0","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"1.1 getattr是什么？ getattr() 函数获取某个类实例对象中指定属性的值 ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:1:0","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"1.2 语法格式 getattr(obj, name[, default]) obj 表示指定的类实例对象 name 表示指定的属性名 default 是可选参数，用于设定该函数的默认返回值 即当函数查找失败时，如果不指定 default 参数，则程序将直接报 AttributeError 错误 反之该函数将返回 default 指定的值。 ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:2:0","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"1.3 使用 ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:3:0","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"1.3.1 构造一个类方法 class KeyWord(object): driver = \"chrome驱动\" def openBrowser(self, browser): print(f\"openBrowser is running {browser}\") ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:3:1","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"1.3.2 调用存在的类属性 kw = Keywork() driver = getattr(kw, \"driver\") print(driver) # ---------------------- chrome驱动 ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:3:2","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"1.3.3 调用不存在的类属性(会报错) name = getattr(kw, \"name\") print(name) # ------------------- AttributeError: 'Keywork' object has no attribute 'name' ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:3:3","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"1.3.4 调用不存在的类属性(设置默认值) name = getattr(kw, \"name\",\"Desire\") print(name) # ------------------- Desire ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:3:4","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"1.3.5 调用类方法 openBrowser = getattr(kw, \"openBrowser\") # 获取类方法 openBrowser(browser=\"Chrome\") # 调用类方法 二、methodcaller解刨 ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:3:5","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"2.1 methodcaller 是什么？ Python内部提供的一个可以通过字符串调用类方法的一个包，在operator库中。 ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:4:0","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"2.2 使用 ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:5:0","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"2.2.1 导包 from operator import methodcaller ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:5:1","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"2.2.2 使用字符串\"openBrowser\"执行对应的openBrowser类方法 method = methodcaller(\"openBrowser\", browser=\"Chrome\") keyword = KeyWord() method(keyword) ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:5:2","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"2.2.3 执行结果 # -------------------------------- openBrowser is running Chrome ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:5:3","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"2.3 解刨 ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:6:0","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"2.3.1 源码 def methodcaller(name, /, *args, **kwargs): def caller(obj): return getattr(obj, name)(*args, **kwargs) return caller ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:6:1","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["Python"],"content":"2.3.2 解读 采用了闭包的形式 调用methodcaller函数时，返回的是methodcaller内部的函数 也就是说调用后返回的还是一个函数 调用methodcaller函数的返回值（method），其实就是caller(obj) method == caller，所以我们可以通过method(obj)执行methodcaller内部方法caller中的函数体了 caller函数操作：通过getattr() 函数从指定的对象返回指定属性的值，从而实现了通过字符串调用类方法 三、比对总结 从上面的methodcaller源码和解读中可以看到，methodcaller底层还是使用的getattr，对于字符串调用类方法，这两种方式都是可行的，自行选择使用。 ","date":"2021年07月25日","objectID":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/:6:2","tags":["Python"],"title":"Getattr和methodcaller剖析","uri":"/2021/07/getattr%E5%92%8Cmethodcaller%E5%89%96%E6%9E%90/"},{"categories":["测试","Python"],"content":"Allure报告趋势图本地显示","date":"2021年05月12日","objectID":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/","tags":["Allure","Python"],"title":"Allure报告趋势图本地显示","uri":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/"},{"categories":["测试","Python"],"content":"众所周知，allure趋势图在本地运行的时候，总是显示的空白，但与Jenkins集成后，生成的报告却显示了整个趋势。 如果不与Jenkins集成就真的没办法展示趋势图吗？ 答案是NO，没有趋势图我们就自己写👀 ","date":"2021年05月12日","objectID":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/:0:0","tags":["Allure","Python"],"title":"Allure报告趋势图本地显示","uri":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/"},{"categories":["测试","Python"],"content":"一、首先看下Jenkins集成allure展示的趋势图是什么样子的 展示了每次运行的结果 对应构建的次数 点击可以跳转到对应的构建结果报告 整体趋势一目了然 ","date":"2021年05月12日","objectID":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/:0:1","tags":["Allure","Python"],"title":"Allure报告趋势图本地显示","uri":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/"},{"categories":["测试","Python"],"content":"二、研究Jenkins生成的allure报告有什么规律 1、打开家目录中的 .jenkins/jobs/test (test是Jenkins上的任务名称) 2、builds构建历史都在此文件夹中 3、进去每次构建的文件夹即可看到每次的构建结果 4、archive文件夹存放的就是每次生成的allure报告压缩包 5、解压后，找到 history-trend.json这个json里面存放的就是每次的构建结果，看名字就能得知 历史趋势 6、分析 history-trend.json文件的规律 整体的文件里面最外层是一个\"列表\" “列表\"里面嵌套的是每次构建的历史，是一个\"字典” 每一个\"字典\"里面又包含 buildOrder：构建次数 reportUrl：报告的url reportName：报告名称 data：报告执行结果 7、再回过头看下我们自己生成的报告中的 history-trend.json 1）使用命令 allure generate test_allure_reports -o allure-reports --clean将报告转成一个静态工程 2）找到 history-trend.json 3）history-trend.json文件里面数据只有 data，并没有构建次数、报告url和报告名称 8、总结 每次生成报告的时候需要在 history-trend.json文件更新之前运行的结果 并且要在 history-trend.json文件中的每次生成报告的时候添加 构建次数和 报告url 添加构建次数是为了使得趋势图能够按照顺序展示 添加报告url是为了使得点击趋势图可以进行跳转，查看历史报告 ","date":"2021年05月12日","objectID":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/:0:2","tags":["Allure","Python"],"title":"Allure报告趋势图本地显示","uri":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/"},{"categories":["测试","Python"],"content":"三、正式开始改造报告 目标： 每次的报告都要进行储存 history-trend.json里面的数据每次都要把历史的数据更新进去 history-trend.json数据里面的\"字典\"需要添加至少两个\"key\"：buildOrder、reportUrl、reportName（这个可要可不要） 每次运行 buildOrder要增1，reportUrl是报告要访问的url history-trend.json数据要根据每个\"字典\"中的 buildOrder从大到小进行排序 history-trend.json历史数据需要进行备份，方便新生成的报告进行历史数据写入 第一步：对每次生成的报告进行储存 # 生成Allure报告 # BASEDIR 是项目位置 # ALLURE_DIR是allure报告存放位置 # ALLURE_PATH 是根据当前时间戳生成allure报告 ALLURE_PATH = os.path.join(ALLURE_DIR, str(int(time()))) command = f'pytest {BASEDIR} -s --alluredir={ALLURE_PATH}' os.system(command) # 对生成的Allure报告进行进一步演进（生成一个相对独立的报告静态工程） # ALLURE_PLUS_DIR 是存放要生成的报告 # buildOrder 是表示以构建次数为文件夹名称 command = f\"allure generate {ALLURE_PATH} -o {os.path.join(ALLURE_PLUS_DIR,str(buildOrder))} --clean\" os.system(command) 第二步：获取历史数据和构建次数 def get_dirname(): hostory_file = os.path.join(ALLURE_PLUS_DIR, \"history.json\") if os.path.exists(hostory_file): with open(hostory_file) as f: li = eval(f.read()) # 根据构建次数进行排序，从大到小 li.sort(key=lambda x: x['buildOrder'], reverse=True) # 返回下一次的构建次数，所以要在排序后的历史数据中的buildOrder+1 return li[0][\"buildOrder\"]+1, li else: # 首次进行生成报告，肯定会进到这一步，先创建history.json,然后返回构建次数1（代表首次） with open(hostory_file, \"w\") as f: pass return 1, None 第二步：更新备份历史数据 history.json和每个报告中的 history-trend.json def update_trend_data(dirname, old_data: list): \"\"\" dirname：构建次数 old_data：备份的数据 update_trend_data(get_dirname()) \"\"\" WIDGETS_DIR = os.path.join(ALLURE_PLUS_DIR, f\"{str(dirname)}/widgets\") # 读取最新生成的history-trend.json数据 with open(os.path.join(WIDGETS_DIR, \"history-trend.json\")) as f: data = f.read() new_data = eval(data) if old_data is not None: new_data[0][\"buildOrder\"] = old_data[0][\"buildOrder\"]+1 else: old_data = [] new_data[0][\"buildOrder\"] = 1 # 给最新生成的数据添加reportUrl key，reportUrl要根据自己的实际情况更改 new_data[0][\"reportUrl\"] = f\"{allure_url}/{dirname}/index.html\" # 把最新的数据，插入到备份数据列表首位 old_data.insert(0, new_data[0]) # 把所有生成的报告中的history-trend.json都更新成新备份的数据old_data，这样的话，点击历史趋势图就可以实现新老报告切换 for i in range(1, dirname+1): with open(os.path.join(ALLURE_PLUS_DIR, f\"{str(i)}/widgets/history-trend.json\"), \"w+\") as f: f.write(json.dumps(old_data)) # 把数据备份到history.json hostory_file = os.path.join(ALLURE_PLUS_DIR, \"history.json\") with open(hostory_file, \"w+\") as f: f.write(json.dumps(old_data)) return old_data, new_data[0][\"reportUrl\"] 第三步：调用顺序（需要使用 os.system进行执行命令行） ALLURE_PATH = os.path.join(ALLURE_DIR, str(int(time()))) command = f'pytest {BASEDIR} -s --alluredir={ALLURE_PATH}' os.system(command) # 先调用get_dirname()，获取到这次需要构建的次数 buildOrder, old_data = get_dirname() # 再执行命令行 command = f\"allure generate {ALLURE_PATH} -o {os.path.join(ALLURE_PLUS_DIR,str(buildOrder))} --clean\" os.system(command) # 执行完毕后再调用update_trend_data() all_data,reportUrl = update_trend_data(buildOrder, old_data) ","date":"2021年05月12日","objectID":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/:0:3","tags":["Allure","Python"],"title":"Allure报告趋势图本地显示","uri":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/"},{"categories":["测试","Python"],"content":"四、看下实现后的效果 趋势图 报告截图 ","date":"2021年05月12日","objectID":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/:0:4","tags":["Allure","Python"],"title":"Allure报告趋势图本地显示","uri":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/"},{"categories":["测试","Python"],"content":"五、跟Jenkins进行对比（一毛一样）😊 ","date":"2021年05月12日","objectID":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/:0:5","tags":["Allure","Python"],"title":"Allure报告趋势图本地显示","uri":"/2021/05/allure%E6%8A%A5%E5%91%8A%E8%B6%8B%E5%8A%BF%E5%9B%BE%E6%9C%AC%E5%9C%B0%E6%98%BE%E7%A4%BA/"},{"categories":null,"content":"关于我 ","date":"2022年06月13日","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]